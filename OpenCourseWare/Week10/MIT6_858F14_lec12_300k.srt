1
00:00:00,080 --> 00:00:02,430
Konten berikut diberikan
di bawah lisensi

2
00:00:02,430 --> 00:00:03,810
Creative Commons.

3
00:00:03,810 --> 00:00:06,060
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,060 --> 00:00:10,150
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,150 --> 00:00:12,690
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:12,690 --> 00:00:16,600
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:16,600 --> 00:00:17,260
di ocw.mit.edu.

8
00:00:26,640 --> 00:00:29,142
PROFESOR: Baiklah,
teman-teman, mari kita mulai.

9
00:00:29,142 --> 00:00:31,350
Jadi hari ini, kita akan
bicara tentang keamanan jaringan.

10
00:00:31,350 --> 00:00:32,933
Dan secara spesifik,
kita akan bicara

11
00:00:32,933 --> 00:00:35,550
tentang paper ini terkait keamanan
TCP/IP oleh orang ini

12
00:00:35,550 --> 00:00:40,027
Steve Bellovin, yang dulu di
AT&T dan sekarang di Columbia.

13
00:00:40,027 --> 00:00:41,610
Satu hal menarik tentang
paper ini

14
00:00:41,610 --> 00:00:43,276
adalah paper ini
sebenarnya sudah relatif tua.

15
00:00:43,276 --> 00:00:44,584
Sudah lebih dari 10 tahun umurnya.

16
00:00:44,584 --> 00:00:46,209
Dan sebenarnya, paper
tersebut mengomentari paper lain

17
00:00:46,209 --> 00:00:48,520
yang diterbitkan 10 tahun sebelumnya.

18
00:00:48,520 --> 00:00:51,840
Dan banyak dari kalian
bertanya, mengapa kita membaca ini

19
00:00:51,840 --> 00:00:54,500
jika banyak masalah yang dibahas di sini
sudah diperbaiki pada protokol

20
00:00:54,500 --> 00:00:55,980
TCP saat ini?

21
00:00:55,980 --> 00:00:57,429
Jadi satu poin
penting-- jadi

22
00:00:57,429 --> 00:00:59,220
benar bahwa beberapa dari
masalah yang Steve

23
00:00:59,220 --> 00:01:02,061
jelaskan pada paper ini
sudah diperbaiki sejak saat itu.

24
00:01:02,061 --> 00:01:04,019
Beberapa di antaranya sebenarnya
masih merupakan masalah saat ini.

25
00:01:04,019 --> 00:01:07,145
Kita akan melihat hal tersebut
dan mengamati apa yang terjadi.

26
00:01:07,145 --> 00:01:09,925
Tapi Anda mungkin
bertanya, mengapa orang-orang

27
00:01:09,925 --> 00:01:11,970
tidak memikirikan masalah
ini pada saat itu

28
00:01:11,970 --> 00:01:13,730
saat mereka merancang TCP?

29
00:01:13,730 --> 00:01:15,480
Apa yang mereka pikirikan?

30
00:01:15,480 --> 00:01:17,507
Dan sebenarnya tidak jelas.

31
00:01:17,507 --> 00:01:18,590
Jadi menurut Anda bagaimana?

32
00:01:18,590 --> 00:01:21,440
Mengapa TCP tidak dirancang
untuk aman dengan semua

33
00:01:21,440 --> 00:01:23,916
pertimbangan ini di awal?

34
00:01:23,916 --> 00:01:26,596
Ya, ada yang mau menebak?

35
00:01:26,596 --> 00:01:27,760
Baik, yang lain?

36
00:01:27,760 --> 00:01:28,260
Ya.

37
00:01:28,260 --> 00:01:30,052
AUDIENS: Internet saat itu
merupakan tempat yang lebih

38
00:01:30,052 --> 00:01:30,500
bisa dipercaya.

39
00:01:30,500 --> 00:01:32,250
PROFESOR: Ya, yang Anda katakan
hampir secara literal

40
00:01:32,250 --> 00:01:33,515
sama dengan yang ditulis di paper tersebut.

41
00:01:33,515 --> 00:01:36,445
Ya, pada saat itu-- seluruh
set protokol internet

42
00:01:36,445 --> 00:01:39,700
yang dirancang saya rasa
sekitar 40 tahun lalu.

43
00:01:39,700 --> 00:01:41,366
Kebutuhan-kebutuhannya
sangat berbeda.

44
00:01:41,366 --> 00:01:44,450
Yaitu untuk menghubungkan beberapa
situs yang relatif saling bisa dipercaya

45
00:01:44,450 --> 00:01:47,070
di mana mereka saling
kenal berdasarkan nama.

46
00:01:47,070 --> 00:01:50,510
Dan saya rasa ini seringkali
menjadi kasus pada sistem apapun yang

47
00:01:50,510 --> 00:01:51,420
menjadi sukses.

48
00:01:51,420 --> 00:01:52,600
Kebutuhan-kebutuhannya berubah.

49
00:01:52,600 --> 00:01:54,864
Jadi saat itu
ini adalah protokol

50
00:01:54,864 --> 00:01:56,030
untuk beberapa situs.

51
00:01:56,030 --> 00:01:57,530
Sekarang menjadi seluruh dunia.

52
00:01:57,530 --> 00:01:58,990
Dan Anda tidak lagi tahu
nama seluruh orang yang

53
00:01:58,990 --> 00:02:00,175
terkoneksi ke
internet.

54
00:02:00,175 --> 00:02:01,633
Anda tidak bisa
menelepon mereka

55
00:02:01,633 --> 00:02:03,470
jika mereka melakukan
hal buruk, dan lainnya.

56
00:02:03,470 --> 00:02:05,650
Jadi saya rasa ini menjadi cerita
untuk sebagian besar protokol

57
00:02:05,650 --> 00:02:06,170
yang kita lihat.

58
00:02:06,170 --> 00:02:08,520
Dan banyak dari Anda bertanya,
seperti, apa sebenarnya

59
00:02:08,520 --> 00:02:09,561
yang mereka pikirkan?

60
00:02:09,561 --> 00:02:10,312
Ini sangat buruk.

61
00:02:10,312 --> 00:02:12,811
Tapi faktanya, mereka merancang
sistem yang sangat berbeda.

62
00:02:12,811 --> 00:02:13,660
Sistem itu digunakan banyak pihak.

63
00:02:13,660 --> 00:02:15,243
Sama seperti web,
yang kita diskusikan

64
00:02:15,243 --> 00:02:17,060
pada beberapa minggu lalu.

65
00:02:17,060 --> 00:02:18,950
Web dirancang untuk
tujuan yang sangat berbeda.

66
00:02:18,950 --> 00:02:19,944
Dan web berkembang.

67
00:02:19,944 --> 00:02:21,610
Dan Anda mengalami
kesulitan ini

68
00:02:21,610 --> 00:02:24,760
Anda harus memikirkan bagaimana
membuat protokol beradaptasi

69
00:02:24,760 --> 00:02:26,750
ke kebutuhan-kebutuhan baru.

70
00:02:26,750 --> 00:02:29,370
Dan hal lain yang kurang
lebih tiba-tiba terjadi

71
00:02:29,370 --> 00:02:31,370
adalah saya rasa orang-orang
juga dalam prosesnya

72
00:02:31,370 --> 00:02:32,814
mendapatkan apresiasi
yang lebih besar

73
00:02:32,814 --> 00:02:34,230
untuk masalah-masalah
yang Anda punya

74
00:02:34,230 --> 00:02:35,970
untuk dikhawatirkan di sisi keamanan.

75
00:02:35,970 --> 00:02:38,520
Dan saat itu pula
Anda tidak benar-benar

76
00:02:38,520 --> 00:02:39,960
mengerti hal-hal
yang Anda

77
00:02:39,960 --> 00:02:42,870
harus khawatirkan tentang
apa yang penyerang lakukan terhadap sistem Anda.

78
00:02:42,870 --> 00:02:44,520
Dan saya rasa untuk
sebagian alasan ini

79
00:02:44,520 --> 00:02:46,400
menarik untuk
melihat

80
00:02:46,400 --> 00:02:48,960
apa yang terjadi terhadap
keamanan TCP, apa yang salah,

81
00:02:48,960 --> 00:02:51,639
bagaimana kita memperbaikinya,
dan lain-lain, untuk mengetahui

82
00:02:51,639 --> 00:02:54,180
masalah apa yang ingin
Anda hindari saat merancang

83
00:02:54,180 --> 00:02:56,980
protokol Anda sendiri,
dan juga apa

84
00:02:56,980 --> 00:02:59,765
pola pikir yang benar untuk berpikir
tentang serangan-serangan ini.

85
00:02:59,765 --> 00:03:02,410
Bagaimana Anda menemukan
apa yang penyerang mungkin

86
00:03:02,410 --> 00:03:03,840
lakukan pada
protokol Anda sendiri

87
00:03:03,840 --> 00:03:08,290
saat Anda merancangnya sehingga
Anda dapat menghindari kelemahan yang sama?

88
00:03:08,290 --> 00:03:10,152
Baiklah, setelah
pengantar tersebut,

89
00:03:10,152 --> 00:03:12,610
mari kita benar-benar membicarakan
apa yang dibahas pada paper ini.

90
00:03:12,610 --> 00:03:15,770
Jadi bagaimana seharusnya kita berpikir
tentang keamanan dalam jaringan?

91
00:03:15,770 --> 00:03:18,620
Jadi saya rasa kita bisa mencoba
untuk mulai dari prinsip-prinsip pertama

92
00:03:18,620 --> 00:03:22,350
dan mencoba mengetahui,
apa model ancaman kita?

93
00:03:22,350 --> 00:03:24,220
Jadi apa yang kita pikir
penyerang akan

94
00:03:24,220 --> 00:03:28,210
bisa lakukan pada
jaringan kita?

95
00:03:28,210 --> 00:03:29,980
Yah, cukup
jelas,

96
00:03:29,980 --> 00:03:36,340
mereka diasumsikan bisa
mencegat paket-paket,

97
00:03:36,340 --> 00:03:38,110
dan mungkin bisa
mengubahnya.

98
00:03:41,000 --> 00:03:42,960
Jadi jika Anda mengirim paket
melalui jaringan

99
00:03:42,960 --> 00:03:45,800
mungkin bijak untuk mengasumsikan
bahwa beberapa orang jahat di luar sana

100
00:03:45,800 --> 00:03:48,540
akan melihat paket Anda dan 
mungkin bisa mengubahnnya

101
00:03:48,540 --> 00:03:49,980
sebelum paket tersebut sampai
pada tujuannya,

102
00:03:49,980 --> 00:03:52,440
bisa menghapusnya,
dan bahkan bisa

103
00:03:52,440 --> 00:03:54,740
menyisipkan paket
milik orang jahat tersebut

104
00:03:54,740 --> 00:03:59,170
yang Anda tidak pernah
kirimkan ke kontak manapun.

105
00:03:59,170 --> 00:04:02,605
Dan mungkin-- jadi
ini mungkin Anda dapat

106
00:04:02,605 --> 00:04:04,480
dengan menemukannya
hanya dengan berpikir

107
00:04:04,480 --> 00:04:07,010
sederhana, yah, jika
Anda tidak mempercayai jaringan,

108
00:04:07,010 --> 00:04:09,490
seorang yang jahat akan
mengirimkan paket-paket acak,

109
00:04:09,490 --> 00:04:11,470
melihat paket-paket Anda,
mengubahnya, dan lain-lain.

110
00:04:11,470 --> 00:04:15,240
Yang agak lebih mengkhawatirkan,
seperti yang dibahas pada paper ini,

111
00:04:15,240 --> 00:04:17,720
orang jahat tersebut juga bisa
berpartisipasi pada protokol Anda.

112
00:04:17,720 --> 00:04:19,178
Merek punya
mesin sendiri, bukan?

113
00:04:19,178 --> 00:04:22,490
Jadi si penyerang punya
komputer mereka sendiri

114
00:04:22,490 --> 00:04:23,990
di mana mereka memiliki
kontrol penuh.

115
00:04:23,990 --> 00:04:29,450
Jadi bahkan jika semua
komputer yang Anda percayai

116
00:04:29,450 --> 00:04:32,187
dikelola secara baik,
mereka berlaku secara benar,

117
00:04:32,187 --> 00:04:34,020
orang jahat tersebut punya komputer
nya sendiri di mana dia dapat

118
00:04:34,020 --> 00:04:35,700
membuatnya melakukan apapun yang dia inginkan.

119
00:04:35,700 --> 00:04:37,840
Dan faktanya, dia dapat
berpartisipasi dalam protokol

120
00:04:37,840 --> 00:04:39,743
atau mendistribusikan sebuah sistem.

121
00:04:45,150 --> 00:04:47,000
Jadi jika Anda memiliki
protokol pengaturan rute, yang

122
00:04:47,000 --> 00:04:49,835
melibatkan banyak orang berkomunikasi
satu dengan yang lain, pada skala tertentu,

123
00:04:49,835 --> 00:04:51,710
mungkin akan tidak
praktis untuk menjaga

124
00:04:51,710 --> 00:04:52,484
orang jahat untuk tetap berada di luar.

125
00:04:52,484 --> 00:04:54,900
Jika Anda menjalankan protokol pengaturan
rute dengan 10 partisipan,

126
00:04:54,900 --> 00:04:57,170
maka Anda dapat dengan mudah
mengontak mereka semua dan, yah,

127
00:04:57,170 --> 00:04:58,380
yah, saya kenal kalian semua.

128
00:04:58,380 --> 00:05:00,720
Tapi pada skala internet
hari ini, tidaklah

129
00:05:00,720 --> 00:05:04,300
masuk akal untuk mendapatkan
informasi terkait apa

130
00:05:04,300 --> 00:05:07,236
atau siapakah orang-orang lain
tersebut dalam protokol ini.

131
00:05:07,236 --> 00:05:08,610
Jadi mungkin beberapa
orang jahat akan

132
00:05:08,610 --> 00:05:11,160
berpartisipasi pada protokol
Anda atau sistem

133
00:05:11,160 --> 00:05:11,660
terdistribusi.

134
00:05:11,660 --> 00:05:13,868
Dan penting untuk merancang
sistem terdistribusi yang

135
00:05:13,868 --> 00:05:17,955
dapat paling tidak melakukan sesuatu
yang masuk akal terkait hal tersebut.

136
00:05:17,955 --> 00:05:19,580
Baiklah, jadi
apa implikasi

137
00:05:19,580 --> 00:05:20,280
dari hal-hal ini?

138
00:05:20,280 --> 00:05:21,680
Saya rasa kita akan melihat daftarnya.

139
00:05:21,680 --> 00:05:26,570
Jadi mencegat adalah-- pada
dasarnya mudah untuk memahaminya.

140
00:05:26,570 --> 00:05:29,170
Yah, Anda sebaiknya tidak
mengirimkan data penting

141
00:05:29,170 --> 00:05:32,380
melalui jaringan jika Anda berharap
orang jahat akan mencegatnya,

142
00:05:32,380 --> 00:05:33,680
atau paling tidak jangan dalam
bentuk yang tidak terenkripsi.

143
00:05:33,680 --> 00:05:35,480
Mungkin Anda harus
mengenkripsi data Anda.

144
00:05:35,480 --> 00:05:37,785
Jadi itu sepertinya cukup
masuk akal untuk

145
00:05:37,785 --> 00:05:38,565
dipahami.

146
00:05:38,565 --> 00:05:41,106
Walaupun tetap saja Anda harus
pikirkan hal tersebut, tentu saja,

147
when designing protocols.
saat merancang protokol.

148
00:05:43,070 --> 00:05:46,770
Sekarang, menyisipkan paket
ternyata berdampak

149
00:05:46,770 --> 00:05:50,380
pada masalah yang jauh
lebih besar dan menarik

150
00:05:50,380 --> 00:05:51,970
menurut paper ini.

151
00:05:51,970 --> 00:05:55,160
Dan khususnya,
penyerang dapat menginjeksi

152
00:05:55,160 --> 00:05:58,860
paket-paket yang berpura-pura 
berasal dari pengirim lain.

153
00:05:58,860 --> 00:06:02,295
Karena cara kerjanya
adalah paket IP tersebut

154
00:06:02,295 --> 00:06:04,420
memiliki header yang mengandung
sumber paket

155
00:06:04,420 --> 00:06:06,080
dan tujuannya.

156
00:06:06,080 --> 00:06:08,830
Dan terserah kepada siapapun
yang membuat paket

157
00:06:08,830 --> 00:06:11,750
untuk mengisi nilai yang tepat 
untuk sumber dan tujuan

158
00:06:11,750 --> 00:06:14,100
dan tidak seorang pun memeriksa 
apakah sumbernya merupakan

159
00:06:14,100 --> 00:06:16,100
sumber yang tepat.

160
00:06:16,100 --> 00:06:18,050
Ada berapa peyaringan 
yang terjadi belakangan ini.

161
00:06:18,050 --> 00:06:21,430
Tapi biasanya kurang bagus,
dan sulit untuk diandalkan.

162
00:06:21,430 --> 00:06:23,115
Jadi untuk perkiraan
pertama, seorang penyerang

163
00:06:23,115 --> 00:06:25,340
dapat mengisi alamat IP
apa pun sebagai sumber,

164
00:06:25,340 --> 00:06:29,180
dan itu akan sampai ke
tujuan dengan benar.

165
00:06:29,180 --> 00:06:32,070
Dan menarik
untuk mencoba mencari tahu

166
00:06:32,070 --> 00:06:35,540
apa yang bisa dilakukan penyerang
dengan kemampuan pengiriman

167
00:06:35,540 --> 00:06:37,670
paket acak.

168
00:06:37,670 --> 00:06:41,771
Sekarang, di beberapa
minggu sampai minggu ini,

169
00:06:41,771 --> 00:06:43,520
seperti di buffer overflow
dan keamanan web,

170
00:06:43,520 --> 00:06:46,110
kita sudah melihat, secara umum,
bug implementasi, seperti,

171
00:06:46,110 --> 00:06:48,440
bagaimana Anda bisa mengeksploitasi
sebuah buffer overflow?

172
00:06:48,440 --> 00:06:50,420
Dan yang menarik,
penulis paper ini

173
00:06:50,420 --> 00:06:53,010
sebenarnya sama sekali tidak
tertarik pada bug

174
00:06:53,010 --> 00:06:53,510
implementasi.

175
00:06:53,510 --> 00:06:56,770
Dia sangat tertarik dengan
kesalahan pada

176
00:06:56,770 --> 00:06:57,562
protokol.

177
00:06:57,562 --> 00:06:58,520
Jadi apa masalahnya?

178
00:06:58,520 --> 00:07:00,580
Mengapa dia mengabaikan
bug implementasi,

179
00:07:00,580 --> 00:07:02,705
meskipun kita menghabiskan beberapa
minggu untuk melihatnya?

180
00:07:02,705 --> 00:07:03,510
Mengapa itu penting?

181
00:07:03,510 --> 00:07:04,010
Ya.

182
00:07:04,010 --> 00:07:06,828
AUDIENS: Karena kita harus
menjaga bug-bug tersebut [TIDAK TERDENGAR].

183
00:07:06,828 --> 00:07:09,800
PROFESOR: Ya, jadi ini adalah
yang sangat disayangkan dari sebuah bug

184
00:07:09,800 --> 00:07:11,550
dalam desain protokol anda.

185
00:07:11,550 --> 00:07:13,589
Karena sulit untuk diubah.

186
00:07:13,589 --> 00:07:15,130
Jadi jika anda memiliki
bug implementasi,

187
00:07:15,130 --> 00:07:17,350
anda memiliki sebuah
memcpy (memory copy) atau sebuah print-out

188
00:07:17,350 --> 00:07:19,254
dalam bentuk tertentu yang
tidak memeriksa batas-batas.

189
00:07:19,254 --> 00:07:21,420
OK, Anda bisa terapkan pemeriksaan
batas-batas, dan masih berfungsi,

190
00:07:21,420 --> 00:07:22,461
dan sekarang juga sudah aman.

191
00:07:22,461 --> 00:07:23,510
Jadi itu sangat bagus.

192
00:07:23,510 --> 00:07:25,995
Tetapi jika terdapat bug di
spesifikasi protokol,

193
00:07:25,995 --> 00:07:29,140
di bagian bagaimana protokol seharusnya
bekerja, maka memperbaiki bug

194
00:07:29,140 --> 00:07:31,190
akan memerlukan juga
perbaikan protokolnya, yang

195
00:07:31,190 --> 00:07:33,820
artinya berpotensi mempengaruhi
semua sistem yang

196
00:07:33,820 --> 00:07:35,460
ada di luar sana yang menggunakan 
protokol ini.

197
00:07:35,460 --> 00:07:37,340
Jadi jika kita menemukan beberapa
masalah di TCP,

198
00:07:37,340 --> 00:07:38,910
hal tersebut cukup berpotensi
memberikan efek yang parah.

199
00:07:38,910 --> 00:07:42,229
Karena setiap mesin yang menggunakan
TCP harus berubah.

200
00:07:42,229 --> 00:07:43,770
Karena akan sulit
untuk membuat

201
00:07:43,770 --> 00:07:45,790
hal itu kompatibel dengan
versi sebelumnya.

202
00:07:45,790 --> 00:07:48,530
Kita akan lihat sebenarnya
bug macam apakah ini.

203
00:07:48,530 --> 00:07:51,640
Tetapi ini juga menjadi alasan sebenarnya
dia sangat bersemangat melihat

204
00:07:51,640 --> 00:07:52,460
bug protokol.

205
00:07:52,460 --> 00:07:56,555
Karena hal tersebut cukup
mendasar bagi protokol TCP

206
00:07:56,555 --> 00:07:58,982
bahwa setiap orang setuju untuk berkomunikasi.

207
00:07:58,982 --> 00:08:00,440
Jadi mari kita lihat
salah satu dari orang-orang ini.

208
00:08:00,440 --> 00:08:03,950
Jadi contoh pertama yang
dia tunjukkan

209
00:08:03,950 --> 00:08:07,140
berkaitan dengan bagaimana
nomor urut TCP bekerja.

210
00:08:09,720 --> 00:08:13,169
Jadi hanya untuk menjelaskan ulang--
Ya, pertanyaan.

211
00:08:13,169 --> 00:08:14,294
AUDIENS: Saya hanya penasaran.

212
00:08:14,294 --> 00:08:15,502
Ini sedikit keluar dari topik pembahasan.

213
00:08:15,502 --> 00:08:17,606
Tetapi, misalnya Anda
menemukan bug di TCP.

214
00:08:17,606 --> 00:08:19,976
Bagaimana Anda membuat
perubahan di TCP tersebut?

215
00:08:19,976 --> 00:08:21,398
Bagaimana Anda memberi tahu
semua komputer

216
00:08:21,398 --> 00:08:23,736
di dunia untuk merubah itu?

217
00:08:23,736 --> 00:08:25,610
PROFESOR: Ya, saya pikir
hal tersebut merupakan masalah yang besar.

218
00:08:25,610 --> 00:08:26,900
Bagaimana jika Anda menemukan bug di TCP?

219
00:08:26,900 --> 00:08:29,280
Sebenarnya, belum jelas apa yang harus dilakukan.

220
00:08:29,280 --> 00:08:32,530
dan saya pikir penulis disini
kesulitan dengan masalah tersebut.

221
00:08:32,530 --> 00:08:36,165
Dan dalam banyak hal,
jika Anda dapat mendesain ulang TCP

222
00:08:36,165 --> 00:08:37,539
sebagian besar dari bug ini
relatif

223
00:08:37,539 --> 00:08:41,620
mudah diperbaiki jika Anda tahu apa
yang harus diperbaiki dari awal.

224
00:08:41,620 --> 00:08:46,410
Tetapi karena TCP
agak sulit

225
00:08:46,410 --> 00:08:51,350
untuk diperbaiki atau diubah,
yang akhirnya terjadi

226
00:08:51,350 --> 00:08:54,457
adalah bahwa orang atau
desainer mencoba mencari

227
00:08:54,457 --> 00:08:58,135
penyesuaian-penyesuaian yang
kompatibel ke belakang

228
00:08:58,135 --> 00:09:01,170
yang memungkinkan implementasi lama
untuk berjalan bersamaan dengan implementasi baru

229
00:09:01,170 --> 00:09:04,970
atau untuk menambahkan beberapa kolom nilai opsional
yang jika ada di sana, maka

230
00:09:04,970 --> 00:09:08,590
komunikasi menjadi lebih aman
dalam beberapa hal.

231
00:09:08,590 --> 00:09:10,370
Tapi ini masalah besar.

232
00:09:10,370 --> 00:09:14,030
Jika ini masalah keamanan
yang tertanam dalam di TCP,

233
00:09:14,030 --> 00:09:17,750
maka ini akan menjadi masalah yang 
sangat besar bagi semua orang

234
00:09:17,750 --> 00:09:23,930
untuk pindah ke 
versi TCP apa pun, n tambah 1.

235
00:09:23,930 --> 00:09:27,296
Dan Anda dapat melihat IPv6 sebagai 
salah satu contoh bahwa hal ini gagal terjadi.

236
00:09:27,296 --> 00:09:29,170
Kami tahu masalah ini 
akan muncul

237
00:09:29,170 --> 00:09:31,025
selama 15 tahun atau 20 tahun.

238
00:09:31,025 --> 00:09:34,759
IPv6 telah ada selama 
lebih dari 10 tahun sekarang.

239
00:09:34,759 --> 00:09:37,300
Dan sulit untuk meyakinkan orang 
untuk berpindah dari IPv4.

240
00:09:37,300 --> 00:09:38,060
IPv4 sudah cukup bagus.

241
00:09:38,060 --> 00:09:39,040
Dia bekerja dengan baik.

242
00:09:39,040 --> 00:09:41,465
Diperlukan banyak
usaha untuk berpindah.

243
00:09:41,465 --> 00:09:43,019
Dan tidak ada orang lain
yang menggunakan IPv6, jadi

244
00:09:43,019 --> 00:09:45,060
kenapa saya harus mulai menggunakan
protokol aneh ini

245
00:09:45,060 --> 00:09:47,220
yang tidak akan digunakan orang lain
untuk berbicara dengan saya?

246
00:09:47,220 --> 00:09:48,520
Jadi hal ini terus berlaku.

247
00:09:48,520 --> 00:09:49,895
Tetapi saya pikir akan
membutuhkan banyak waktu.

248
00:09:49,895 --> 00:09:53,290
Dan dibutuhkan motivasi
yang kuat untuk berpindah.

249
00:09:53,290 --> 00:09:56,940
Kompatibilitas ke belakang
juga sangat membantu.

250
00:09:56,940 --> 00:09:58,700
Tidak cukup baik untuk,
saya rasa, IPv6-- IPv6

251
00:09:58,700 --> 00:10:01,205
memiliki banyak rencana kompatibilitas
ke belakang di dalamnya.

252
00:10:01,205 --> 00:10:04,720
Anda bisa berkomunikasi dengan
host IPv4 dari IPv6.

253
00:10:04,720 --> 00:10:07,770
Jadi mereka mencoba membuat
seluruh dukungan ini.

254
00:10:07,770 --> 00:10:11,840
Namun tetap saja, sangatlah sulit untuk
meyakinkan orang untuk memperbarui.

255
00:10:11,840 --> 00:10:15,194
Baiklah, namun yah, melihat kembali
ke nomor urut TCP

256
00:10:15,194 --> 00:10:17,610
kita akan melihat
sebenarnya dua masalah yang

257
00:10:17,610 --> 00:10:20,990
memiliki hubungan dengan cara
TCP handshake berkerja.

258
00:10:20,990 --> 00:10:24,260
Jadi mari kita habiskan sedikit
waktu memikirkan

259
00:10:24,260 --> 00:10:27,060
detail-detail bagaimana
koneksi TCP pada awalnya

260
00:10:27,060 --> 00:10:28,510
dibangun.

261
00:10:28,510 --> 00:10:30,650
Jadi sebenarnya ada
tiga paket

262
00:10:30,650 --> 00:10:33,900
yang harus dikirim agar
koneksi TCP baru

263
00:10:33,900 --> 00:10:34,690
bisa terbangun.

264
00:10:34,690 --> 00:10:37,960
Jadi klien kita membangkitkan
sebuah paket untuk terkoneksi ke sebuah server.

265
00:10:37,960 --> 00:10:41,140
Dan itu mengatakan, yah, ini adalah
alamat IP saya, C, client.

266
00:10:41,140 --> 00:10:42,940
Saya mengirimkan ini ke server.

267
00:10:42,940 --> 00:10:44,534
Dan ada berbagai kolom nilai.

268
00:10:44,534 --> 00:10:46,575
Tetapi yang menarik
untuk tujuan

269
00:10:46,575 --> 00:10:49,590
diskusi ini adalah
nomor urut.

270
00:10:49,590 --> 00:10:51,610
Jadi akan ada flag
syn yang mengatakan,

271
00:10:51,610 --> 00:10:54,350
saya ingin mensinkronisiasi keadaan
dan membangun koneksi baru.

272
00:10:54,350 --> 00:10:57,480
Dan Anda mencantumkan sebuah
nomor sekuens klien

273
00:10:57,480 --> 00:11:00,680
pada paket syn aslinya.

274
00:11:00,680 --> 00:11:02,370
Lalu saat server
menerimanya,

275
00:11:02,370 --> 00:11:04,167
server tersebut akan
melihat dan berkata,

276
00:11:04,167 --> 00:11:05,750
Yah, sebuah client ingin
terhubung dengan saya,

277
00:11:05,750 --> 00:11:07,459
Jadi saya akan mengirim sebuah paket
kembali ke apapun

278
00:11:07,459 --> 00:11:09,000
alamat ini,
siapapun yang mengaku bahwa dia

279
00:11:09,000 --> 00:11:10,060
mencoba untuk terhubung dengan saya.

280
00:11:10,060 --> 00:11:13,740
Jadi dia akan mengirim paket dari
server ke client

281
00:11:13,740 --> 00:11:17,170
dan menyertakan nomor sinkronisasi, SN
miliknya sendiri

282
00:11:17,170 --> 00:11:18,080
server.

283
00:11:18,080 --> 00:11:19,910
Dan dia akan mengakui
nomor client.

284
00:11:23,750 --> 00:11:28,040
Dan akhirnya,
client membalasnya,

285
00:11:28,040 --> 00:11:30,260
mengakui nomor
sinkronisasi server

286
00:11:30,260 --> 00:11:37,070
-- mengakui SNS.

287
00:11:37,070 --> 00:11:40,110
dan sekarang client dapat
mulai mengirimkan data.

288
00:11:40,110 --> 00:11:42,290
Jadi untuk mengirim
data, client

289
00:11:42,290 --> 00:11:46,770
harus memasukan beberapa
data di dalam paket,

290
00:11:46,770 --> 00:11:51,780
dan juga memasukan nomor
sekuens client

291
00:11:51,780 --> 00:11:53,275
untuk mengindikasikan bahwa
bahwa sebenarnya ini adalah

292
00:11:53,275 --> 00:11:55,858
semacam data client yang sah
saat pertama kali terhubung.

293
00:11:55,858 --> 00:11:57,650
Data tersebut bukan data
dari yang belakangan dikirimkan,

294
00:11:57,650 --> 00:12:00,168
sebagai contoh, yang
baru saja sampai

295
00:12:00,168 --> 00:12:02,542
karena server kehilangan
bagian awal dari data.

296
00:12:02,542 --> 00:12:04,735
Jadi umumnya, semua
nomor urut ini

297
00:12:04,735 --> 00:12:08,240
dimaksudkan untuk memastikan
pengiriman paket sudah teratur.

298
00:12:08,240 --> 00:12:11,225
Jadi jika klien mengirim
dua paket, paket yang

299
00:12:11,225 --> 00:12:14,370
memiliki nomor urut pertama,
itu adalah potongan data pertama.

300
00:12:14,370 --> 00:12:16,078
Dan yang memiliki 
nomor urut berikutnya

301
00:12:16,078 --> 00:12:17,410
adalah bagian data berikutnya.

302
00:12:17,410 --> 00:12:20,790
Namun ternyata 
berguna juga untuk menyediakan

303
00:12:20,790 --> 00:12:22,424
beberapa properti keamanan.

304
00:12:22,424 --> 00:12:24,465
Berikut contoh bahwa
kebutuhan-kebutuhan ini berubah

305
00:12:24,465 --> 00:12:25,840
Jadi pada awalnya, tidak
ada yang mengira

306
00:12:25,840 --> 00:12:27,465
TCP menyediakan 
properti keamanan apa pun.

307
00:12:27,465 --> 00:12:29,940
Tapi kemudian aplikasi
mulai menggunakan TCP dan semacam

308
00:12:29,940 --> 00:12:32,470
mengandalkan fakta bahwa
koneksi TCP ini

309
00:12:32,470 --> 00:12:35,800
tidak dapat dipatahkan
oleh penyerang acak,

310
00:12:35,800 --> 00:12:39,150
atau penyerang tidak dapat
menyisipkan data ke dalam

311
00:12:39,150 --> 00:12:40,360
koneksi TCP yang sudah Anda miliki.

312
00:12:40,360 --> 00:12:43,060
Dan tiba-tiba, mekanisme ini
yang pada awalnya hanya

313
00:12:43,060 --> 00:12:46,240
dimaksudkan untuk
pengurutan paket, tetapi sekarang

314
00:12:46,240 --> 00:12:49,160
digunakan untuk menjamin
keamanan

315
00:12:49,160 --> 00:12:52,110
untuk koneksi ini.

316
00:12:52,110 --> 00:12:59,810
Jadi dalam kasus ini, saya
kira masalahnya

317
00:12:59,810 --> 00:13:03,710
berasal dari apa yang
dapat diasumsikan server tentang

318
00:13:03,710 --> 00:13:04,520
koneksi TCP ini.

319
00:13:04,520 --> 00:13:08,180
Jadi biasanya, server 
mengasumsikan-- secara implisit,

320
00:13:08,180 --> 00:13:12,480
Anda mungkin membayangkan-- 
bahwa koneksi ini dibuat

321
00:13:12,480 --> 00:13:17,195
dengan klien yang tepat di
alamat IP C. Tampaknya

322
00:13:17,195 --> 00:13:18,650
seperti hal yang wajar untuk diasumsikan.

323
00:13:18,650 --> 00:13:20,990
Apakah ada dasar untuk membuat 
asumsi ini?

324
00:13:20,990 --> 00:13:24,780
Jika sebuah server mendapatkan pesan 
ini, inilah

325
00:13:24,780 --> 00:13:27,500
beberapa data pada koneksi ini 
dari client ke server,

326
00:13:27,500 --> 00:13:32,950
dan dia memiliki nomor urut C, 
mengapa server mungkin saja

327
00:13:32,950 --> 00:13:35,759
menyimpulkan bahwa ini sebenarnya
klien yang benar yang mengirimkan ini?

328
00:13:35,759 --> 00:13:38,050
AUDIENS: Karena nomor urut 
sulit ditebak.

329
00:13:38,050 --> 00:13:39,940
PROFESOR: Benar, itulah hal implisit 
yang sedang terjadi,

330
00:13:39,940 --> 00:13:42,640
bahwa dia harus memiliki nomor 
urut C yang benar di sini.

331
00:13:42,640 --> 00:13:46,430
Dan agar koneksi 
ini terbangun,

332
00:13:46,430 --> 00:13:49,870
klien harus mengakui
server

333
00:13:49,870 --> 00:13:51,570
nomor urut S di sini.

334
00:13:51,570 --> 00:13:55,520
Dan nomor urut server S hanya 
dikirim oleh server

335
00:13:55,520 --> 00:13:59,386
ke alamat IP klien 
yang dituju.

336
00:13:59,386 --> 00:13:59,886
Ya.

337
00:13:59,886 --> 00:14:01,362
AUDIENS: Berapa banyak bit yang 
tersedia untuk urutan 

338
00:14:01,362 --> 00:14:01,862
angka?

339
00:14:01,862 --> 00:14:05,831
PROFESSOR: Jadi nomor urut 
dalam TCP adalah 32 bit panjangnya.

340
00:14:05,831 --> 00:14:10,359
Itu tidak sepenuhnya 
mudah ditebak.

341
00:14:10,359 --> 00:14:12,025
Jika itu benar-benar
angka 32 bit acak,

342
00:14:12,025 --> 00:14:14,040
akan sulit untuk ditebak.

343
00:14:14,040 --> 00:14:16,699
Dan kemungkinan Anda akan
menghabiskan banyak bandwidth

344
00:14:16,699 --> 00:14:17,637
untuk mencoba menebaknya.

345
00:14:17,637 --> 00:14:19,044
Yah, pertanyaan.

346
00:14:19,044 --> 00:14:20,607
AUDIENS: Data
bilangan frekuensi

347
00:14:20,607 --> 00:14:23,150
lebih tinggi dibandingkan
Nomor uruta awalnya?

348
00:14:23,150 --> 00:14:25,650
PROFESOR: Yah, pada dasarnya,
hal-hal ini bertambah.

349
00:14:25,650 --> 00:14:27,500
Jadi setiap kali anda
mengirim sebuah syn,

350
00:14:27,500 --> 00:14:29,660
maka akan dihitung sebagai satu byte
pada nomor urut Anda.

351
00:14:29,660 --> 00:14:31,010
Jadi inilah SNC.

352
00:14:31,010 --> 00:14:34,670
Saya pikir yang sebenarnya terjadi
adalah bahwa ini merupakan SNC plus 1.

353
00:14:34,670 --> 00:14:36,140
Dan terus berlaku dari sana.

354
00:14:36,140 --> 00:14:40,117
Jadi jika Anda mengirim 5 byte,
maka yang berikutnya adalah SNC plus 6.

355
00:14:40,117 --> 00:14:42,200
Jadi ini hanya menghitung jumlah
byte yang anda kirim.

356
00:14:42,200 --> 00:14:44,920
setiap SYN terhitung sebagai 1 byte.

357
00:14:44,920 --> 00:14:45,720
Masuk akal?

358
00:14:45,720 --> 00:14:48,050
Pertanyaan lain tentang ini?

359
00:14:48,050 --> 00:14:54,650
Baiklah, jadi pada umumnya,
atau setidaknya cara

360
00:14:54,650 --> 00:14:56,370
spesifikasi TCP
merekomendasikan

361
00:14:56,370 --> 00:14:58,550
bagaimana memilih
number urut ini,

362
00:14:58,550 --> 00:15:02,750
adalah dengan meningkatkannya
dengan kecepatan yang kurang lebih tetap.

363
00:15:02,750 --> 00:15:06,300
Jadi RFC (Request For Comments) mulanya menganjurkan
untuk meningkatkannya

364
00:15:06,300 --> 00:15:12,350
pada sekitar 250,000
unit, ditambah 250,000, per detik.

365
00:15:12,350 --> 00:15:14,920
dan alasan mengapa sebelumnya tidak
sepenuhnya acak

366
00:15:14,920 --> 00:15:17,060
karena nomor
urut ini sebenarnya

367
00:15:17,060 --> 00:15:20,690
digunakan untuk mencegah salahnya
penempatan paket, atau paket

368
00:15:20,690 --> 00:15:22,534
dari koneksi sebelumnya,
dari mengganggu

369
00:15:22,534 --> 00:15:23,917
koneksi baru.

370
00:15:23,917 --> 00:15:26,870
jadi jika setiap saat Anda
membangun sebuah koneksi baru

371
00:15:26,870 --> 00:15:29,740
Anda memilih nomor urut
yang benar-benar acak,

372
00:15:29,740 --> 00:15:32,590
setelah itu ada kemungkinan jika Anda
membangun banyak koneksi

373
00:15:32,590 --> 00:15:35,510
berulang-ulang hingga beberapa paket
dari koneksi sebelumnya

374
00:15:35,510 --> 00:15:37,290
akan mendapatkan
nomor urut yang cukup mirip

375
00:15:37,290 --> 00:15:38,790
dengan koneksi baru
Anda dan akan

376
00:15:38,790 --> 00:15:41,490
dapat diterima sebagai
potongan data yang valid

377
00:15:41,490 --> 00:15:42,602
pada koneksi baru tersebut.

378
00:15:42,602 --> 00:15:45,000
Jadi ini adalah sesuatu yang
sangat dikhawatirkan oleh para perancang TCP 

379
00:15:45,000 --> 00:15:48,916
-- yakni paket-paket tidak berurutan
atau yang tertunda.

380
00:15:48,916 --> 00:15:51,290
Jadi sebagai hasilnya, mereka benar-benar
menginginkan nomor urut ini

381
00:15:51,290 --> 00:15:55,210
untuk berkembang secara 
monoton dari waktu ke waktu secara kasar,

382
00:15:55,210 --> 00:15:56,900
bahkan secara lintas koneksi.

383
00:15:56,900 --> 00:15:58,580
Jika saya buka satu
koneksi, hal itu mungkin

384
00:15:58,580 --> 00:16:01,060
memilki sumber dan
tujuan, nomor port,

385
00:16:01,060 --> 00:16:02,610
alamat IP, dan sebagainya, yang sama.

386
00:16:02,610 --> 00:16:04,920
tetapi karena saya membangun
koneksi ini sekarang bukannya

387
00:16:04,920 --> 00:16:07,640
lebih awal, paket-paket
dari sebelumnya diharapkan

388
00:16:07,640 --> 00:16:10,030
tidak akan cocok
dengan nomor urut

389
00:16:10,030 --> 00:16:12,310
yang saya miliki untuk koneksi baru saya.

390
00:16:12,310 --> 00:16:14,280
Jadi ini merupakan mekanisme
untuk mencegah kebingungan

391
00:16:14,280 --> 00:16:18,431
lintas koneksi
yang berulang.

392
00:16:18,431 --> 00:16:18,930
Yah.

393
00:16:18,930 --> 00:16:22,983
AUDIENS: jadi jika Anda tidak tahu
secara tepat seberapa banyak grid lain

394
00:16:22,983 --> 00:16:25,566
yang di mana Anda bekomunikasi dengannya
akan meningkatkan paket urutan,

395
00:16:25,566 --> 00:16:26,845
bagaimana Anda tahu
paket yang anda terima adalah

396
00:16:26,845 --> 00:16:29,120
paket berikutnya jika tidak ada
[TIDAK TERDENGAR] paket berikutnya

397
00:16:29,120 --> 00:16:29,530
yang Anda--

398
00:16:29,530 --> 00:16:31,870
PROFESOR: Biasanya Anda akan
ingat paket terakhir

399
00:16:31,870 --> 00:16:33,260
yang anda terima.

400
00:16:33,260 --> 00:16:35,680
Dan jika nomor urut selanjutnya
persis seperti itu,

401
00:16:35,680 --> 00:16:38,267
maka ini merupakan
paket selanjutnya pada urutannya.

402
00:16:38,267 --> 00:16:39,850
Jadi sebagai contoh, di sini,
server mengetahui

403
00:16:39,850 --> 00:16:43,937
bahwa saya dengan tepat melihat
data sebesar SNC ditambah 1.

404
00:16:43,937 --> 00:16:46,020
Jika paket selanjutnya memiliki
nomor urut SNC ditambah 1,

405
00:16:46,020 --> 00:16:47,618
itu adalah yang selanjutnya.

406
00:16:47,618 --> 00:16:49,117
AUDIENS: Jadi makud
Anda bahwa ketika

407
00:16:49,117 --> 00:16:51,790
Anda membangun sebuah nomor urut,
kemudian bahkan setelah itu Anda

408
00:16:51,790 --> 00:16:52,762
berkomitmen terhadapnya--

409
00:16:52,762 --> 00:16:54,428
PROFESOR: Baik,
pastinya, yah, yah.

410
00:16:54,428 --> 00:16:56,611
Jadi nomor urut
ini, awalnya ketika

411
00:16:56,611 --> 00:16:58,986
Anda membangunnya, itu semua
terpilih menurut suatu rencana.

412
00:16:58,986 --> 00:17:00,135
Kita akan bicarakan tentang rencana itu.

413
00:17:00,135 --> 00:17:01,940
Anda dapat berpikir bahwa
mereka mungkin merupakan acak.

414
00:17:01,940 --> 00:17:05,310
Tetapi seiring waktu, mereka harus memiliki
semacam aliran untuk nomor urut

415
00:17:05,310 --> 00:17:07,034
awal untuk koneksi.

416
00:17:07,034 --> 00:17:09,575
Tapi hanya dalam sebuah koneksi, sekalinya
mereka ditetapkan, ya sudah.

417
00:17:09,575 --> 00:17:10,280
Itu semua tidak berubah.

418
00:17:10,280 --> 00:17:11,890
Dan semua itu berdetak
seiring jalannya data

419
00:17:11,890 --> 00:17:15,630
terkirim di dalam
koneksi, tepatnya.

420
00:17:15,630 --> 00:17:17,270
Masuk akal?

421
00:17:17,270 --> 00:17:19,619
Baiklah, jadi ada
beberapa rencana

422
00:17:19,619 --> 00:17:22,020
yang disarankan untuk bagaimana mengelola
nomor urut ini.

423
00:17:22,020 --> 00:17:23,650
Dan itu sebenarnya
merupakan rencana yang masuk akal

424
00:17:23,650 --> 00:17:27,970
untuk menghindari paket duplikat
di dalam jaringan menyebabkan masalah.

425
00:17:27,970 --> 00:17:31,730
Tetapi masalahnya, tentu
saja, muncul

426
00:17:31,730 --> 00:17:37,511
di mana penyerang memiliki kemampuan
untuk menebak urutan

427
00:17:37,511 --> 00:17:38,010
nomor tersebut.

428
00:17:38,010 --> 00:17:42,090
Dikarenakan kurang banyaknya
pilihan acak yang dipilih.

429
00:17:42,090 --> 00:17:44,750
Jadi caranya mesin host
memilih nomor urut ini

430
00:17:44,750 --> 00:17:47,290
adalah mereka hanya memiliki
counter yang berjalan dalam memori.

431
00:17:47,290 --> 00:17:50,080
Setiap detik mereka
menambahnya dengan 250.000.

432
00:17:50,080 --> 00:17:51,790
Dan setiap ada
koneksi yang baru

433
00:17:51,790 --> 00:17:55,530
masuk, mereka juga menambahnya
dengan nilai konstan seperti 64k atau 128k.

434
00:17:55,530 --> 00:17:57,930
Saya tidak ingat angka tepatnya.

435
00:17:57,930 --> 00:18:00,180
Jadi secara relatif ini mudah
untuk ditebak, seperti yang Anda lihat.

436
00:18:00,180 --> 00:18:02,030
Anda mengirim mereka
permintaan koneksi mereka,

437
00:18:02,030 --> 00:18:04,116
dan Anda lihat nomor
urut apa yang kembali.

438
00:18:04,116 --> 00:18:05,741
lalu Anda tahu
selanjutnya akan

439
00:18:05,741 --> 00:18:07,950
menjadi 64k lebih tinggi dari itu.

440
00:18:07,950 --> 00:18:12,352
Jadi tidak banyak
keacakan di dalam protokol ini.

441
00:18:12,352 --> 00:18:14,310
Jadi kita bisa membuat sketsa
seperti apa bentuknya ini.

442
00:18:14,310 --> 00:18:17,190
Jadi jika saya adalah penyerang yang 
ingin terhubung ke server

443
00:18:17,190 --> 00:18:20,690
tetapi berpura-pura berasal dari
alamat IP tertentu,

444
00:18:20,690 --> 00:18:23,920
maka yang mungkin akan saya lakukan adalah mengirim
permintaan ke server,

445
00:18:23,920 --> 00:18:26,490
sangat mirip seperti
langkah pertama,

446
00:18:26,490 --> 00:18:30,470
termasuk beberapa
nomor urut awal yang saya pilih.

447
00:18:30,470 --> 00:18:31,995
Pada titik ini,
nomor urut berapapun

448
00:18:31,995 --> 00:18:33,660
sama bagusnya, karena
server seharusnya tidak

449
00:18:33,660 --> 00:18:35,970
tidak memiliki asumsi apapun
tentang nomor urut

450
00:18:35,970 --> 00:18:37,042
klien.

451
00:18:37,042 --> 00:18:38,250
Sekarang, apa yang akan dilakukan oleh server?

452
00:18:38,250 --> 00:18:40,760
Server akan mendapatkan
paket yang sama seperti sebelumnya.

453
00:18:40,760 --> 00:18:42,550
Jadi dia akan melakukan hal yang
sama seperti sebelumnya.

454
00:18:42,550 --> 00:18:47,500
Dia mengirimkan paket kembali ke
klien dengan nomor urut server

455
00:18:47,500 --> 00:18:53,000
tertentu dan
mengonfirmasi SNC.

456
00:18:53,000 --> 00:18:55,800
Dan sekarang penyerang,
jika penyerang

457
00:18:55,800 --> 00:18:58,620
ingin membuat sebuah koneksi,
ia butuh menyusun

458
00:18:58,620 --> 00:19:01,540
sebuah paket yang terlihat persis seperti
paket ketiga di sana.

459
00:19:01,540 --> 00:19:04,779
Jadi dia harus mengirim sebuah paket
dari klien ke server.

460
00:19:04,779 --> 00:19:05,570
Hal ini cukup mudah.

461
00:19:05,570 --> 00:19:07,403
Anda hanya perlu mengisi
nilai-nilainya di header.

462
00:19:07,403 --> 00:19:12,820
Tetapi Anda harus mengonfirmasi
nomor urut SNS server ini.

463
00:19:12,820 --> 00:19:15,090
Dan disinilah
permasalahan dimulai.

464
00:19:15,090 --> 00:19:18,950
Jika nilai SNS 
cukup mudah untuk ditebak,

465
00:19:18,950 --> 00:19:21,050
maka penyerang sudah siap untuk menyerang.

466
00:19:21,050 --> 00:19:22,910
Dan sekarang server
berpikir mereka memiliki

467
00:19:22,910 --> 00:19:26,400
koneksi yang sudah terhubung sebelumnya
dengan klien dari alamat

468
00:19:26,400 --> 00:19:27,990
IP ini.

469
00:19:27,990 --> 00:19:31,920
dan sekarang penyerang dapat
menyuntikkan data ke koneksi ini

470
00:19:31,920 --> 00:19:33,174
seperti sebelumnya.

471
00:19:33,174 --> 00:19:34,590
Mereka hanya membentuk
paket yang

472
00:19:34,590 --> 00:19:37,680
terlihat seperti ini,
berisi data, dan

473
00:19:37,680 --> 00:19:41,030
mempunyai nomor urut klien
yang sebenarnya dipilih

474
00:19:41,030 --> 00:19:41,540
musuh.

475
00:19:41,540 --> 00:19:43,870
Mungkin tambah 1 di sini.

476
00:19:43,870 --> 00:19:48,170
Tetapi itu semua bergantung pada
kemampuan untuk menebak nomor urut

477
00:19:48,170 --> 00:19:51,400
yang diberikan server ini.

478
00:19:51,400 --> 00:19:52,820
Baiklah, apakah ini masuk akal?

479
00:19:52,820 --> 00:19:53,320
Ya.

480
00:19:53,320 --> 00:19:54,280
AUDIENS: Apa alasannya
bahwa nomor urut server

481
00:19:54,280 --> 00:19:56,374
tidak sepenuhnya acak?

482
00:19:56,374 --> 00:19:57,790
PROFESOR: Jadi
ada dua alasan.

483
00:19:57,790 --> 00:20:00,940
Satu, seperti yang saya 
jelaskan sebelumnya,

484
00:20:00,940 --> 00:20:05,330
server ingin memastikan 
paket-paket

485
00:20:05,330 --> 00:20:07,720
dari koneksi yang 
berbeda seiring berjalannya waktu

486
00:20:07,720 --> 00:20:09,315
tidak bertabrakan satu 
sama lain.

487
00:20:09,315 --> 00:20:12,280
Jadi jika Anda membuat 
koneksi dari satu port sumber

488
00:20:12,280 --> 00:20:14,864
ke port tujuan lain, dan 
kemudian Anda menutup koneksi

489
00:20:14,864 --> 00:20:17,363
dan membuat satu lagi
sumber dan tujuan

490
00:20:17,363 --> 00:20:20,000
port yang sama, anda ingin memastikan
paket dari koneksi dari satu koneksi

491
00:20:20,000 --> 00:20:24,121
tidak tampak valid
dalam koneksi lain.

492
00:20:24,121 --> 00:20:26,109
AUDIENS: Jadi
nomor urut server

493
00:20:26,109 --> 00:20:28,525
bertambah satu untuk setiap
paket mereka?

494
00:20:28,525 --> 00:20:33,397
PROFESSOR: Yah, begitu nomor
urut dalam koneksi,

495
00:20:33,397 --> 00:20:35,550
seperti yang saya jelaskan, dapat
bertabrakan dengan data lain

496
00:20:35,550 --> 00:20:36,217
dalam sebuah koneksi.

497
00:20:36,217 --> 00:20:37,591
Tapi ada juga 
pertanyaan tentang,

498
00:20:37,591 --> 00:20:39,820
bagaimana Anda memilih 
nomor urut awal di sini?

499
00:20:39,820 --> 00:20:42,530
Dan nilainya akan dinaikkan
setiap kali ada koneksi baru

500
00:20:42,530 --> 00:20:43,440
terbentuk.

501
00:20:43,440 --> 00:20:47,190
Jadi harapannya adalah saat
nilainya melewati sekitar 2 pangkat 32

502
00:20:47,190 --> 00:20:50,600
dan kembali lagi dari nol,
sudah cukup waktu

503
00:20:50,600 --> 00:20:52,270
sehingga paket-paket 
lama di jaringan

504
00:20:52,270 --> 00:20:54,283
benar-benar sudah hilang
dan tidak akan

505
00:20:54,283 --> 00:20:56,006
muncul sebagai duplikat.

506
00:20:56,006 --> 00:20:57,630
Jadi itulah alasannya mengapa
Anda tidak sekedar

507
00:20:57,630 --> 00:20:59,920
memilih poin acak,
atau sejak awal mereka

508
00:20:59,920 --> 00:21:01,374
tidak memilih poin acak.

509
00:21:01,374 --> 00:21:01,874
Ya.

510
00:21:01,874 --> 00:21:04,309
AUDIENS: Jadi ini adalah masalah
antar koneksi,

511
00:21:04,309 --> 00:21:06,910
untuk koneksi antar guide? yang sama,
klien yang sama,

512
00:21:06,910 --> 00:21:09,410
server yang sama, port sumber 
yang sama, tujuan yang sama.

513
00:21:09,410 --> 00:21:11,012
Dan kita khawatir
tentang paket yang lama--

514
00:21:11,012 --> 00:21:13,565
PROFESSOR: Jadi ini yang asli,
yah, yang dikhawatirkan

515
00:21:13,565 --> 00:21:14,810
desainer TCP,
itulah sebabnya mereka

516
00:21:14,810 --> 00:21:16,696
menganjurkan cara ini untuk memilih
nomor urut awal ini.

517
00:21:16,696 --> 00:21:18,094
AUDIENS: Jika Anda memiliki
beberapa koneksi baru berbeda,

518
00:21:18,094 --> 00:21:19,135
Anda dapat membedakannya.

519
00:21:19,135 --> 00:21:19,900
PROFESOR: Ya, itu benar.

520
00:21:19,900 --> 00:21:22,375
AUDIENS: Jadi saya tidak mengerti
mengapa menaikkan angkanya

521
00:21:22,375 --> 00:21:24,355
dan tidak mengambilnya secara acak saja.

522
00:21:24,355 --> 00:21:26,850
PROFESOR: Saya pikir 
alasan mereka tidak memilih secara acak

523
00:21:26,850 --> 00:21:29,100
adalah jika anda memilih
secara acak, dan membuat,

524
00:21:29,100 --> 00:21:31,320
Misalnya, 1,000 koneksi
dalam waktu singkat

525
00:21:31,320 --> 00:21:34,040
dari sumber yang sama
ke tujuan yang sama,

526
00:21:34,040 --> 00:21:37,780
maka, semuanya
merupakan angka acak dari module 2

527
00:21:37,780 --> 00:21:38,990
hingga 32.

528
00:21:38,990 --> 00:21:40,920
Dan sekarang ada
kemungkinan nontrivial

529
00:21:40,920 --> 00:21:42,420
bahwa beberapa paket
dari satu koneksi

530
00:21:42,420 --> 00:21:45,600
akan tertunda di dalam jaringan
dan akhirnya, muncul lagi,

531
00:21:45,600 --> 00:21:48,760
dan akan membingungkan dari
paket ke koneksi lainnya.

532
00:21:48,760 --> 00:21:50,840
Ini tidak ada
hubungannya dengan keamanan.

533
00:21:50,840 --> 00:21:52,465
Ini hanyalah pertimbangan
desain mereka

534
00:21:52,465 --> 00:21:55,290
yang pada awalnya sebagai pengiriman yang handal.

535
00:21:55,290 --> 00:21:58,720
AUDIENS: [TIDAK TERDENGAR] beberapa lainnya
klien ke server, bukan?

536
00:21:58,720 --> 00:21:59,595
PROFESOR: Maaf?

537
00:21:59,595 --> 00:22:01,830
AUDIENCE: Ini [TIDAK TERDENGAR]
klien lain?

538
00:22:01,830 --> 00:22:03,080
PROFESOR: Ya itu benar.

539
00:22:03,080 --> 00:22:04,830
Jadi kami belum benar-benar mengatakan
mengapa ini menarik sekali

540
00:22:04,830 --> 00:22:06,190
untuk dilakukan penyerang.

541
00:22:06,190 --> 00:22:06,880
Kenapa mengganggu?

542
00:22:06,880 --> 00:22:09,055
Anda bisa pergi dari
alamat IP lamanya, bukan?

543
00:22:09,055 --> 00:22:12,855
AUDIENS: Jadi apa yang terjadi
kepada server [TIDAK TERDENGAR]?

544
00:22:17,346 --> 00:22:19,720
PROFESOR: Ya, ini sebenarnya
pertanyaan yang menarik.

545
00:22:19,720 --> 00:22:20,440
Apa yang terjadi di sini?

546
00:22:20,440 --> 00:22:22,106
Jadi paket ini tidak
langsung dibuang.

547
00:22:22,106 --> 00:22:24,430
Itu sebenarnya masuk
kedalam komputer ini.

548
00:22:24,430 --> 00:22:26,426
Dan apa yang terjadi?

549
00:22:26,426 --> 00:22:28,926
AUDIENS: [TIDAK TERDENGAR], mereka
hanya menyebutkan Anda untuk mencoba dan melakukannya

550
00:22:28,926 --> 00:22:31,116
seperti mereka
akan mencoba dan melakukannya ketika

551
00:22:31,116 --> 00:22:34,019
komputer lain sedang 
memperbarui atau me-reboot atau mematikan,

552
00:22:34,019 --> 00:22:34,560
atau semacam itu.

553
00:22:34,560 --> 00:22:35,682
PROFESOR: Benar,
pasti mereka merasa, oh,

554
00:22:35,682 --> 00:22:36,192
bahwa komputer itu sedang offline.

555
00:22:36,192 --> 00:22:37,670
Paket akan
dibuang,

556
00:22:37,670 --> 00:22:39,720
dan Anda tidak perlu
terlalu mengkhawatirkannya.

557
00:22:39,720 --> 00:22:43,010
Jika komputer benar-benar
mendengarkan alamat IP itu,

558
00:22:43,010 --> 00:22:45,065
maka dalam protokol TCP,
Anda seharusnya

559
00:22:45,065 --> 00:22:47,790
mengirim paket reset
untuk mengatur ulang koneksi.

560
00:22:47,790 --> 00:22:51,630
Karena ini bukan koneksi
yang diketahui oleh komputer C.

561
00:22:51,630 --> 00:22:54,730
Dan di TCP, ini dianggap
karena, oh, ini

562
00:22:54,730 --> 00:22:57,640
adalah beberapa paket lama yang
saya minta sejak lama,

563
00:22:57,640 --> 00:22:59,320
tetapi saya
sudah melupakannya.

564
00:22:59,320 --> 00:23:04,850
Jadi mesin C di sini mungkin mengirim
paket ke server yang mengatakan,

565
00:23:04,850 --> 00:23:07,710
Saya ingin reset.

566
00:23:07,710 --> 00:23:10,503
Saya benar-benar lupa tepatnya
nomor urut mana yang ada di sana.

567
00:23:10,503 --> 00:23:13,582
Tetapi klien C di sini mengetahui
semua nomor urut

568
00:23:13,582 --> 00:23:15,290
dan mengirim nomor urut
yang diperlukan

569
00:23:15,290 --> 00:23:17,580
dan mengatur ulang koneksi ini.

570
00:23:17,580 --> 00:23:20,229
Jadi, jika komputer C
akan melakukan ini,

571
00:23:20,229 --> 00:23:21,812
maka itu mungkin akan
mengganggu rencana Anda

572
00:23:21,812 --> 00:23:22,948
untuk membuat koneksi.

573
00:23:22,948 --> 00:23:24,406
Karena ketika S mendapatkan
paket ini,

574
00:23:24,406 --> 00:23:25,993
mengatakan, oh, tentu, jika
Anda tidak menginginkannya,

575
00:23:25,993 --> 00:23:27,840
saya akan setel ulang koneksi Anda.

576
00:23:27,840 --> 00:23:30,610
Ada beberapa
bug implementasi

577
00:23:30,610 --> 00:23:34,075
yang mungkin Anda manfaatkan, atau 
setidaknya penulis bicarakan,

578
00:23:34,075 --> 00:23:38,215
dan potensi eksploitasi,
yang akan mencegah

579
00:23:38,215 --> 00:23:39,990
klien C untuk menanggapi.

580
00:23:39,990 --> 00:23:42,758
Jadi misalnya, jika Anda 
membanjiri C dengan banyak paket,

581
00:23:42,758 --> 00:23:44,633
itu cara mudah untuk membuatnya 
menjatuhkan yang ini.

582
00:23:44,633 --> 00:23:46,924
Ternyata ada bug lain yang 
lebih menarik yang

583
00:23:46,924 --> 00:23:49,520
tidak perlu membanjiri C dengan
banyak paket yang masih didapat

584
00:23:49,520 --> 00:23:51,200
C untuk menjatuhkan paket ini,
atau setidaknya

585
00:23:51,200 --> 00:23:53,436
demikian pada beberapa implementasi
pada tumpukan TCP di masa lalu.

586
00:23:53,436 --> 00:23:53,936
Ya.

587
00:23:53,936 --> 00:23:55,436
AUDIENS: Agaknya,
sebagian besar firewall

588
00:23:55,436 --> 00:23:57,888
juga akan [TIDAK TERDENGAR].

589
00:23:57,888 --> 00:23:59,370
PROFESOR: Yang ini?

590
00:23:59,370 --> 00:24:00,852
AUDIENS: Tidak, yang SYN.

591
00:24:00,852 --> 00:24:01,840
PROFESOR: Yang ini

592
00:24:01,840 --> 00:24:02,828
AUDIENS: Itu
datang ke klien,

593
00:24:02,828 --> 00:24:05,203
dan klien awalnya tidak mengirim
SYN ke server itu.

594
00:24:05,203 --> 00:24:07,188
Dan firewall akan
menjatuhkannya.

595
00:24:07,188 --> 00:24:08,980
PROFESOR: Ya, tergantung.

596
00:24:08,980 --> 00:24:12,590
Pastinya jika Anda memiliki sebuah
firewall canggih yang memiliki ingatan besar

597
00:24:12,590 --> 00:24:15,150
dan melacak seluruh
koneksi, atau misalnya

598
00:24:15,150 --> 00:24:17,110
jika Anda memiliki sebuah NAT,
maka ini mungkin terjadi.

599
00:24:17,110 --> 00:24:20,640
Di sisi lain, sebuah NAT
mungkin dapat mengirim RST

600
00:24:20,640 --> 00:24:22,810
atas nama kliennya.

601
00:24:22,810 --> 00:24:23,720
Jadi itu tidak jelas.

602
00:24:23,720 --> 00:24:26,450
Saya pikir hal ini tidak terlalu umum.

603
00:24:26,450 --> 00:24:29,730
Misalnya dalam sebuah
jaringan Comcast,

604
00:24:29,730 --> 00:24:32,500
Saya yakin tidak ada yang
mencegat paket-paket tersebut

605
00:24:32,500 --> 00:24:34,916
dan mempertahankan keadaan
dan mengirim RST atas nama saya

606
00:24:34,916 --> 00:24:35,750
atau hal lain yang serupa.

607
00:24:35,750 --> 00:24:36,250
Ya.

608
00:24:36,250 --> 00:24:38,250
AUDIENS: Jadi mengapa
server tidak dapat

609
00:24:38,250 --> 00:24:40,206
memiliki urutan
angka independen

610
00:24:40,206 --> 00:24:42,380
untuk setiap sumber yang mungkin?

611
00:24:42,380 --> 00:24:46,260
PROFESOR: Benar, jadi inilah
apa yang dilakukan protokol TCP sekarang.

612
00:24:46,260 --> 00:24:49,910
Inilah salah satu contoh cara untuk
memperbaiki masalah ini dengan cara

613
00:24:49,910 --> 00:24:50,660
kompatibilitas mundur.

614
00:24:50,660 --> 00:24:52,285
Jadi kita akan menuju
tepatnya perumusan

615
00:24:52,285 --> 00:24:53,330
bagaimana Anda mengaturnya.

616
00:24:53,330 --> 00:24:55,910
Tetapi kenyataannya jika 
Anda melihatnya secara seksama,

617
00:24:55,910 --> 00:24:59,630
seiring perjalanan, Anda tidak
memerlukan urutan awal angka

618
00:24:59,630 --> 00:25:00,950
ini secara global.

619
00:25:00,950 --> 00:25:04,626
Anda hanya perlu memperlihatkannya
ke pasangan sumber/tujuan.

620
00:25:04,626 --> 00:25:06,500
dan Anda mendapatkan
properti penghindaran

621
00:25:06,500 --> 00:25:11,560
duplikasi yang sudah ada sebelumnya,
dan Anda mendapatkan beberapa keamaanan.

622
00:25:11,560 --> 00:25:15,590
Jadi hanya untuk 
menuliskannya

623
00:25:15,590 --> 00:25:18,550
di papan bagaimana
penyerang mendapatkan

624
00:25:18,550 --> 00:25:21,425
nomor urut awal,
penyerang kemungkinan

625
00:25:21,425 --> 00:25:23,770
hanya mengirim koneksi
dari IP address nya

626
00:25:23,770 --> 00:25:27,400
ke server dan katakan,
aku ingin membuat koneksi baru

627
00:25:27,400 --> 00:25:30,506
dan server akan mengirim
kembali respon

628
00:25:30,506 --> 00:25:33,920
ke penyerang yang mengandung
nomor urut S sendiri.

629
00:25:33,920 --> 00:25:36,590
Dan jika SNS untuk
koneksi ini

630
00:25:36,590 --> 00:25:39,492
dan SNS untuk koneksi 
ini terhubung,

631
00:25:39,492 --> 00:25:40,450
maka ini adalah masalah.

632
00:25:40,450 --> 00:25:42,540
Tetapi Anda katakan,
kita buat mereka tidak terhubung.

633
00:25:42,540 --> 00:25:44,310
Karena ini dari 
alamat yang berbeda.

634
00:25:44,310 --> 00:25:45,960
Maka hal ini
bukan masalah lagi.

635
00:25:45,960 --> 00:25:47,630
Anda tidak dapat menebak
SNS ini akan

636
00:25:47,630 --> 00:25:52,298
berdasarkan SNS
untuk koneksi yang berbeda.

637
00:25:52,298 --> 00:25:52,798
Ya.

638
00:25:52,798 --> 00:25:54,797
AUDIENS: Jadi Anda masih
punya masalah collision,

639
00:25:54,797 --> 00:25:56,533
karena Anda dapat
mengambil 32 bits

640
00:25:56,533 --> 00:25:58,774
dengan alamat rekan-rekan Anda.

641
00:25:58,774 --> 00:26:01,264
Jadi, Anda memiliki banyak port
untuk masing-masingnya.

642
00:26:01,264 --> 00:26:04,252
Jadi, Anda masih memiliki
nomor urut yang bertentangan

643
00:26:04,252 --> 00:26:06,660
untuk semua koneksi
yang Anda dapatkan ini, bukan?

644
00:26:06,660 --> 00:26:08,160
PROFESOR: Jadi
nomor urut ini

645
00:26:08,160 --> 00:26:11,156
ternyata spesifik,
ke alamat IP

646
00:26:11,156 --> 00:26:14,530
dan pasangan nomor port
sumber/tujuan.

647
00:26:14,530 --> 00:26:16,360
Jadi jika portnya
berbeda, maka mereka

648
00:26:16,360 --> 00:26:17,372
tidak saling
mengganggu sama sekali.

649
00:26:17,372 --> 00:26:19,130
AUDIENS: Oh, karena 
Anda menggunakan port--

650
00:26:19,130 --> 00:26:20,205
PROFESSOR: Tepat sekali,
ya, Anda juga menggunakan

651
00:26:20,205 --> 00:26:21,504
port ini.

652
00:26:21,504 --> 00:26:22,746
AUDIENS: Karena saya
pikir port itu--

653
00:26:22,746 --> 00:26:25,246
PROFESSOR: Ya, jadi port-portnya
berada di bawah nomor

654
00:26:25,246 --> 00:26:27,987
urutannya jika
dipikir-pikir.

655
00:26:27,987 --> 00:26:28,486
Ada pertanyaan?

656
00:26:28,486 --> 00:26:31,060
AUDIENS: Jika nomor urutnya
global,

657
00:26:31,060 --> 00:26:33,910
maka bukankah
penyerang [TIDAK TERDENGAR]?

658
00:26:36,774 --> 00:26:37,940
PROFESSOR: Ya, poin yang bagus.

659
00:26:37,940 --> 00:26:40,780
Jadi faktanya, jika server
menambahkan nomor urut

660
00:26:40,780 --> 00:26:43,180
dengan, misalnya,
64k mungkin,

661
00:26:43,180 --> 00:26:46,885
saya rasa, untuk setiap koneksi,
maka, yah, Anda terhubung.

662
00:26:46,885 --> 00:26:49,090
Dan lalu mungkin lima
orang lain terhubung.

663
00:26:49,090 --> 00:26:51,120
Dan kemudian Anda harus
melakukan penyerangan ini.

664
00:26:51,120 --> 00:26:54,790
Jadi sampai batas tertentu, Anda benar,
ini sedikit bermasalah.

665
00:26:54,790 --> 00:26:56,420
Di sisi lain,
Anda mungkin bisa

666
00:26:56,420 --> 00:27:01,860
mengatur agar paket anda
di sini dikirim tepat

667
00:27:01,860 --> 00:27:02,740
sebelum paket ini.

668
00:27:02,740 --> 00:27:05,870
Jadi jika Anda mengirimkan
hal ini secara terus menerus,

669
00:27:05,870 --> 00:27:08,200
maka ada peluang bagus
mereka akan sampai pada server

670
00:27:08,200 --> 00:27:08,920
secara terus menerus.

671
00:27:08,920 --> 00:27:10,710
Server tersebut akan mendapatkan
yang satu ini, merespon

672
00:27:10,710 --> 00:27:12,180
dengan nomor urutan ini.

673
00:27:12,180 --> 00:27:13,580
Dia akan mendapatkan yang
berikutnya, yang ini,

674
00:27:13,580 --> 00:27:16,754
merespon dengan nomor
urut setelah itu.

675
00:27:16,754 --> 00:27:19,170
Dan setelah itu Anda tahu apa
yang harus dimasukkan di paket ketiga ini

676
00:27:19,170 --> 00:27:21,450
dalam urutan anda.

677
00:27:21,450 --> 00:27:24,620
Jadi saya rasa ini bukanlah
metode yang sempurna

678
00:27:24,620 --> 00:27:25,790
untuk terkoneksi ke sebuah server.

679
00:27:25,790 --> 00:27:27,260
Hal tersebut melibatkan tebak-tebakan.

680
00:27:27,260 --> 00:27:29,720
Tapi jika Anda dengan hati-hati
menyusun paket-paket Anda dengan benar,

681
00:27:29,720 --> 00:27:32,230
maka cukup mudah untuk
membuat tebakan yang tepat.

682
00:27:32,230 --> 00:27:34,720
Atau mungkin Anda mencoba beberapa
kali, dan mungkin Anda akan beruntung.

683
00:27:34,720 --> 00:27:35,480
Ya.

684
00:27:35,480 --> 00:27:38,246
AUDIENS: Jadi meskipun
itu benar-benar acak,

685
00:27:38,246 --> 00:27:39,912
dan Anda harus menebaknya,
hanya ada

686
00:27:39,912 --> 00:27:40,998
sekitar 4 miliar kemungkinan.

687
00:27:40,998 --> 00:27:42,248
Bukan jumlah yang besar, kan?

688
00:27:42,248 --> 00:27:44,372
Saya rasa
dalam kurun satu tahun,

689
00:27:44,372 --> 00:27:46,300
Anda seharusnya
mungkin dapat menembusnya.

690
00:27:46,300 --> 00:27:48,660
PROFESOR: Benar, ya, jadi
Anda benar sekali.

691
00:27:48,660 --> 00:27:53,500
Anda seharusnya tidak terlalu bergantung
pada TCP untuk memberikan keamanan

692
00:27:53,500 --> 00:27:54,817
yang sangat kuat.

693
00:27:54,817 --> 00:27:56,900
Karena Anda benar, hanya
ada 4 miliar tebakan.

694
00:27:56,900 --> 00:27:59,370
Dan Anda mungkin dapat
mengirimkan paket sebanyak itu

695
00:27:59,370 --> 00:28:02,780
dalam sehari jika Anda
memiliki koneksi yang cukup cepat.

696
00:28:05,510 --> 00:28:07,562
Jadi itu semacam
argumen yang menarik

697
00:28:07,562 --> 00:28:09,645
di sini dalam hal
pada titik tertentu,

698
00:28:09,645 --> 00:28:11,120
TCP sepertinya tidak aman.

699
00:28:11,120 --> 00:28:12,270
Karena itu hanya 32 bit.

700
00:28:12,270 --> 00:28:14,090
Tidak mungkin kita dapat
membuatnya menjadi aman.

701
00:28:14,090 --> 00:28:15,631
Tapi saya rasa fakta bahwa banyak
aplikasi mengandalkannya

702
00:28:15,631 --> 00:28:18,740
dan tidak mengimplementasikan
keamanan di luar hal itu

703
00:28:18,740 --> 00:28:22,368
menjadi sangat mengganggu
dan menjadi sebuah masalah.

704
00:28:22,368 --> 00:28:24,060
Namun Anda benar-benar tepat.

705
00:28:24,060 --> 00:28:26,790
Dalam praktiknya, Anda ingin
melakukan semacam enkripsi

706
00:28:26,790 --> 00:28:29,350
di atas hal ini yang
akan memberikan jaminan

707
00:28:29,350 --> 00:28:31,610
lebih kuat bahwa tidak ada orang
yang merusak data Anda,

708
00:28:31,610 --> 00:28:33,710
tapi bila kuncinya
lebih panjang dari 32 bit.

709
00:28:39,120 --> 00:28:41,242
Ternyata masih berguna untuk
mencegah orang

710
00:28:41,242 --> 00:28:45,812
untuk merusak menggunakan koneksi
TCP dalam banyak kasus.

711
00:28:45,812 --> 00:28:48,140
Baiklah, pertanyaan lain?

712
00:28:48,140 --> 00:28:50,435
Baiklah, jadi mari kita lihat
apa yang sebenarnya salah.

713
00:28:50,435 --> 00:28:53,360
Mengapa itu merupakan hal
yang buruk jika orang-orang tersebut

714
00:28:53,360 --> 00:28:56,990
dapat memalsukan koneksi TCP
dari alamat apapun?

715
00:28:56,990 --> 00:29:00,335
Jadi salah satu alasan mengapa
hal ini buruk adalah jika ada

716
00:29:00,335 --> 00:29:03,460
segala jenis otorisasi
yang berbasis IP.

717
00:29:08,240 --> 00:29:11,600
Jadi jika beberapa server memutuskan
apakah sebuah operasi akan

718
00:29:11,600 --> 00:29:14,170
diperbolehkan atau tidak berdasarkan
alamat IP itu berasal,

719
00:29:14,170 --> 00:29:16,000
maka ini akan
berpotensi menjadi

720
00:29:16,000 --> 00:29:18,950
sebuah masalah di mana penyerang
memalsukan koneksi

721
00:29:18,950 --> 00:29:21,440
dari sebuah alamat sumber
yang acak.

722
00:29:21,440 --> 00:29:24,040
Jadi satu contoh di mana
ini menjadi masalah--

723
00:29:24,040 --> 00:29:26,350
dan ini sebagian besar
sudah tidak lagi-- adalah

724
00:29:26,350 --> 00:29:30,910
keluarga perintah r ini,
hal-hal seperti rlogin.

725
00:29:30,910 --> 00:29:33,160
Jadi dulu kasusnya
adalah Anda dapat menjalankan sesuatu

726
00:29:33,160 --> 00:29:34,984
seperti rlogin ke sebuah
mesin, contohnya

727
00:29:34,984 --> 00:29:35,900
athena.dialup.mit.edu.

728
00:29:41,360 --> 00:29:45,600
Dan jika koneksi Anda
berasal dari sebuah host di MIT,

729
00:29:45,600 --> 00:29:49,000
maka perintah rlogin ini akan
sukses jika Anda berkata, oh ya,

730
00:29:49,000 --> 00:29:51,174
saya pengguna Alice di mesin ini.

731
00:29:51,174 --> 00:29:53,340
Biarkan saya masuk sebagai Alice
ke mesin yang lain ini.

732
00:29:53,340 --> 00:29:55,548
Dan itu mengasumsikan bahwa
semua mesin yang ada di mit.edu

733
00:29:55,548 --> 00:29:58,410
dapat dipercaya untuk
membuat pernyataan itu.

734
00:29:58,410 --> 00:30:00,700
Saya harus mengatakan bahwa menurut saya
dial-up tidak benar-benar pernah

735
00:30:00,700 --> 00:30:01,500
memiliki masalah ini.

736
00:30:01,500 --> 00:30:03,416
Dia sudah menggunakan Cerberus
semenjak pertama kali.

737
00:30:03,416 --> 00:30:07,360
Tetapi sistem lain tentu
memiliki masalah seperti itu.

738
00:30:07,360 --> 00:30:10,610
Dan ini adalah contoh dari
penggunaan alamat IP di mana

739
00:30:10,610 --> 00:30:15,170
koneksinya berasal dari
semacam mekanisme otentikasi

740
00:30:15,170 --> 00:30:19,190
untuk menentukan apakah
pemanggil atau klien

741
00:30:19,190 --> 00:30:20,470
dapat dipercaya atau tidak.

742
00:30:20,470 --> 00:30:22,650
Jadi ini tentu
pernah menjadi masalah,

743
00:30:22,650 --> 00:30:23,730
namun tidak lagi.

744
00:30:23,730 --> 00:30:27,120
Jadi mengandalkan IP sepertinya
merupakan rencana yang buruk.

745
00:30:27,120 --> 00:30:28,980
Namun, kenyataannya
masih demikian.

746
00:30:28,980 --> 00:30:30,160
Jadi rlogin sudah hilang.

747
00:30:30,160 --> 00:30:33,574
Baru-baru ini digantikan
oleh SSH, dimana hal tersebut bagus.

748
00:30:33,574 --> 00:30:34,990
Di sisi lain,
masih banyak

749
00:30:34,990 --> 00:30:38,470
contoh protokol lain
yang mengandalkan

750
00:30:38,470 --> 00:30:40,530
otentikasi berbasis IP.

751
00:30:40,530 --> 00:30:41,890
Salah satunya adalah SMTP.

752
00:30:41,890 --> 00:30:45,555
Jadi ketika Anda mengirim email, Anda
menggunakan SMTP untuk berkomunikasi dengan sebuah

753
00:30:45,555 --> 00:30:47,650
server untuk mengirim pesan.

754
00:30:47,650 --> 00:30:51,120
Dan untuk mencegah spam,
banyak server SMTP

755
00:30:51,120 --> 00:30:53,470
yang hanya akan menerima
pesan masuk

756
00:30:53,470 --> 00:30:55,710
dari alamat IP
tertentu.

757
00:30:55,710 --> 00:30:57,460
Jadi sebagai contoh,
server surat Comcast

758
00:30:57,460 --> 00:31:00,280
hanya akan menerima surat
dari alamat IP Comcast.

759
00:31:00,280 --> 00:31:02,570
Sama juga bagi server surat MIT--
hanya akan menerima surat

760
00:31:02,570 --> 00:31:03,500
dari alamat IP MIT.

761
00:31:03,500 --> 00:31:06,260
Atau setidaknya ada
satu server yang tidak

762
00:31:06,260 --> 00:31:08,910
berjalan yang mempunyai properti ini.

763
00:31:08,910 --> 00:31:11,090
Jadi ini adalah kasus
di mana ini masih

764
00:31:11,090 --> 00:31:13,026
menggunakan otentikasi berbasis IP.

765
00:31:13,026 --> 00:31:14,905
Di sini, ini tidak terlalu buruk.

766
00:31:14,905 --> 00:31:16,775
Kasus terburuk, Anda akan
mengirim beberapa spam

767
00:31:16,775 --> 00:31:17,775
melalui server surat.

768
00:31:17,775 --> 00:31:19,890
Jadi itulah mengapa
mereka masih menggunakan ini,

769
00:31:19,890 --> 00:31:23,710
sedangkan hal-hal yang memungkinkan Anda
untuk masuk ke akun apapun

770
00:31:23,710 --> 00:31:27,280
sudah berhenti menggunakan otentikasi berbasis
IP.

771
00:31:27,280 --> 00:31:29,820
Jadi apakah ini masuk akal,
mengapa ini adalah sebuah rencana yang buruk?

772
00:31:29,820 --> 00:31:33,500
Dan untuk memastikan,
misalkan beberapa server

773
00:31:33,500 --> 00:31:34,554
menggunakan rlogin.

774
00:31:34,554 --> 00:31:35,845
Apa yang akan Anda lakukan untung menyerangnya?

775
00:31:35,845 --> 00:31:39,640
Hal buruk apa yang akan terjadi?

776
00:31:39,640 --> 00:31:41,590
Saran?

777
00:31:41,590 --> 00:31:42,090
Ya.

778
00:31:42,090 --> 00:31:44,026
AUDIENS: Cukup masuk
ke komputer Anda,

779
00:31:44,026 --> 00:31:46,482
lalu buat pengguna
yang ingin Anda masuki,

780
00:31:46,482 --> 00:31:47,898
kemudian Anda masuk
ke dalam jaringan.

781
00:31:47,898 --> 00:31:50,450
PROFESOR: Ya, jadi pada dasarnya
Anda masuk ke komputer.

782
00:31:50,450 --> 00:31:53,955
Anda mensintesis datanya agar
terlihat seperti seperangkat

783
00:31:53,955 --> 00:31:56,170
perintah rlogin yang sah yang menyatakan,
masuk sebagai pengguna ini

784
00:31:56,170 --> 00:31:58,980
dan jalankan perintah ini
di shell Unix.

785
00:31:58,980 --> 00:32:01,780
Anda semacam mensintesis data ini
dan Anda juga memasang keseluruhan serangan ini

786
00:32:01,780 --> 00:32:04,295
dan mengirimkan data ini seolah-olah seorang
pengguna yang sah sedang berinteraksi

787
00:32:04,295 --> 00:32:09,275
dengan sebuah klien rlogin, dan
setelah itu Anda sudah selesai.

788
00:32:09,275 --> 00:32:11,280
OK, jadi ini salah satu
alasan mengapa Anda mungkin

789
00:32:11,280 --> 00:32:15,560
tidak ingin nomor urut TCP Anda
mudah untuk ditebak.

790
00:32:15,560 --> 00:32:17,340
Masalah lainnya adalah
serangan reset ini.

791
00:32:17,340 --> 00:32:23,120
Sama seperti kita sudah dapat
mengirimkan sebuah paket SYN,

792
00:32:23,120 --> 00:32:25,222
jika Anda tahu nomor urut
seseorang,

793
00:32:25,222 --> 00:32:26,680
Anda juga dapat mengirimkan
sebuah paket reset.

794
00:32:26,680 --> 00:32:27,810
Kita sudah membahasnya
secara singkat

795
00:32:27,810 --> 00:32:29,750
di sini sebagai klien sah
yang berpotensi

796
00:32:29,750 --> 00:32:32,975
untuk mengirimkan sebuah paket reset untuk
mengatur kembali koneksi palsu

797
00:32:32,975 --> 00:32:35,200
yang dibuat
oleh si penyerang.

798
00:32:35,200 --> 00:32:36,960
Tapi di situasi yang 
mirip, musuh

799
00:32:36,960 --> 00:32:40,180
dapat mencoba untuk mengirimkan paket reset
untuk sebuah koneksi yang sudah ada

800
00:32:40,180 --> 00:32:42,400
jika ada cara
agar musuh dapat mengetahui

801
00:32:42,400 --> 00:32:46,060
berapa nomor urut Anda
pada koneksi tersebut.

802
00:32:46,060 --> 00:32:48,850
Jadi ini sebenarnya tidak jelas
apakah merupakan sebuah masalah besar

803
00:32:48,850 --> 00:32:49,750
atau tidak.

804
00:32:49,750 --> 00:32:51,240
Pada tingkat tertentu,
mungkin Anda harus

805
00:32:51,240 --> 00:32:52,490
mengasumsikan bahwa bagaimanapun juga
semua koneksi TCP Anda dapat

806
00:32:52,490 --> 00:32:53,450
dirusak kapan pun itu.

807
00:32:53,450 --> 00:32:55,210
Ini tidak seperti jaringan
yang dapat diandalkan.

808
00:32:55,210 --> 00:32:57,920
Jadi mungkin Anda seharusnya mengharapkan
koneksi Anda terputus.

809
00:32:57,920 --> 00:32:59,710
Tetapi suatu tempat di mana
ini ternyata

810
00:32:59,710 --> 00:33:03,000
menjadi bukan sebuah asumsi
yang baik untuk dibuat

811
00:33:03,000 --> 00:33:06,060
adalah pada kasus di mana router
berkomunikasi satu dengan yang lain.

812
00:33:06,060 --> 00:33:08,340
Jadi jika Anda memiliki
beberapa router yang

813
00:33:08,340 --> 00:33:10,505
mengkomunikasikan beberapa
protokol pengaturan rute, maka mereka

814
00:33:10,505 --> 00:33:13,590
terhubung, tentu saja,
oleh beberapa jaringan fisik.

815
00:33:13,590 --> 00:33:16,480
Tetapi melalui beberapa jaringan
fisik, mereka sebenarnya

816
00:33:16,480 --> 00:33:18,000
mengkomunikasikan beberapa protokol jaringan.

817
00:33:18,000 --> 00:33:19,671
Dan protokol jaringan tersebut
berjalan di atas TCP.

818
00:33:19,671 --> 00:33:21,170
Jadi sebenarnya ada
sesi TCP

819
00:33:21,170 --> 00:33:22,878
berjalan di atas masing-masing
tautan fisik ini

820
00:33:22,878 --> 00:33:26,672
yang digunakan oleh router untuk
bertukar informasi pengaturan rute.

821
00:33:26,672 --> 00:33:28,630
Jadi ini pasti
kasusnya bagi protokol

822
00:33:28,630 --> 00:33:32,250
bernama BGP yang akan kita bicarakan
lebih lanjut sebentar lagi.

823
00:33:32,250 --> 00:33:36,050
Dan BGP menggunakan fakta
bahwa koneksi TCP

824
00:33:36,050 --> 00:33:39,580
hidup untuk juga menyiratkan
bahwa tautannya hidup.

825
00:33:39,580 --> 00:33:41,750
Jadi jika koneksi TCP
terputus, maka router

826
00:33:41,750 --> 00:33:43,090
mengasumsikan tautannya terputus.

827
00:33:43,090 --> 00:33:46,350
Dan mereka menghitung ulang semua
tabel pengaturan rute mereka.

828
00:33:46,350 --> 00:33:47,875
Jadi jika seorang musuh
ingin memasang

829
00:33:47,875 --> 00:33:49,819
semacam serangan denial
of service di sini,

830
00:33:49,819 --> 00:33:51,319
mereka dapat mencoba untuk
menebak nomor

831
00:33:51,319 --> 00:33:54,520
urut dari router-router ini
dan menyetel ulang session-session ini.

832
00:33:54,520 --> 00:33:57,876
Jadi jika sesi TCP antara
dua router terputus,

833
00:33:57,876 --> 00:33:59,750
kedua router akan berpikir,
oh, tautan ini mati.

834
00:33:59,750 --> 00:34:01,583
Kita harus menghitung ulang
semua tabel pengaturan rute,

835
00:34:01,583 --> 00:34:02,510
dan rutenya berubah.

836
00:34:02,510 --> 00:34:05,235
Dan kemudian Anda mungkin menembak mati
tautan lainnya, dan seterusnya.

837
00:34:05,235 --> 00:34:07,300
Jadi ini serangan yang
cukup mengkhawatirkan,

838
00:34:07,300 --> 00:34:12,489
bukan karena melanggar
privasi seseorang, dan lain-lain,

839
00:34:12,489 --> 00:34:15,510
atau setidaknya tidak secara langsung,
tetapi lebih karena ini benar-benar

840
00:34:15,510 --> 00:34:19,310
menyebabkan banyak
masalah ketersediaan

841
00:34:19,310 --> 00:34:21,079
bagi pengguna lain di sistem.

842
00:34:21,079 --> 00:34:21,734
Ya.

843
00:34:21,734 --> 00:34:23,960
AUDIENS: Jadi jika Anda
adalah seorang penyerang,

844
00:34:23,960 --> 00:34:26,170
dan Anda ingin menarget
satu pengguna spesifik,

845
00:34:26,170 --> 00:34:29,740
bisakah Anda terus
mengirimkan pemintaan koneksi

846
00:34:29,740 --> 00:34:32,594
ke server menggunakan
IP-nya dan membuat

847
00:34:32,594 --> 00:34:33,969
dia terus menjatuhkan
koneksinya

848
00:34:33,969 --> 00:34:38,679
ke server dan lalu
Anda [TIDAK TERDENGAR]?

849
00:34:38,679 --> 00:34:41,540
PROFESOR: Yah, jadi itu
mengharuskan Anda menebak.

850
00:34:41,540 --> 00:34:43,460
Jadi maksud Anda,
misalkan saya menggunakan Gmail,

851
00:34:43,460 --> 00:34:45,835
dan Anda ingin mencegah saya dari
mempelajari sesuatu di Gmail,

852
00:34:45,835 --> 00:34:48,292
jadi kirimkan saja paket
ke mesin saya

853
00:34:48,292 --> 00:34:49,530
dengan berpura-pura dari Gmail.

854
00:34:49,530 --> 00:34:51,980
Yah, Anda harus menebak
nomor port sumber dan tujuan

855
00:34:51,980 --> 00:34:52,787
yang tepat.

856
00:34:52,787 --> 00:34:54,620
Nomor port tujuannya
mungkin 443,

857
00:34:54,620 --> 00:34:55,912
karena saya menggunakan HTTPS.

858
00:34:55,912 --> 00:34:57,370
Tetapi nomor 
port sumbernya adalah

859
00:34:57,370 --> 00:34:59,390
serangkaian 16-bit yang acak.

860
00:34:59,390 --> 00:35:02,040
Dan itu juga akan menjadi
kasus di mana kemungkinan

861
00:35:02,040 --> 00:35:03,070
dari nomor urutnya akan
menjadi berbeda.

862
00:35:03,070 --> 00:35:04,903
Jadi kecuali Anda menebak
nomor urut yang ada

863
00:35:04,903 --> 00:35:09,650
di dalam jendela TCP saya, yang
urutannya mungkin

864
00:35:09,650 --> 00:35:11,400
puluhan kilobyte,
Anda juga

865
00:35:11,400 --> 00:35:13,280
tidak akan berhasil
dalam hal itu.

866
00:35:13,280 --> 00:35:17,350
Jadi Anda harus menebak hal
dalam jumlah yang wajar.

867
00:35:17,350 --> 00:35:19,168
Tidak ada semacam
akses serbatahu.

868
00:35:19,168 --> 00:35:21,293
Anda tidak bisa hanya menanyakan
server dan berkata berapakah

869
00:35:21,293 --> 00:35:23,130
nomor urut orang itu?

870
00:35:23,130 --> 00:35:27,890
Jadi itu adalah alasan mengapa
hal itu juga tidak berhasil.

871
00:35:27,890 --> 00:35:30,040
Dan lagi, banyak dari
masalah ini telah

872
00:35:30,040 --> 00:35:31,880
diperbaiki, termasuk
hal berbasis RST ini,

873
00:35:31,880 --> 00:35:33,065
terutama bagi router BGP.

874
00:35:35,890 --> 00:35:38,460
Sebenarnya ada dua
perbaikan yang mencengangkan.

875
00:35:38,460 --> 00:35:41,389
Pertama benar-benar menunjukkan Anda
bagaimana Anda dapat dengan berhati-hati

876
00:35:41,389 --> 00:35:43,430
memanfaatkan hal-hal yang ada
atau memanfaatkan mereka

877
00:35:43,430 --> 00:35:45,670
untuk memperbaiki masalah tertentu.

878
00:35:45,670 --> 00:35:47,747
Di sini, wawasannya adalah
bahwa router-router ini hanya

879
00:35:47,747 --> 00:35:49,497
ingin berbicara kepada
sesama, tidak kepada orang lain

880
00:35:49,497 --> 00:35:50,980
melalui jaringan.

881
00:35:50,980 --> 00:35:52,990
Dan jadi untuk hasilnya,
jika paket tersebut

882
00:35:52,990 --> 00:35:55,817
datang bukan dari
router yang berada di sebelah tautan,

883
00:35:55,817 --> 00:35:58,442
tapi dari tempat lain, saya ingin
membuang semua paket ini.

884
00:35:58,442 --> 00:36:01,730
Dan apa yang perancang protokol
penulisan ini sadari adalah

885
00:36:01,730 --> 00:36:04,370
ada sebuah bidang yang hebat
di dalam sebuah paket yang disebut waktu

886
00:36:04,370 --> 00:36:05,390
hidup.

887
00:36:05,390 --> 00:36:08,665
Itu adalah sebuah bidang 8-bit yang
dikurangi oleh setiap router

888
00:36:08,665 --> 00:36:11,840
untuk memastikan paket tersebut
tidak masuk kedalam pengulangan tidak terbatas.

889
00:36:11,840 --> 00:36:15,180
Jadi nilai maksimum yang
dapat dicapai oleh TTL ini adalah 255.

890
00:36:15,180 --> 00:36:17,630
Dan akan dikurangi
dari situ.

891
00:36:17,630 --> 00:36:19,165
Jadi apa yang dilakukan
protokol penulisan ini--

892
00:36:19,165 --> 00:36:23,000
itu semacam sebuah
peretasan yang cerdas-- yaitu mereka

893
00:36:23,000 --> 00:36:27,220
menolak paket apapun yang memiliki
nilai TTL yang bukan 255.

894
00:36:27,220 --> 00:36:29,660
Karena jika sebuah paket
memiliki nilai 255,

895
00:36:29,660 --> 00:36:31,430
itu pasti datang
dari router

896
00:36:31,430 --> 00:36:33,530
yang berada di sisi
lain dari tautan ini.

897
00:36:33,530 --> 00:36:35,630
Dan jika penyerang mencoba
menyuntikkan paket apapun

898
00:36:35,630 --> 00:36:37,900
untuk merusak koneksi
BGP yang sudah ada,

899
00:36:37,900 --> 00:36:39,852
itu akan memiliki
nilai TTL lebih kecil dari 255,

900
00:36:39,852 --> 00:36:41,935
karena itu akan dikurangi
oleh router lainnya

901
00:36:41,935 --> 00:36:44,520
sepanjang jalan,
termasuk yang satu ini.

902
00:36:44,520 --> 00:36:47,766
Dan setelah itu akan
ditolak oleh penerimanya.

903
00:36:47,766 --> 00:36:50,762
Jadi ini adalah satu contoh
sebuah kombinasi pintar

904
00:36:50,762 --> 00:36:52,470
dari sebuah teknik yang
kompatibel ke belakang

905
00:36:52,470 --> 00:36:54,658
dan memecahkan masalah
yang sangat spesifik ini.

906
00:36:54,658 --> 00:36:55,158
Ya.

907
00:36:55,158 --> 00:36:56,866
AUDIENS: Bukankah router
kanan bawah

908
00:36:56,866 --> 00:36:58,616
juga mengirimkan sesuatu
dengan TTL 255

909
00:36:58,616 --> 00:37:00,670
PROFESOR: Ya, sebenarnya router
ini adalah--

910
00:37:00,670 --> 00:37:01,830
sebuah router fisik.

911
00:37:01,830 --> 00:37:03,780
Dan dia mengetahui
bahwa ini adalah tautan yang berbeda.

912
00:37:03,780 --> 00:37:07,130
Jadi dia melihat pada TTL
dan tautan mana yang digunakan.

913
00:37:07,130 --> 00:37:09,150
Jadi jika sebuah paket
datang pada tautan ini,

914
00:37:09,150 --> 00:37:12,840
dia tidak akan menerimanya
untuk koneksi TCP ini.

915
00:37:12,840 --> 00:37:13,896
Tapi Anda benar.

916
00:37:13,896 --> 00:37:17,630
Untuk sebagian besar kasus,
router ini mempercayai

917
00:37:17,630 --> 00:37:19,450
tetangga langsung mereka.

918
00:37:19,450 --> 00:37:20,950
Namun tidak harus
selalu begitu.

919
00:37:20,950 --> 00:37:22,016
Tapi jika Anda seringkali
menemukan masalah ini,

920
00:37:22,016 --> 00:37:23,740
dan Anda tahu bahwa Anda
sudah mengimplementasikan cara ini,

921
00:37:23,740 --> 00:37:24,720
maka itu pasti salah satu
dari tetangga-tetangga Anda.

922
00:37:24,720 --> 00:37:25,594
Anda akan melihat.

923
00:37:25,594 --> 00:37:27,162
TCP membuang antarmuka-antarmuka ini.

924
00:37:27,162 --> 00:37:29,210
Mengapa Anda mengirimkan saya
paket-paket reset ini?

925
00:37:29,210 --> 00:37:31,120
Masalah ini tidak terlalu besar.

926
00:37:31,120 --> 00:37:34,736
Anda dapat mengelolanya dengan
beberapa mekanisme Auto Pan.

927
00:37:34,736 --> 00:37:36,005
Masuk akal?

928
00:37:36,005 --> 00:37:38,450
Baiklah, ada
beberapa perbaikan untuk BGP

929
00:37:38,450 --> 00:37:41,550
di mana mereka mengimplementasi beberapa 
bentuk header autentikasi,

930
00:37:41,550 --> 00:37:43,480
header autentikasi MD5
MD5 juga.

931
00:37:43,480 --> 00:37:46,220
Tapi mereka benar-benar menargetkan
aplikasi khusus ini

932
00:37:46,220 --> 00:37:48,340
di mana serangan reset ini
sangat buruk.

933
00:37:48,340 --> 00:37:49,975
Ini masih menjadi masalah sekarang.

934
00:37:49,975 --> 00:37:51,975
Jika terdapat beberapa
koneksi yang berumur panjang

935
00:37:51,975 --> 00:37:53,766
di luar sana yang saya sangat
ingin tembak mati,

936
00:37:53,766 --> 00:37:58,480
Saya hanya perlu mengirimkan
paket RST dalam jumlah besar,

937
00:37:58,480 --> 00:38:00,730
mungkin sebesar
ratusan ribu

938
00:38:00,730 --> 00:38:04,770
atau lebih, tapi mungkin
tidak benar-benar 4 miliar.

939
00:38:04,770 --> 00:38:07,930
Karena servernya
sebenarnya agak

940
00:38:07,930 --> 00:38:10,520
longgar dalam hal nomor urut
yang mereka terima untuk reset.

941
00:38:10,520 --> 00:38:13,360
Itu bisa saja paket apa pun
dalam rentang tertentu.

942
00:38:13,360 --> 00:38:16,730
Dan dalam kasus ini, saya mungkin
dapat, atau penyerang mana pun,

943
00:38:16,730 --> 00:38:19,500
mengatur ulang sebuah
koneksi yang ada dengan sederhana

944
00:38:19,500 --> 00:38:21,262
tanpa banyak usaha.

945
00:38:21,262 --> 00:38:22,738
Itu masih menjadi masalah.

946
00:38:22,738 --> 00:38:25,460
Dan orang-orang belum benar-benar menemukan
solusi yang baik untuk itu.

947
00:38:28,640 --> 00:38:31,576
Baiklah, dan saya kira
semacam hal buruk terakhir yang

948
00:38:31,576 --> 00:38:33,700
terjadi karena nomor urut
ini agak

949
00:38:33,700 --> 00:38:36,331
mudah ditebak adalah
injeksi data

950
00:38:36,331 --> 00:38:39,280
ke koneksi yang ada.

951
00:38:39,280 --> 00:38:43,550
Jadi misalkan ada beberapa
protokol seperti rlogin,

952
00:38:43,550 --> 00:38:47,650
tapi mungkin rlogin tidak--
misalkan kita memiliki beberapa

953
00:38:47,650 --> 00:38:49,710
protokol hipotetis
yang mirip seperti rlogin,

954
00:38:49,710 --> 00:38:51,990
tetapi sebenarnya protokol itu tidak
melakukan autentikasi berbasis IP.

955
00:38:51,990 --> 00:38:53,364
Anda harus mengetikkan
kata sandi Anda

956
00:38:53,364 --> 00:38:55,392
untuk masuk, semua hal hebat ini.

957
00:38:55,392 --> 00:38:57,350
Masalahnya adalah setelah Anda
mengetikkan kata sandi Anda,

958
00:38:57,350 --> 00:38:59,225
mungkin koneksi TCP anda
baru saja dibuat

959
00:38:59,225 --> 00:39:01,060
dan dapat menerima data sembarang.

960
00:39:01,060 --> 00:39:03,392
Jadi menunggu salah satu dari kalian
masuk ke dalam mesin, mengetikkan

961
00:39:03,392 --> 00:39:04,100
kata sandi Anda.

962
00:39:04,100 --> 00:39:05,235
Saya tidak tahu
apa kata sandi itu.

963
00:39:05,235 --> 00:39:07,026
Tapi begitu koneksi TCP
TCP terbangun,

964
00:39:07,026 --> 00:39:09,120
saya hanya akan mencoba menebak
nomor urut Anda

965
00:39:09,120 --> 00:39:11,332
dan memasukkan beberapa data
ke koneksi Anda yang sudah terhubung.

966
00:39:11,332 --> 00:39:13,415
Jadi jika saya dapat menebak
nomor urut Anda dengan benar,

967
00:39:13,415 --> 00:39:16,005
maka hal ini memungkinkan saya
untuk berpura-pura seperti

968
00:39:16,005 --> 00:39:18,255
Anda telah mengetikkan beberapa perintah
setelah Anda terautentikasi

969
00:39:18,255 --> 00:39:19,977
dengan benar dengan kata sandi Anda.

970
00:39:19,977 --> 00:39:21,810
Jadi ini semua menunjukkan
bahwa Anda benar-benar

971
00:39:21,810 --> 00:39:28,260
tidak ingin bergantung pada
nomor urut 32-bit ini

972
00:39:28,260 --> 00:39:30,430
untuk memberikan keamanan.

973
00:39:30,430 --> 00:39:33,660
Tapi mari kita lihat apa sebenarnya
yang dilakukan oleh tumpukan TCP modern

974
00:39:33,660 --> 00:39:35,650
untuk mencoba mengurangi
masalah ini.

975
00:39:35,650 --> 00:39:37,650
Jadi saat kita
sedang berdiskusi,

976
00:39:37,650 --> 00:39:41,170
Saya rasa satu pendekatan yang
akan kita lihat dalam dua

977
00:39:41,170 --> 00:39:44,780
kuliah berikutnya adalah bagaimana
cara menerapkan beberapa keamanan

978
00:39:44,780 --> 00:39:45,910
pada level aplikasi.

979
00:39:45,910 --> 00:39:50,160
Jadi kita akan menggunakan kriptografi
untuk autentikasi dan enkripsi

980
00:39:50,160 --> 00:39:54,460
dan menandatangani dan verifikasi pesan-pesan
pada level aplikasi

981
00:39:54,460 --> 00:39:57,420
tanpa benar-benar
banyak melibatkan TCP.

982
00:39:57,420 --> 00:39:59,606
Tapi ada beberapa
aplikasi yang sudah ada

983
00:39:59,606 --> 00:40:03,950
yang akan mendapatkan manfaat dari
membuat ini sedikit lebih baik,

984
00:40:03,950 --> 00:40:07,160
setidaknya tidak memudahkan hal itu
untuk mengeksploitasi masalah-masalah ini.

985
00:40:07,160 --> 00:40:09,360
Dan saya rasa cara
orang melakukan hal ini

986
00:40:09,360 --> 00:40:13,200
dalam praktiknya saat ini-- sebagai
contoh Linux dan Windows--

987
00:40:13,200 --> 00:40:17,360
adalah mereka mengimplementasi usulan
yang diberikan John sebelumnya,

988
00:40:17,360 --> 00:40:20,920
bahwa kita mengelola
nomor urut awal yang berbeda

989
00:40:20,920 --> 00:40:22,820
untuk setiap pasangan
sumber dan penerima.

990
00:40:22,820 --> 00:40:29,110
Jadi sebagian besar hal yang
diimplementasi oleh SYN TCP

991
00:40:29,110 --> 00:40:33,200
adalah masih membuat mereka menghitung
nomor urut awal ini sama

992
00:40:33,200 --> 00:40:34,590
seperti yang kita lakukan sebelumnya.

993
00:40:34,590 --> 00:40:39,600
Jadi katakanlah ini sebagai
gaya lama dari ISN.

994
00:40:39,600 --> 00:40:42,000
Dan untuk benar-benar
menghasilkan ISN

995
00:40:42,000 --> 00:40:44,650
yang aktual untuk
koneksi tertentu,

996
00:40:44,650 --> 00:40:48,130
kita akan menambahkan
offset acak 32 bit.

997
00:40:48,130 --> 00:40:51,005
Jadi kita akan mengikutsertakan
semacam fungsi.

998
00:40:51,005 --> 00:40:54,010
Pikirkan itu sebagai sebuah
fungsi hash seperti SHA-1

999
00:40:54,010 --> 00:40:56,295
atau sesuatu yang lebih baik.

1000
00:40:56,295 --> 00:40:59,190
Dan ini akan menjadi
sebuah fungsi dari

1001
00:40:59,190 --> 00:41:05,140
IP sumber, nomor port sumber,
alamat penerima IP,

1002
00:41:05,140 --> 00:41:10,820
port tujuan, dan semacam
kunci rahasia

1003
00:41:10,820 --> 00:41:14,900
yang pada kasus ini hanya
diketahui oleh server.

1004
00:41:14,900 --> 00:41:17,290
Jadi ini memiliki
properti yang bagus di mana

1005
00:41:17,290 --> 00:41:19,350
di dalam koneksi
jenis apapun,

1006
00:41:19,350 --> 00:41:24,147
yang telah diidentifikasi oleh sebuah sumber
dan tujuan pasangan port IP,

1007
00:41:24,147 --> 00:41:25,980
dia masih mempertahankan seluruh
properti yang bagus

1008
00:41:25,980 --> 00:41:30,000
dari algoritme urutan
nomor sebelumnya ini.

1009
00:41:30,000 --> 00:41:34,780
Tapi jika Anda memiliki koneksi dari
tupel sumber/tujuan berbeda,

1010
00:41:34,780 --> 00:41:37,230
maka tidak akan ada hal
yang bisa Anda

1011
00:41:37,230 --> 00:41:41,600
ketahui mengenai nilai
dari nomor urut

1012
00:41:41,600 --> 00:41:42,780
tupel koneksi lain.

1013
00:41:42,780 --> 00:41:45,450
Dan bahkan, Anda akan diharuskan
untuk menebak kunci ini untuk

1014
00:41:45,450 --> 00:41:47,680
bisa menyimpulkan nilai tersebut.

1015
00:41:47,680 --> 00:41:50,580
Dan mudah-mudahan servernya,
kemungkinan kernel OS-nya,

1016
00:41:50,580 --> 00:41:52,290
menyimpan kunci ini
di suatu tempat di dalam memori

1017
00:41:52,290 --> 00:41:54,670
dan tidak memberikannya
kepada orang lain.

1018
00:41:54,670 --> 00:41:56,420
Jadi kurang lebih inilah cara hampir
semua stack TCP

1019
00:41:56,420 --> 00:41:58,365
menangani masalah
masalah tersebut

1020
00:41:58,365 --> 00:42:02,896
hari ini sejauh yang dimungkinkan
dengan nomor urut berukuran

1021
00:42:02,896 --> 00:42:03,395
32-bit.

1022
00:42:03,395 --> 00:42:04,050
Hal tersebut tidak sempurna,
tapi masih bisa bekerja.

1023
00:42:04,050 --> 00:42:04,543
Yah.

1024
00:42:04,543 --> 00:42:06,126
AUDIENS: Bisakah Anda
ulangi lagi?

1025
00:42:06,126 --> 00:42:09,480
Apakah kuncinya unik untuk--

1026
00:42:09,480 --> 00:42:11,380
PROFESOR: Jadi ketika
mesin saya menyala,

1027
00:42:11,380 --> 00:42:13,780
atau saat ada mesin yang menyala,
dia menghasilkan kunci acak.

1028
00:42:13,780 --> 00:42:16,530
Setiap kali Anda menyalakan ulang mesin
itu menghasilkan kunci baru.

1029
00:42:16,530 --> 00:42:20,565
Dan ini berarti bahwa
untuk pasangan sumber/tujuan tertentu,

1030
00:42:20,565 --> 00:42:24,680
setiap kali nomor
urut nya

1031
00:42:24,680 --> 00:42:26,830
maju pada tingkat
yang sama seperti yang

1032
00:42:26,830 --> 00:42:27,820
dikendalikan oleh hal ini.

1033
00:42:27,820 --> 00:42:29,444
Jadi untuk pasangan sumber/
tujuan yang diberikan,

1034
00:42:29,444 --> 00:42:30,850
hal ini sudah tetap.

1035
00:42:30,850 --> 00:42:32,889
Jadi Anda memperhatikan
nomor urut Anda

1036
00:42:32,889 --> 00:42:34,680
berevolusi berdasarkan
nomor urut awal Anda

1037
00:42:34,680 --> 00:42:36,596
untuk koneksi baru
berevolusi berdasarkan

1038
00:42:36,596 --> 00:42:39,480
algoritme tertentu.

1039
00:42:39,480 --> 00:42:43,915
Sehingga masih menyediakan semua
pertahanan terhadap paket lama

1040
00:42:43,915 --> 00:42:47,120
dari koneksi sebelumnya yang
disisipkan ke koneksi baru,

1041
00:42:47,120 --> 00:42:50,430
seperti masalah pengurutan
ulang paket.

1042
00:42:50,430 --> 00:42:51,630
Jadi dia masih bisa berfungsi.

1043
00:42:51,630 --> 00:42:53,490
Dan itu adalah satu-satunya
hal yang nyata di mana

1044
00:42:53,490 --> 00:42:56,030
kita memerlukan algoritme
pemilihan nomor urut ini

1045
00:42:56,030 --> 00:42:58,800
untuk mencegah paket ganda
ini yang dapat menyebabkan masalah.

1046
00:42:58,800 --> 00:43:01,660
Bagaimanapun juga, hal yang
kita eksploitasi sebelumnya,

1047
00:43:01,660 --> 00:43:04,095
yaitu jika Anda
mendapatkan nomor

1048
00:43:04,095 --> 00:43:08,130
urut untuk satu koneksi
dari A ke S, maka

1049
00:43:08,130 --> 00:43:10,715
dari situ anda dapat menyimpulkan
nomor urut

1050
00:43:10,715 --> 00:43:12,360
untuk koneksi yang berbeda.

1051
00:43:12,360 --> 00:43:13,080
Itu sekarang sudah hilang.

1052
00:43:13,080 --> 00:43:14,750
Kerena setiap koneksi
memiliki offset berbeda

1053
00:43:14,750 --> 00:43:19,790
falam ruang 32-bit ini seperti
diimplementasikan oleh fungsi F nya.

1054
00:43:19,790 --> 00:43:25,085
Jadi hal ini melepaskan hubungan antara
nomor urut awal

1055
00:43:25,085 --> 00:43:27,611
yang terlihat di setiap koneksi.

1056
00:43:27,611 --> 00:43:28,110
Yah.

1057
00:43:28,110 --> 00:43:31,300
AUDIENS: Apa gunanya untuk 
mengikutsertakan kuncinya?

1058
00:43:31,300 --> 00:43:33,300
PROFESOR: Sebenarnya, jika Anda
tidak mengikutsertakan kuncinya,

1059
00:43:33,300 --> 00:43:35,050
maka saya bisa terkoneksi kepada Anda.

1060
00:43:35,050 --> 00:43:37,487
Saya akan menghitung fungsi yang sama yaitu F.
Saya akan menguranginya.

1061
00:43:37,487 --> 00:43:38,070
Saya akan mengambil ini.

1062
00:43:38,070 --> 00:43:40,170
Saya akan menghitung fungsi F ini
untuk koneksi yang sebenarnya saya

1063
00:43:40,170 --> 00:43:40,910
ingin palsukan.

1064
00:43:40,910 --> 00:43:42,615
Dan saya akan menebak
urutan angka awal yang itu

1065
00:43:42,615 --> 00:43:43,360
akan seperti apa.

1066
00:43:43,360 --> 00:43:46,230
AUDIENS: Jadi bisakah Anda--
karena mesin sekarang jarang

1067
00:43:46,230 --> 00:43:50,630
restart, dapatkah Anda masih
[TIDAK TERDENGAR] dengan membalik--

1068
00:43:50,630 --> 00:43:53,569
PROFESOR: Menurut saya
pada umumnya fungsi F ini

1069
00:43:53,569 --> 00:43:55,610
merupakan sesuatu seperti sebuah
fungsi hash yang aman secara kriptografis,

1070
00:43:55,610 --> 00:44:01,557
yang memiliki properti
yang semi-terbukti bahwa dia

1071
00:44:01,557 --> 00:44:03,140
sulit dibobol. Dia
secara kriptografis

1072
00:44:03,140 --> 00:44:04,480
sulit untuk dibalik.

1073
00:44:04,480 --> 00:44:07,160
Jadi bahkan jika Anda diberikan
input dan output secara literal

1074
00:44:07,160 --> 00:44:14,059
dari fungsi hash ini
kecuali untuk bagian kuncinya ini,

1075
00:44:14,059 --> 00:44:15,517
akan sangat
sulit untuk Anda menebak

1076
00:44:15,517 --> 00:44:17,490
apa kunci ini
secara kriptografis,

1077
00:44:17,490 --> 00:44:19,324
bahkan dalam pengaturan yang terisolasi.

1078
00:44:19,324 --> 00:44:21,740
Jadi semoga ini setidaknya akan
menjadi sesulit dalam konfigurasi ini

1079
00:44:21,740 --> 00:44:24,324
juga.

1080
00:44:24,324 --> 00:44:26,615
Kita akan membahas sedikit lebih lanjut
tentang fungsi-fungsi ini

1081
00:44:26,615 --> 00:44:30,460
F akan dibahas nanti dan bagaimana
Anda menggunakannya dengan benar.

1082
00:44:30,460 --> 00:44:31,650
Masuk akal?

1083
00:44:31,650 --> 00:44:37,140
Ada pertanyaan lain dari
masalah dan solusi ini?

1084
00:44:37,140 --> 00:44:41,252
Baik, jadi sebenarnya,
ini sebagian besar

1085
00:44:41,252 --> 00:44:44,255
semacam contoh dari ini
serangan nomor urut TCP

1086
00:44:44,255 --> 00:44:46,790
yang tidak relevan lagi.

1087
00:44:46,790 --> 00:44:49,440
Karena setiap sistem operasi
pada dasarnya mengimplementasikan rencana ini

1088
00:44:49,440 --> 00:44:50,080
hari-hari ini.

1089
00:44:50,080 --> 00:44:52,425
Jadi sulit untuk menyimpulkan
apa yang akan menjadi

1090
00:44:52,425 --> 00:44:53,577
nomor urut dari seseorang.

1091
00:44:53,577 --> 00:44:55,910
Di sisi lain, orang-orang
terus membuat kesalahan yang sama.

1092
00:44:55,910 --> 00:44:59,755
Jadi bahkan setelah ini
diimplementasikan untuk TCP,

1093
00:44:59,755 --> 00:45:01,490
ada protokol lain
yang disebut

1094
00:45:01,490 --> 00:45:05,830
DNS yang sangat rentan
terhadap serangan yang serupa.

1095
00:45:05,830 --> 00:45:10,060
Dan alasannya adalah bahwa DNS
sebenarnya berjalan diatas UDP.

1096
00:45:10,060 --> 00:45:13,100
Jadi UDP adalah sebuah protokol
stateless yang di mana Anda sebenarnya

1097
00:45:13,100 --> 00:45:16,340
tidak perlu membangun koneksi
apapun di mana

1098
00:45:16,340 --> 00:45:18,140
Anda menukarkan nomor urut.

1099
00:45:18,140 --> 00:45:20,040
Di dalam UDP, Anda hanya
mengirimkan sebuah permintaan

1100
00:45:20,040 --> 00:45:22,140
dari alamat sumber
Anda ke server.

1101
00:45:22,140 --> 00:45:24,950
Dan server akan mencari tahu balasan
apa yang seharunya dan mengirimkan

1102
00:45:24,950 --> 00:45:28,780
kembali ke alamat sumber apapun yang
muncul di dalam paket.

1103
00:45:28,780 --> 00:45:32,850
Jadi itu adalah sebuah
perjalanan satu putaran, sehingga tidak

1104
00:45:32,850 --> 00:45:34,350
ada waktu untuk bertukar
nomor urut

1105
00:45:34,350 --> 00:45:36,349
dan untuk membangun itu,
oh, yah, Anda sebenarnya

1106
00:45:36,349 --> 00:45:38,140
berbicara ke orang yang tepat.

1107
00:45:38,140 --> 00:45:44,330
Jadi dengan DNS, akibatnya,
untuk sementara waktu,

1108
00:45:44,330 --> 00:45:48,840
cukup mudah untuk memalsukan
respon dari server DNS.

1109
00:45:48,840 --> 00:45:51,464
Jadi bagaimana sebuah query pada
umumnya terlihat di dalam DNS?

1110
00:45:51,464 --> 00:45:53,130
Yah, Anda mengirim beberapa
pertanyaan-- jadi misalkan

1111
00:45:53,130 --> 00:45:57,230
sebuah client, mengirim paket dari
client ke sebuah server DNS

1112
00:45:57,230 --> 00:46:00,210
yang mengetahui IP address milik 
server DNS dari sebelumnya,

1113
00:46:00,210 --> 00:46:04,260
mungkin sudah dikonfigurasi sebelumnya,
berkata, yah, inilah pertanyaan saya.

1114
00:46:04,260 --> 00:46:07,336
Mungkin saya mencari mit.edu.

1115
00:46:07,336 --> 00:46:09,860
Dan pada dasarnya itu saja.

1116
00:46:09,860 --> 00:46:12,420
Dan nomor port
milik server tujuan

1117
00:46:12,420 --> 00:46:14,600
selalu 53 untuk DNS.

1118
00:46:14,600 --> 00:46:17,380
Dan client biasanya berjalan 
di atas port number yang sama

1119
00:46:17,380 --> 00:46:20,720
agar penggunaanya mudah atau lainnya.

1120
00:46:20,720 --> 00:46:23,003
Jadi anda mengirim paket ini
dari client dengan port 53.

1121
00:46:23,003 --> 00:46:24,320
ke server pada port ini.

1122
00:46:24,320 --> 00:46:25,200
Inilah query-nya.

1123
00:46:25,200 --> 00:46:30,460
Dan server pada akhirnya
mengirim kembali sebuah balasan yang mengatakan,

1124
00:46:30,460 --> 00:46:38,580
mit.edu memiliki sebuah alamat
IP tertentu, 18.9 titik sesuatu.

1125
00:46:38,580 --> 00:46:41,860
Masalahnya adalah beberapa
penyerang dapat dengan mudah

1126
00:46:41,860 --> 00:46:43,615
mengirim sebuah paket respon serupa
yang berpura-pura

1127
00:46:43,615 --> 00:46:45,408
berasal dari server.

1128
00:46:45,408 --> 00:46:47,366
Dan tidak ada sangat
banyak keteracakan di sini.

1129
00:46:47,366 --> 00:46:50,180
Jadi jika saya tahu bahwa Anda
sedang mencoba untuk terhubung ke mit.edu,

1130
00:46:50,180 --> 00:46:53,126
saya akan hanya mengirimkan paket yang banyak
seperti ini kepada mesin Anda.

1131
00:46:53,126 --> 00:46:55,334
Saya tahu dengan tepat DNS server
apa yang anda akan query.

1132
00:46:55,334 --> 00:46:57,400
Saya tahu dengan tepat 
apa alamat IP Anda.

1133
00:46:57,400 --> 00:46:58,703
Saya tahu nomor port nya.

1134
00:46:58,703 --> 00:47:00,036
Saya tahu apa yang anda query kan.

1135
00:47:00,036 --> 00:47:02,530
Saya bisa sekadar menyediakan
alamat IP milik saya sendiri di sini.

1136
00:47:02,530 --> 00:47:06,310
Dan jika paket saya mencapai
sana setelah Anda mengirim ini

1137
00:47:06,310 --> 00:47:08,630
tapi sebelum Anda mendapatkan
respon sebenarnya,

1138
00:47:08,630 --> 00:47:11,930
mesin klient anda akan
menggunakan paket saya.

1139
00:47:11,930 --> 00:47:14,585
Jadi ini adalah contoh lain
di mana keteracakan yang tidak cukup

1140
00:47:14,585 --> 00:47:17,470
dari protokol ini menyebabkan
sangat mudah untuk memasukkan respon

1141
00:47:17,470 --> 00:47:20,027
atau memasukkan paket secara umum.

1142
00:47:20,027 --> 00:47:21,860
Dan hal ini sebenarnya
dalam beberapa kasus lebih buruk

1143
00:47:21,860 --> 00:47:23,113
daripada serangan sebelumnya.

1144
00:47:23,113 --> 00:47:25,220
Karena di sini Anda bisa
meyakinkan sebuah klien

1145
00:47:25,220 --> 00:47:28,150
untuk terkoneksi ke
alamat IP lainnya.

1146
00:47:28,150 --> 00:47:29,865
Dan dia mungkin akan
memyimpan hasilnya dalam cache,

1147
00:47:29,865 --> 00:47:31,246
karena DNS menyimpan cache.

1148
00:47:31,246 --> 00:47:32,787
Mungkin Anda dapat menyediakan
TTL (Time To Live)

1149
00:47:32,787 --> 00:47:36,550
yang cukup lama pada respon ini
hingga bertahun-tahun.

1150
00:47:36,550 --> 00:47:38,620
Dan maka klien Anda,
sampai reboot berikutnya,

1151
00:47:38,620 --> 00:47:41,740
akan terus menggunakan 
alamat IP ini untuk mit.edu.

1152
00:47:41,740 --> 00:47:42,240
Yah.

1153
00:47:42,240 --> 00:47:44,980
AUDIENS: Apakah Anda bisa memperbaiki ini
dengan kliennya mengikutsertakan

1154
00:47:44,980 --> 00:47:48,130
sebuah nilai acak pada
query, dan server kustomer

1155
00:47:48,130 --> 00:47:48,630
tepatnya?

1156
00:47:48,630 --> 00:47:50,755
PROFESOR: Benar,
yah, jadi ini biasanya yang dilakukan

1157
00:47:50,755 --> 00:47:52,050
orang-orang pada umumnya sekarang.

1158
00:47:52,050 --> 00:47:55,167
Masalahnya, seperti yang 
dibicarakan sebelumnya,

1159
00:47:55,167 --> 00:47:56,250
yaitu kompatibilitas dengan versi sebelumnya.

1160
00:47:56,250 --> 00:47:58,870
Sangat sulit untuk mengubah
perangkat lunak server DNS

1161
00:47:58,870 --> 00:47:59,760
yang dijalankan semua orang.

1162
00:47:59,760 --> 00:48:01,260
Jadi pada dasarnya Anda
harus mengetahui

1163
00:48:01,260 --> 00:48:02,700
di mana anda menyisipkan keacakan?

1164
00:48:02,700 --> 00:48:04,450
Dan orang-orang telah
menemukan dua tempat.

1165
00:48:04,450 --> 00:48:05,860
Tetapi bukan yang terbaik.

1166
00:48:05,860 --> 00:48:08,340
Tetapi pada dasarnya ada
sebuah nomor port asal,

1167
00:48:08,340 --> 00:48:11,050
yang memiliki tingkat keteracakan 16 bit.

1168
00:48:11,050 --> 00:48:13,700
Lalu jika Anda dapat memilih
port asal secara acak,

1169
00:48:13,700 --> 00:48:15,140
maka Anda mendapatkan 16 bit.

1170
00:48:15,140 --> 00:48:19,470
Lalu terdapat juga
sebuah ID query di dalam

1171
00:48:19,470 --> 00:48:22,460
paket, yang
juga 16 bit.

1172
00:48:22,460 --> 00:48:25,030
Dan server juga mengembalikan
ID query yang sama.

1173
00:48:25,030 --> 00:48:27,040
Sehingga menggabungkan kedua
benda ini bersama,

1174
00:48:27,040 --> 00:48:30,570
sebagian besar (DNS) resolver akhir-akhir ini
mendapatkan keacakan 32 bit

1175
00:48:30,570 --> 00:48:31,940
dari protokol ini.

1176
00:48:31,940 --> 00:48:36,620
Dan itu, lagi-lagi, membuatnya terasa
lebih sulit, tetapi tetap saja

1177
00:48:36,620 --> 00:48:40,854
tidak sempurna secara kriptografi,
untuk memalsukan respon seperti ini

1178
00:48:40,854 --> 00:48:44,340
dan membuat itu
diterima oleh klien.

1179
00:48:44,340 --> 00:48:47,450
Tetapi masalah ini
terus datang, sayangnya.

1180
00:48:47,450 --> 00:48:51,990
Sehingga meskipun dia
dipahami dengan baik untuk TCP,

1181
00:48:51,990 --> 00:48:55,200
saya rasa beberapa orang mengatakan
bahwa ini mungkin adalah sebuah masalah.

1182
00:48:55,200 --> 00:48:59,350
Tetapi itu tidak sebenarnya diperbaiki
sampai beberapa tahun lalu.

1183
00:49:01,970 --> 00:49:04,220
Masuk akal?

1184
00:49:04,220 --> 00:49:06,080
Baiklah, jadi saya rasa
sebagai tambahan,

1185
00:49:06,080 --> 00:49:08,910
ada solusi
untuk masalah DNS ini

1186
00:49:08,910 --> 00:49:11,890
juga dengan memperkuat
keamanan untuk DNS

1187
00:49:11,890 --> 00:49:13,270
pada level aplikasi.

1188
00:49:13,270 --> 00:49:16,750
Jadi sehingga daripada mengandalkan pada
properti keteracakan

1189
00:49:16,750 --> 00:49:19,611
dari sejumlah
kecil bit di dalam paket,

1190
00:49:19,611 --> 00:49:23,680
Anda dapat mencoba menggunakan enkripsi
pada protokol DNS.

1191
00:49:23,680 --> 00:49:26,040
Sehingga protokol seperti DNS SEC
yang disebutkan secara singkat pada paper

1192
00:49:26,040 --> 00:49:28,070
membahas tentang mencoba melakukan hal ini.

1193
00:49:28,070 --> 00:49:30,770
Jadi alih-alih mengandalkan
properti keamanan apapun di tingkat

1194
00:49:30,770 --> 00:49:34,590
jaringan, mereka mengharuskan semua
nama DNS memiliki tanda tangan

1195
00:49:34,590 --> 00:49:36,290
yang menyertainya.

1196
00:49:36,290 --> 00:49:37,820
Sepertinya itu rencana yang masuk akal.

1197
00:49:37,820 --> 00:49:39,695
Tetapi ternyata
Mengerjakan detailnya

1198
00:49:39,695 --> 00:49:42,300
sebenarnya cukup
sulit. Jadi salah satu contoh

1199
00:49:42,300 --> 00:49:47,100
masalah yang muncul
adalah nama dan asalnya.

1200
00:49:47,100 --> 00:49:51,130
Karena di DNS, Anda
ingin mendapatkan respon.

1201
00:49:51,130 --> 00:49:52,680
Yah, nama ini memiliki
alamat IP itu.

1202
00:49:52,680 --> 00:49:54,721
Atau Anda dapat mendapatkan respon
mengatakan, tidak, maaf,

1203
00:49:54,721 --> 00:49:56,310
nama ini tidak ada.

1204
00:49:56,310 --> 00:50:00,186
Jadi Anda ingin menandatangani juga
respon tidak ada tersebut.

1205
00:50:00,186 --> 00:50:01,560
Karena kalau tidak,
musuh itu

1206
00:50:01,560 --> 00:50:04,760
dapat mengirim kembali respon
tidak ada dan berpura-pura

1207
00:50:04,760 --> 00:50:07,420
kalau nama tersebut tidak ada,
walaupun sebenarnya ada.

1208
00:50:07,420 --> 00:50:09,930
Jadi bagaimana Anda menandai
respon di mana beberapa nama tertentu

1209
00:50:09,930 --> 00:50:11,951
tidak ada sebelumnya?

1210
00:50:11,951 --> 00:50:13,450
Saya rasa satu kemungkinannya
adalah Anda dapat

1211
00:50:13,450 --> 00:50:17,950
memberikan kunci server DNS Anda
yang menandatangani semua catatan Anda.

1212
00:50:17,950 --> 00:50:19,082
Sepertinya itu rencana yang buruk.

1213
00:50:19,082 --> 00:50:21,248
Karena dengan begitu seseorang
yang mengkompromikan server DNS Anda

1214
00:50:21,248 --> 00:50:22,680
dapat pergi dengan kunci ini.

1215
00:50:22,680 --> 00:50:25,700
Jadi sebagai gantinya, model
DNS SEC beroperasi di atas fakta

1216
00:50:25,700 --> 00:50:29,440
bahwa Anda menandatangani semua nama Anda
di domain Anda sebelumnya,

1217
00:50:29,440 --> 00:50:32,315
dan Anda memberikan data yang sudah ditandatangani
ke server DNS Anda.

1218
00:50:32,315 --> 00:50:34,866
Dan server DNS kemudian bisa
merespon pada setiap pertanyaan.

1219
00:50:34,866 --> 00:50:36,990
Tetapi bahkan jika itu dikompromikan,
tidak banyak hal lain

1220
00:50:36,990 --> 00:50:37,480
yang penyerang itu dapat lakukan.

1221
00:50:37,480 --> 00:50:39,600
Semua hal ini
ditandatangani, dan kuncinya

1222
00:50:39,600 --> 00:50:43,340
tidak ditemukan pada
server DNS itu sendiri.

1223
00:50:43,340 --> 00:50:49,150
Jadi protokol DNS SEC mempunyai
mekanisme cerdas bernama NSEC

1224
00:50:49,150 --> 00:50:52,230
untuk menandatangani catatan yang belum ada.

1225
00:50:52,230 --> 00:50:55,390
Dan cara yang Anda akan lakukan
ini adalah dengan menandatangani celah

1226
00:50:55,390 --> 00:50:56,650
dalam sebuah namespace.

1227
00:50:56,650 --> 00:51:00,490
Jadi sebuah catatan NSEC mungkin
mengatakan, yah, ada

1228
00:51:00,490 --> 00:51:06,550
sebuah nama foo.mit.edu, dan
sebuah nama selanjutnya secara alfabet

1229
00:51:06,550 --> 00:51:10,492
mungkin adalah goo.mit.edu.

1230
00:51:10,492 --> 00:51:13,680
Dan tidak ada apapun secara alfabet
di antara dua nama ini.

1231
00:51:13,680 --> 00:51:16,380
Jadi jika Anda meng-query sebuah
nama di antara dua

1232
00:51:16,380 --> 00:51:17,921
nama-nama ini yang secara alfabet
sudah tersusun, kemudian

1233
00:51:17,921 --> 00:51:20,170
server dapat mengembalikan
isi pesan yang sudah ditandatangani ini,

1234
00:51:20,170 --> 00:51:22,050
oh, tidak ada sesuatu
di antara dua nama ini.

1235
00:51:22,050 --> 00:51:24,460
Anda bisa dengan aman
mengembalikan, itu tidak ada.

1236
00:51:24,460 --> 00:51:26,060
Tetapi kemudian ini
memungkinkan beberapa penyerang

1237
00:51:26,060 --> 00:51:27,768
untuk benar-benar mengenumerasi
nama domain Anda.

1238
00:51:27,768 --> 00:51:31,410
Anda bisa saja menanyakan sebbuah
nama domain dan menemukan catatan ini

1239
00:51:31,410 --> 00:51:32,710
dan berkata, oh, yah, bagus.

1240
00:51:32,710 --> 00:51:34,330
Jadi kedua hal ini ada.

1241
00:51:34,330 --> 00:51:36,520
Biarkan saya bertanya untuk untuk gooa.mit.edu.

1242
00:51:36,520 --> 00:51:38,200
Dia akan memberikan saya sebuah
respon yang berkata,

1243
00:51:38,200 --> 00:51:40,820
apa nama selanjutnya pada
domain Anda, dan lain-lain.

1244
00:51:40,820 --> 00:51:42,290
Jadi sebenarnya
sedikit lebih susah

1245
00:51:42,290 --> 00:51:43,950
untuk membuat
protokol yang benar

1246
00:51:43,950 --> 00:51:46,790
yang menjaga semua
properti yang bagus dari DNS

1247
00:51:46,790 --> 00:51:50,420
dan mencegah pengenumerasian nama
dan masalah lainnya.

1248
00:51:50,420 --> 00:51:52,020
Sebenarnya sekarang
ada hal baik yang

1249
00:51:52,020 --> 00:51:55,950
bernama NSEC3 yang mencoba untuk menyelesaikan
masalah ini sebagian-- setengah

1250
00:51:55,950 --> 00:51:56,875
berjalan, setengah tidak.

1251
00:51:56,875 --> 00:51:59,110
Kita akan melihat, saya rasa, apa
yang membuatnya [TIDAK TERDENGAR].

1252
00:51:59,110 --> 00:51:59,880
Yah.

1253
00:51:59,880 --> 00:52:01,550
AUDIENS: Apakah ada
bentuk tanda

1254
00:52:01,550 --> 00:52:03,915
dari domain level
atas yang tidak ada?

1255
00:52:03,915 --> 00:52:05,540
PROFESOR: Yah, saya
rasa sebenarnya yah.

1256
00:52:05,540 --> 00:52:07,600
Domain dot hanyalah
sebuah domain.

1257
00:52:07,600 --> 00:52:10,250
Dan mereka juga memiliki
mekanisme yang diterapkan juga.

1258
00:52:10,250 --> 00:52:13,120
Jadi sebenarnya dot dan dot
com sekarang mengimplementasi DNS SEC,

1259
00:52:13,120 --> 00:52:15,842
dan ada semua catatan
ini yang mengatakan, yah,

1260
00:52:15,842 --> 00:52:18,540
.in adalah sebuah nama
domain yang ada,

1261
00:52:18,540 --> 00:52:21,915
dan dot sesuatu yang lain ada,
dan tidak ada apapun diantaranya.

1262
00:52:21,915 --> 00:52:23,186
Jadi ada semua hal ini.

1263
00:52:23,186 --> 00:52:25,118
AUDIENS: Jadi selain
penolakan layanan,

1264
00:52:25,118 --> 00:52:27,533
mengapa kita sangat peduli
dengan pengulangan

1265
00:52:27,533 --> 00:52:29,442
nama domain dengan mit.edu?

1266
00:52:29,442 --> 00:52:30,900
PROFESOR: Yah,
mungkin kita tidak.

1267
00:52:30,900 --> 00:52:33,200
Sebenarnya, ada
file teks di AFS

1268
00:52:33,200 --> 00:52:35,210
yang mencantumkan semua
nama domain ini di MIT.

1269
00:52:35,210 --> 00:52:36,930
Tetapi saya rasa secara
umum, beberapa perusahaan

1270
00:52:36,930 --> 00:52:39,530
merasa sedikit tidak nyaman
untuk mengungkapkan ini.

1271
00:52:39,530 --> 00:52:41,735
Mereka biasanya memiliki
nama internal yang

1272
00:52:41,735 --> 00:52:46,245
berada di DNS yang tidak boleh
diketahui pihak luar.

1273
00:52:46,245 --> 00:52:49,730
Saya rasa ini sebenarnya
area abu-abu di mana tidak pernah

1274
00:52:49,730 --> 00:52:51,910
benar-benar diformalkan jaminan
apa yang diberikan oleh DNS

1275
00:52:51,910 --> 00:52:52,774
kepada Anda atau tidak.

1276
00:52:52,774 --> 00:52:54,690
Dan orang-orang mulai
berasumsi hal-hal seperti, yah,

1277
00:52:54,690 --> 00:52:57,390
jika kita mencantumkan sebuah nama, dan itu
tidak benar-benar dipublikasikan di mana pun,

1278
00:52:57,390 --> 00:52:59,760
maka mungkin aman di sini.

1279
00:52:59,760 --> 00:53:02,740
Saya pikir ini adalah tempat lain
di mana sistem ini tidak memiliki

1280
00:53:02,740 --> 00:53:04,740
spesifikasi yang jelas dalam hal
apa yang dimilikinya

1281
00:53:04,740 --> 00:53:05,930
dan tidak perlu disediakannya.

1282
00:53:05,930 --> 00:53:08,224
Dan ketika Anda membuat beberapa
perubahan seperti ini, maka orang-orang

1283
00:53:08,224 --> 00:53:11,214
mengatakan, oh, yah, saya pernah
mengandalkan itu.

1284
00:53:11,214 --> 00:53:12,116
Ya.

1285
00:53:12,116 --> 00:53:13,574
AUDIENCE: [TIDAK TERDENGAR]
serangan replay

1286
00:53:13,574 --> 00:53:16,595
di mana Anda bisa mengirim
dengan percaya diri tanda tangan celah?

1287
00:53:16,595 --> 00:53:17,970
PROFESOR: Yah,
sebenarnya ada

1288
00:53:17,970 --> 00:53:19,053
waktu kedaluwarsa untuk hal-hal ini.

1289
00:53:19,053 --> 00:53:22,480
Jadi jika Anda menandatangani hal ini,
Anda sebenarnya menandatangani dan mengatakan,

1290
00:53:22,480 --> 00:53:25,370
Saya menandatangani bahwa
kumpulan nama ini

1291
00:53:25,370 --> 00:53:27,710
adalah valid untuk, saya
tidak tahu, mungkin satu minggu.

1292
00:53:27,710 --> 00:53:30,790
Dan kemudian kliennya, jika mereka
mempunyai jam yang sinkron,

1293
00:53:30,790 --> 00:53:33,436
mereka bisa menolak
pesan bertanda tangan yang sudah lama.

1294
00:53:33,436 --> 00:53:36,770
Masuk akal?

1295
00:53:36,770 --> 00:53:43,290
Baiklah, jadi hal ini ada pada
serangan tebakan TCP SYN.

1296
00:53:43,290 --> 00:53:47,850
Masalah menarik lainnya yang
juga muncul dalam kasus TCP

1297
00:53:47,850 --> 00:53:50,490
yaitu serangan denial
of service yang

1298
00:53:50,490 --> 00:53:54,160
mengeksploitasi fakta bahwa
server harus menyimpan beberapa keadaan.

1299
00:53:54,160 --> 00:53:57,460
Jadi jika Anda melihat pada
handshake ini yang kita

1300
00:53:57,460 --> 00:54:00,450
punya di papan tulis
sebelumnya, kita akan melihat

1301
00:54:00,450 --> 00:54:04,230
bahwa saat sebuah klien membangun
sebuah koneksi ke server,

1302
00:54:04,230 --> 00:54:08,720
server sebenarnya harus
mengingat nomor-nomor rurut

1303
00:54:08,720 --> 00:54:10,440
SNC.

1304
00:54:10,440 --> 00:54:13,060
Jadi server harus
mempertahankan sebuah struktur data

1305
00:54:13,060 --> 00:54:16,960
pada sisi yang mengatakan,
untuk koneksi ini,

1306
00:54:16,960 --> 00:54:18,850
inilah adalah nomor urut nya.

1307
00:54:18,850 --> 00:54:21,140
Dan dia akan mengatakan, yah,
koneksi saya dari C ke S

1308
00:54:21,140 --> 00:54:23,740
memiliki nomor urut SNC.

1309
00:54:26,250 --> 00:54:28,510
Dan alasan kenapa server
harus menyimpan tabel ini

1310
00:54:28,510 --> 00:54:33,545
adalah karena server
perlu untuk mencari tahu

1311
00:54:33,545 --> 00:54:37,340
nilai SNC apa untuk diterima di sini nantinya.

1312
00:54:37,340 --> 00:54:38,660
Apakah ini masuk akal?

1313
00:54:38,660 --> 00:54:41,562
AUDIENCE: [TIDAK TERDENGAR] SNS?

1314
00:54:41,562 --> 00:54:43,936
PROFESOR: Ya, saya kira
servernya juga membutuhkan SNS, yah.

1315
00:54:48,120 --> 00:54:51,770
Namun ternyata--
yah, Anda benar.

1316
00:54:51,770 --> 00:54:57,445
Dan permasalahannya adalah--
sebenarnya, yah, anda benar.

1317
00:54:57,445 --> 00:54:58,945
SNS sebenarnya
jauh lebih penting.

1318
00:54:58,945 --> 00:55:00,235
Maaf, yah.

1319
00:55:00,235 --> 00:55:02,746
[TIDAK TERDENGAR] SNS itu sebenarnya
jauh lebih penting.

1320
00:55:02,746 --> 00:55:04,371
Karena SNS adalah cara bagaimana
Anda dapat mengetahui bahwa Anda

1321
00:55:04,371 --> 00:55:05,412
sedang berbicara kepada orang yang benar.

1322
00:55:08,790 --> 00:55:12,075
Permasalahannya adalah
tidak ada batasan nyata

1323
00:55:12,075 --> 00:55:13,710
pada ukuran dari tabel ini.

1324
00:55:13,710 --> 00:55:16,317
Jadi Anda mungkin mendapatkan paket
dari mesin lain.

1325
00:55:16,317 --> 00:55:17,650
Anda bahkan tidak tahu siapa yang mengirimnya.

1326
00:55:17,650 --> 00:55:19,983
Anda hanya mendapatkan paket yang
terlihat seperti ini dengan sumber

1327
00:55:19,983 --> 00:55:21,610
alamat yang mengaku sebagai C.

1328
00:55:21,610 --> 00:55:24,730
Dan agar dapat nantinya dapat
menerima koneksi

1329
00:55:24,730 --> 00:55:28,435
dari alamat IP ini, Anda harus
membuat tabel entri ini.

1330
00:55:28,435 --> 00:55:31,012
Dan tabel entri ini
akan bertahan cukup lama.

1331
00:55:31,012 --> 00:55:33,345
Karena mungkin seseorang sedang
terkoneksi kepada Anda

1332
00:55:33,345 --> 00:55:34,346
dari tempat yang sangat jauh.

1333
00:55:34,346 --> 00:55:35,690
Terdapat banyak paket hilang.

1334
00:55:35,690 --> 00:55:40,090
Mungkin tidak akan sampai
1 menit hingga seseorang

1335
00:55:40,090 --> 00:55:42,730
menyelesaikan TCP handshake
di kasus terburuknya.

1336
00:55:42,730 --> 00:55:45,710
Jadi Anda harus menyimpan
keadaan ini dalam TCP stack

1337
00:55:45,710 --> 00:55:47,980
dalam jangka waktu yang lama.

1338
00:55:47,980 --> 00:55:50,230
Dan tidak bisa cara untuk
menebak apakah ini

1339
00:55:50,230 --> 00:55:52,640
ini adalah koneksi yang valid atau tidak.

1340
00:55:52,640 --> 00:55:55,710
Jadi satu serangan denial
of service yang ditemukan orang 

1341
00:55:55,710 --> 00:55:58,690
terhadap sebagian besar TCP stack
adalah dengan hanya mengirim

1342
00:55:58,690 --> 00:56:01,670
banyak paket seperti ini.

1343
00:56:01,670 --> 00:56:04,980
Jadi jika saya adalah penyerang, maka saya 
hanya perlu mengirim banyak paket SYN

1344
00:56:04,980 --> 00:56:08,930
ke server tertentu dan
dapat mengisi tabel hingga penuh.

1345
00:56:08,930 --> 00:56:12,810
Masalahnya adalah ketika 
dalam kasus terbaik,

1346
00:56:12,810 --> 00:56:15,410
mungkin penyerang hanya perlu selalu 
menggunakan alamat IP sumber

1347
00:56:15,410 --> 00:56:16,720
yang sama.

1348
00:56:16,720 --> 00:56:18,800
Dalam kasus tersebut, Anda 
dapat cukup berkata, yah,

1349
00:56:18,800 --> 00:56:21,710
setiap komputer client diizinkan
2 entri pada tabel,

1350
00:56:21,710 --> 00:56:23,340
atau seperti itu.

1351
00:56:23,340 --> 00:56:25,870
Lalu penyerang dapat menggunakan 
hingga 2 entri tabel tetapi

1352
00:56:25,870 --> 00:56:26,745
tidak lebih.

1353
00:56:26,745 --> 00:56:28,667
Masalahnya, tentu saja,
adalah penyerang

1354
00:56:28,667 --> 00:56:30,125
dan memalsukan alamat IP 
milik client,

1355
00:56:30,125 --> 00:56:31,832
untuk membuatnya terlihat seperti acak.

1356
00:56:31,832 --> 00:56:33,290
Dan kemudian untuk
servernya, akan

1357
00:56:33,290 --> 00:56:34,885
menjadi sangat sulit
untuk membedakan apakah ini

1358
00:56:34,885 --> 00:56:37,385
adalah penyerang yang berusaha
tersambung dengan kita atau seorang klien

1359
00:56:37,385 --> 00:56:38,510
yang saya belum pernah dengar sebelumnya.

1360
00:56:38,510 --> 00:56:41,320
Sehingga jika Anda adalah situs web yang
seharusnya menerima koneksi

1361
00:56:41,320 --> 00:56:44,275
dari mana pun di dunia, hal ini
akan menjadi masalah besar.

1362
00:56:44,275 --> 00:56:46,870
Karena antara Anda menolak
akses kepada semua orang,

1363
00:56:46,870 --> 00:56:51,080
atau Anda memiliki tempat penyimpanan
status untuk hampir semua koneksi

1364
00:56:51,080 --> 00:56:52,716
palsu yang mencoba.

1365
00:56:52,716 --> 00:56:55,020
Apakah itu masuk akal?

1366
00:56:55,020 --> 00:56:57,480
Jadi ini adalah sedikit
masalah untuk TCP, dan faktanya

1367
00:56:57,480 --> 00:57:01,990
untuk hampir semua protokol yang
mengizinkan beberapa inisiasi

1368
00:57:01,990 --> 00:57:04,970
koneksi, dan server
harus menyimpan status.

1369
00:57:04,970 --> 00:57:05,890
Jadi ada beberapa perbaikan.

1370
00:57:05,890 --> 00:57:07,490
Kita akan membahasnya
sebentar lagi apa

1371
00:57:07,490 --> 00:57:10,285
solusi yang diimplementasikan TCP untuk
mencoba mengatasi masalah ini.

1372
00:57:10,285 --> 00:57:13,788
Ini disebut SYN
flooding pada TCP.

1373
00:57:13,788 --> 00:57:15,162
Tetapi secara umum,
ini adalah sebuah masalah

1374
00:57:15,162 --> 00:57:17,030
yang pantas diketahui
dan coba

1375
00:57:17,030 --> 00:57:19,975
untuk dihindari di protokol apa pun
yang Anda rancang yang berjalan di atasnya.

1376
00:57:19,975 --> 00:57:22,120
Jadi Anda ingin memastikan
bahwa server tidak

1377
00:57:22,120 --> 00:57:24,830
harus menyimpan keadaan
sampai benar-benar bisa bisa

1378
00:57:24,830 --> 00:57:27,204
mengotentikasi dan mengidentifikasi,
siapakah kliennya?

1379
00:57:27,204 --> 00:57:29,745
Karena pada saat itu, jika Anda
sudah mengidentifikasi siapa itu kliennya,

1380
00:57:29,745 --> 00:57:31,340
Anda sudah mengotentikasi
mereka entah bagaimana,

1381
00:57:31,340 --> 00:57:32,290
lalu Anda bisa benar-benar
membuat sebuah keputusan,

1382
00:57:32,290 --> 00:57:34,515
yah, setiap klien hanya
diperbolehkan untuk terhubung

1383
00:57:34,515 --> 00:57:35,920
sekali, atau sesuatu.

1384
00:57:35,920 --> 00:57:37,780
Dan kemudian saya tidak akan
menyimpan lebih banyak status.

1385
00:57:37,780 --> 00:57:40,240
Di sini, masalahnya adalah
Anda menjamin

1386
00:57:40,240 --> 00:57:42,938
bahwa Anda menyimpan status
sebelum Anda tahu siapa

1387
00:57:42,938 --> 00:57:44,146
yang terhubung dengan Anda.

1388
00:57:46,670 --> 00:57:48,330
Jadi mari lihat
bagaimana Anda dapat

1389
00:57:48,330 --> 00:57:53,070
mengatasi serangan SYN flooding ini
di mana server mengakumulasi

1390
00:57:53,070 --> 00:57:54,850
banyak keadaan.

1391
00:57:54,850 --> 00:57:57,530
Jadi tentu saja, jika Anda
dapat mengubah TCP lagi,

1392
00:57:57,530 --> 00:58:00,810
Anda dapat memperbaikinya dengan sangat
mudah dengan menggunakan kriptografi

1393
00:58:00,810 --> 00:58:04,490
atau sesuatu atau mengubah dengan tepat
siapa yang bertanggung jawab untuk menyimpan

1394
00:58:04,490 --> 00:58:05,130
keadaan tertentu.

1395
00:58:05,130 --> 00:58:07,100
Masalahnya adalah kita
memiliki TCP apa adanya.

1396
00:58:07,100 --> 00:58:11,310
Dan bisakah kita memperbaiki masalah
tanpa mengubah protokol

1397
00:58:11,310 --> 00:58:12,860
TCP?

1398
00:58:12,860 --> 00:58:15,657
Jadi ini, sekali lagi, latihan untuk
mencoba mencari tahu, yah,

1399
00:58:15,657 --> 00:58:17,930
trik apa yang sebenarnya
bisa kita gunakan

1400
00:58:17,930 --> 00:58:21,470
atau lebih tepatnya asumsi apa
yang bisa kita perlunak dan tetap

1401
00:58:21,470 --> 00:58:24,715
tetap mengikuti format header
TCP dan hal-hal lainnya.

1402
00:58:24,715 --> 00:58:28,900
Dan triknya adalah sebenarnya untuk
menemukan cara yang cerdas

1403
00:58:28,900 --> 00:58:31,500
untuk membuat server
tidak menyimpan keadaan tanpa harus

1404
00:58:31,500 --> 00:58:33,842
membuatnya-- sehingga server tidak
perlu menyimpan

1405
00:58:33,842 --> 00:58:36,424
tabel ini di memori.

1406
00:58:36,424 --> 00:58:37,840
Dan cara kita
melakukannya adalah

1407
00:58:37,840 --> 00:58:42,140
dengan memilih SMS dengan hati-hati.

1408
00:58:42,140 --> 00:58:44,840
Alih-alih menggunakan formula ini
yang kita lihat sebelumnya, di mana

1409
00:58:44,840 --> 00:58:47,650
kita harus menambahkan
fungsi ini, kita

1410
00:58:47,650 --> 00:58:51,170
akan memilih
urutan angka

1411
00:58:51,170 --> 00:58:52,710
ini dalam cara yang lain.

1412
00:58:52,710 --> 00:58:55,094
Dan saya akan memberikan Anda
persis rumusnya.

1413
00:58:55,094 --> 00:58:57,510
Dan kita akan membahas mengapa
hal ini menarik

1414
00:58:57,510 --> 00:58:59,530
dan properti bagus apa yang dimilikinya.

1415
00:58:59,530 --> 00:59:02,192
Jadi apabila server mendeteksi dirinya berada
di bawah serangan semacam ini,

1416
00:59:02,192 --> 00:59:03,650
dia akan beralih
ke dalam mode ini

1417
00:59:03,650 --> 00:59:12,510
di mana hal tersebut akan memilih SNS menggunakan
rumus ini penerapan yang menerapkan

1418
00:59:12,510 --> 00:59:14,900
pada dasarnya sama atau
serupa dengan fungsi F

1419
00:59:14,900 --> 00:59:15,490
yang kita lihat sebelumnya.

1420
00:59:18,470 --> 00:59:20,100
Dan apa yang akan diterapkan
olehnya adalah

1421
00:59:20,100 --> 00:59:25,652
IP sumber, IP tujuan
IP, hal yang sama seperti sebelumnya,

1422
00:59:25,652 --> 00:59:35,920
port sumber, port tujuan,
dan juga penanda waktu,

1423
00:59:35,920 --> 00:59:39,420
dan juga sebuah kunci di dalam sini.

1424
00:59:39,420 --> 00:59:45,374
Dan kita akan menggabungkannya
dengan penanda waktu juga.

1425
00:59:45,374 --> 00:59:47,665
Jadi penanda waktu ini akan
menjadi cukup kasar.

1426
00:59:47,665 --> 00:59:49,206
Hal tersebut akan berada pada
orde menit.

1427
00:59:49,206 --> 00:59:52,290
Jadi setiap menit,
penanda waktu ditandai satu persatu.

1428
00:59:52,290 --> 00:59:54,560
Ini waktu yang sangat kasar.

1429
00:59:54,560 --> 00:59:59,920
Dan di sana mungkin ada beberapa pemisahan
di antara bagian dari header ini

1430
00:59:59,920 --> 01:00:01,270
dan bagian dari header ini.

1431
01:00:01,270 --> 01:00:03,270
Penanda waktu ini
membutuhkan banyak bit.

1432
01:00:03,270 --> 01:00:07,000
Jadi saya lupa secara tepat apa yang
protokol ini lakukan dalam mesin sebenarnya.

1433
01:00:07,000 --> 01:00:09,730
Tapi Anda dapat dengan mudah
membayangkan mungkin dengan menggunakan 8 bit.

1434
01:00:09,730 --> 01:00:11,158
Untuk timestamp-nya,
saya akan

1435
01:00:11,158 --> 01:00:15,920
menggunakan 24 bit untuk bagian ini
dari nomor urut.

1436
01:00:15,920 --> 01:00:18,830
Baiklah, jadi mengapa
ini merupakan rencana yang baik?

1437
01:00:18,830 --> 01:00:19,850
Apa yang terjadi di sini?

1438
01:00:19,850 --> 01:00:21,990
Mengapa rumus aneh ini?

1439
01:00:21,990 --> 01:00:24,210
Jadi saya pikir Anda harus
mengingat, satu properti

1440
01:00:24,210 --> 01:00:26,920
yang kita coba untuk capai
pada nomor urut.

1441
01:00:26,920 --> 01:00:28,580
Jadi ada dua hal yang terjadi.

1442
01:00:28,580 --> 01:00:31,844
Satu adalah adanya pertahanan ini
terhadap paket yang terduplikat

1443
01:00:31,844 --> 01:00:35,041
yang kita coba untuk capai
dengan-- mungkin rumusnya masih

1444
01:00:35,041 --> 01:00:35,541
di sini.

1445
01:00:35,541 --> 01:00:37,030
Tidak-- oh, ya, ya, di sini.

1446
01:00:37,030 --> 01:00:39,210
Baik, jadi hanya untuk 
membandingkan beberapa hal ini-- jadi

1447
01:00:39,210 --> 01:00:42,100
saat kita sedang tidak dalam
serangan, kita sebelumnya

1448
01:00:42,100 --> 01:00:45,148
mempertahankan skema
nomor urut gaya lama ini

1449
01:00:45,148 --> 01:00:47,606
untuk mencegah paket duplikat
dari koneksi-koneksi sebelumnya, seluruh

1450
01:00:47,606 --> 01:00:49,495
hal baik ini.

1451
01:00:49,495 --> 01:00:51,120
Ternyata orang-orang
tidak bisa mencari tahu

1452
01:00:51,120 --> 01:00:53,800
sebuah cara untuk bertahan melawan
serangan SYN flooding jenis ini

1453
01:00:53,800 --> 01:00:55,990
tanpa mengorbankan
properti ini,

1454
01:00:55,990 --> 01:00:57,370
jadi pada dasarnya
berkata, yah, inilah

1455
01:00:57,370 --> 01:00:59,670
satu rencana yang mungkin bisa berhasil
dalam kasus tertentu.

1456
01:00:59,670 --> 01:01:02,330
Ini adalah sebuah rencana di mana
kita tidak perlu memikirkan tentang

1457
01:01:02,330 --> 01:01:03,760
komponen ISN lama itu.

1458
01:01:03,760 --> 01:01:06,890
Dah alih-alih, kita
fokus untuk sekadar memastikan

1459
01:01:06,890 --> 01:01:12,305
jika terdapat 
nomor urut S dalam respon

1460
01:01:12,305 --> 01:01:15,900
ke sebuah paket, seperti di sini,
maka kita tahu itu

1461
01:01:15,900 --> 01:01:18,150
pasti klien yang benar.

1462
01:01:18,150 --> 01:01:22,434
Maka ingatlah bahwa untuk
mencegah serangan IP spoofing,

1463
01:01:22,434 --> 01:01:23,850
kita bergantung
pada nilai SNS ini.

1464
01:01:23,850 --> 01:01:28,310
Maka jika server mengirim
nilai SNS ini,

1465
01:01:28,310 --> 01:01:30,800
kita berharap hanya klien yang dapat 
mengirim nilai SNS yang benar kembali ke

1466
01:01:30,800 --> 01:01:32,985
kita, dan selesai membangun
koneksinya.

1467
01:01:32,985 --> 01:01:36,220
Dan ini adalah alasan mengapa Anda harus menyimpannya
di dalam tabel sebelah sini.

1468
01:01:36,220 --> 01:01:37,730
Karena jika tidak,
bagaimana Anda tahu

1469
01:01:37,730 --> 01:01:40,610
bahwa ini adalah respon 
asli atau palsu?

1470
01:01:40,610 --> 01:01:42,660
Dan alasan mengapa memakai 
fungsi F di sini

1471
01:01:42,660 --> 01:01:47,670
adalah bahwa kita mungkin tidak dapat
menyimpan tabel ini di memori.

1472
01:01:47,670 --> 01:01:51,760
Dan alih-alih, ketika percobaan koneksi
sampai di sini,

1473
01:01:51,760 --> 01:01:53,480
kita akan menghitung SNS
sesuai dengan

1474
01:01:53,480 --> 01:01:55,440
rumus di sini
dan cukup

1475
01:01:55,440 --> 01:01:58,058
mengirimnya kembali ke klien manapun 
yang berpura-pura terkoneksi

1476
01:01:58,058 --> 01:01:59,250
kepada kita.

1477
01:01:59,250 --> 01:02:01,960
And then we'll forget all
about this connection.

1478
01:02:01,960 --> 01:02:05,040
And then if this third packet
eventually comes through,

1479
01:02:05,040 --> 01:02:09,230
and its SNS value here matches
what we would expect to see,

1480
01:02:09,230 --> 01:02:11,040
then we'll say, oh
yeah, this must've

1481
01:02:11,040 --> 01:02:13,310
been someone got our
response from step two

1482
01:02:13,310 --> 01:02:15,745
and finally sent it back to us.

1483
01:02:15,745 --> 01:02:17,495
And now we finally
commit after step three

1484
01:02:17,495 --> 01:02:21,846
to storing a real entry for
this TCP connection in memory.

1485
01:02:21,846 --> 01:02:25,350
So this is a way to sort of
defer the storage of this state

1486
01:02:25,350 --> 01:02:28,820
at the server by requiring
the server, the client,

1487
01:02:28,820 --> 01:02:30,420
to echo back this exact value.

1488
01:02:30,420 --> 01:02:32,716
And by constructing it
in this careful way,

1489
01:02:32,716 --> 01:02:34,590
we can actually check
whether the client just

1490
01:02:34,590 --> 01:02:38,598
made up this value, or if it's
the real thing we're expecting.

1491
01:02:38,598 --> 01:02:40,486
Does that make sense?

1492
01:02:40,486 --> 01:02:43,320
AUDIENCE: [INAUDIBLE]
SNC [INAUDIBLE]?

1493
01:02:43,320 --> 01:02:46,620
PROFESSOR: Yeah, so SNC now,
we basically don't store it.

1494
01:02:46,620 --> 01:02:48,570
It's maybe not great.

1495
01:02:48,570 --> 01:02:52,134
But so it is.

1496
01:02:52,134 --> 01:02:54,470
So in fact, I guess
what really happens

1497
01:02:54,470 --> 01:02:59,650
is in-- I didn't show it here.

1498
01:02:59,650 --> 01:03:05,435
But there's probably going to be
sort of a null data field here

1499
01:03:05,435 --> 01:03:07,560
that says this
packet has no data.

1500
01:03:07,560 --> 01:03:10,680
But it still includes the
sequence number SNC just

1501
01:03:10,680 --> 01:03:12,790
because there's a field for it.

1502
01:03:12,790 --> 01:03:14,554
So this is how the
server can reconstruct

1503
01:03:14,554 --> 01:03:15,857
what this SNC value is.

1504
01:03:15,857 --> 01:03:18,190
Because the client is going
to include it in this packet

1505
01:03:18,190 --> 01:03:18,727
anyway.

1506
01:03:18,727 --> 01:03:19,810
It wasn't relevant before.

1507
01:03:19,810 --> 01:03:22,050
But it sort of is relevant now.

1508
01:03:22,050 --> 01:03:24,820
And we weren't going to
check it against anything.

1509
01:03:24,820 --> 01:03:28,210
But it turns out to be
pretty much good enough.

1510
01:03:28,210 --> 01:03:29,770
It has some unfortunate
consequences.

1511
01:03:29,770 --> 01:03:33,785
Like if this is-- well,
there's some complicated things

1512
01:03:33,785 --> 01:03:35,100
you might abuse here.

1513
01:03:35,100 --> 01:03:37,330
But it doesn't seem
to be that bad.

1514
01:03:37,330 --> 01:03:39,370
It seems certainly
better than the server

1515
01:03:39,370 --> 01:03:41,495
filling up its memory and
swapping serving requests

1516
01:03:41,495 --> 01:03:43,370
all together.

1517
01:03:43,370 --> 01:03:45,630
And then we don't include
in this computation.

1518
01:03:45,630 --> 01:03:48,110
Because the only thing
we care about here

1519
01:03:48,110 --> 01:03:50,099
is offloaded the
storage of this table

1520
01:03:50,099 --> 01:03:52,640
and making sure that the only
connections that eventually you

1521
01:03:52,640 --> 01:03:56,075
do get established are
legitimate clients.

1522
01:03:56,075 --> 01:03:58,110
Because therefore,
we can say, well,

1523
01:03:58,110 --> 01:04:00,990
if this client is establishing
a million connections to me,

1524
01:04:00,990 --> 01:04:02,698
I'll stop accepting
connections from him.

1525
01:04:02,698 --> 01:04:04,150
That's easy enough, finally.

1526
01:04:04,150 --> 01:04:06,710
The problem is that all
these source addresses,

1527
01:04:06,710 --> 01:04:09,180
if they're spoofed,
are hard to distinguish

1528
01:04:09,180 --> 01:04:11,630
from legitimate clients.

1529
01:04:11,630 --> 01:04:12,580
Make sense?

1530
01:04:12,580 --> 01:04:13,530
Yeah.

1531
01:04:13,530 --> 01:04:15,612
AUDIENCE: Would you need
to store the timestamp?

1532
01:04:15,612 --> 01:04:17,570
PROFESSOR: Ahh, so the
clever thing, the reason

1533
01:04:17,570 --> 01:04:20,280
this timestamp is sort
of on the slide here,

1534
01:04:20,280 --> 01:04:23,920
is that when we receive this
SNS value in step three,

1535
01:04:23,920 --> 01:04:26,190
we need to figure
out, how do you

1536
01:04:26,190 --> 01:04:27,690
compute the input
to this function F

1537
01:04:27,690 --> 01:04:28,951
to check whether it's correct?

1538
01:04:28,951 --> 01:04:30,367
So actually, we
take the timestamp

1539
01:04:30,367 --> 01:04:33,510
from the end of the packet,
and we use that inside

1540
01:04:33,510 --> 01:04:35,512
of this computation.

1541
01:04:35,512 --> 01:04:36,970
Everything else we
can reconstruct.

1542
01:04:36,970 --> 01:04:39,330
We know who just sent us
the third step and packet.

1543
01:04:39,330 --> 01:04:41,230
And we have all these fields.

1544
01:04:41,230 --> 01:04:43,542
And we have our key, which
is, again, still secret.

1545
01:04:43,542 --> 01:04:46,000
And this timestamp just comes
from the end of the sequence,

1546
01:04:46,000 --> 01:04:47,810
from the last 8 bits.

1547
01:04:47,810 --> 01:04:51,040
And then it might
be that we'll reject

1548
01:04:51,040 --> 01:04:55,780
timestamps that are too old,
just disallow old connections.

1549
01:04:55,780 --> 01:04:56,280
Yeah.

1550
01:04:56,280 --> 01:04:57,492
AUDIENCE: So I'm guessing
the reason you only

1551
01:04:57,492 --> 01:04:58,867
use this when
you're under attack

1552
01:04:58,867 --> 01:05:01,160
is because you lose 8 bits
of security, or whatever?

1553
01:05:01,160 --> 01:05:02,630
PROFESSOR: Yes, it's not great.

1554
01:05:02,630 --> 01:05:04,120
It has many bad properties.

1555
01:05:04,120 --> 01:05:07,668
One is you sort of lose 8 bits
of security in some sense.

1556
01:05:07,668 --> 01:05:09,880
Because now the
unguessable part is just

1557
01:05:09,880 --> 01:05:13,250
24 bits instead of 32 bits.

1558
01:05:13,250 --> 01:05:18,750
Another problem is what happens
if you lose certain packets?

1559
01:05:18,750 --> 01:05:26,163
So if this packet is lost--
so it's typically, in TCP,

1560
01:05:26,163 --> 01:05:28,580
there's someone responsible
for retransmitting something

1561
01:05:28,580 --> 01:05:30,540
if a particular packet is lost.

1562
01:05:30,540 --> 01:05:33,870
And in TCP, if the
third packet is lost,

1563
01:05:33,870 --> 01:05:36,490
then the client might not
be waiting for anything.

1564
01:05:36,490 --> 01:05:39,040
Or sorry, maybe
the protocol we're

1565
01:05:39,040 --> 01:05:40,850
running on top of
this TCP connection

1566
01:05:40,850 --> 01:05:42,308
is one where the
server is supposed

1567
01:05:42,308 --> 01:05:43,900
to say something initially.

1568
01:05:43,900 --> 01:05:45,290
So I connect.

1569
01:05:45,290 --> 01:05:46,470
I just listen.

1570
01:05:46,470 --> 01:05:48,869
And in the SMTP, for
example, the server

1571
01:05:48,869 --> 01:05:51,160
is supposed to send me some
sort of an initial greeting

1572
01:05:51,160 --> 01:05:53,370
in the protocol.

1573
01:05:53,370 --> 01:05:55,446
So OK, suppose I'm
connecting to an SMTP server.

1574
01:05:55,446 --> 01:05:57,160
I send my third packet.

1575
01:05:57,160 --> 01:05:58,120
I think I'm done.

1576
01:05:58,120 --> 01:06:00,795
I'm just waiting for
the server to tell me,

1577
01:06:00,795 --> 01:06:02,190
greetings as an SMTP server.

1578
01:06:02,190 --> 01:06:04,316
Please send mail.

1579
01:06:04,316 --> 01:06:05,440
This packet could get lost.

1580
01:06:05,440 --> 01:06:08,340
And in real TCP, the
way this gets handled

1581
01:06:08,340 --> 01:06:12,540
is that the server from step
two remembers that, hey, I

1582
01:06:12,540 --> 01:06:13,860
sent this response.

1583
01:06:13,860 --> 01:06:15,867
I never heard back,
this third thing.

1584
01:06:15,867 --> 01:06:17,283
So it's the server
that's supposed

1585
01:06:17,283 --> 01:06:19,829
to resend this packet
to trigger the client

1586
01:06:19,829 --> 01:06:22,489
to resend this third packet.

1587
01:06:22,489 --> 01:06:24,530
Of course, if the server
isn't storing any state,

1588
01:06:24,530 --> 01:06:26,660
it has no idea what to resend.

1589
01:06:26,660 --> 01:06:28,720
So this actually makes
connection establishment

1590
01:06:28,720 --> 01:06:31,669
potentially
programmatic where you

1591
01:06:31,669 --> 01:06:33,710
could enter this weird
state where both sides are

1592
01:06:33,710 --> 01:06:34,714
waiting for each other.

1593
01:06:34,714 --> 01:06:36,130
Well, the server
doesn't even know

1594
01:06:36,130 --> 01:06:37,421
that it's waiting for anything.

1595
01:06:37,421 --> 01:06:39,180
And the client is
waiting for the server.

1596
01:06:39,180 --> 01:06:41,138
And the server basically
dropped responsibility

1597
01:06:41,138 --> 01:06:42,250
by not storing state.

1598
01:06:42,250 --> 01:06:44,512
So this is another
reason why you

1599
01:06:44,512 --> 01:06:46,470
don't run this in production
mode all the time.

1600
01:06:46,470 --> 01:06:47,216
Yeah.

1601
01:06:47,216 --> 01:06:49,950
AUDIENCE: Presumably also you
could have data commissions

1602
01:06:49,950 --> 01:06:53,530
if you establish two very
short-lived connections right

1603
01:06:53,530 --> 01:06:55,600
after each other
from the same host.

1604
01:06:55,600 --> 01:06:56,105
PROFESSOR: Absolutely,
yeah, yeah.

1605
01:06:56,105 --> 01:06:58,370
So another thing is, of
course, because we gave up

1606
01:06:58,370 --> 01:07:01,340
on using this ISN
old style part,

1607
01:07:01,340 --> 01:07:03,080
we now give up
protection against

1608
01:07:03,080 --> 01:07:05,400
these multiple connections
in a short time period being

1609
01:07:05,400 --> 01:07:07,400
independent from one another.

1610
01:07:07,400 --> 01:07:09,322
So I think there's a
number of trade-offs.

1611
01:07:09,322 --> 01:07:10,770
We just talked about three.

1612
01:07:10,770 --> 01:07:12,830
There's several more
things you worry about.

1613
01:07:12,830 --> 01:07:15,790
But it's not great.

1614
01:07:15,790 --> 01:07:18,150
If we could design a protocol
from scratch to be better,

1615
01:07:18,150 --> 01:07:21,390
we could just have a separate
nice 64-bit header for this

1616
01:07:21,390 --> 01:07:23,001
and a 64-bit value for this.

1617
01:07:23,001 --> 01:07:24,750
And then we could
enable this all the time

1618
01:07:24,750 --> 01:07:26,458
without giving up the
other stuff and all

1619
01:07:26,458 --> 01:07:28,148
these nice things.

1620
01:07:28,148 --> 01:07:28,648
Yeah.

1621
01:07:28,648 --> 01:07:31,133
AUDIENCE: I just had one
quick question on the SNS.

1622
01:07:31,133 --> 01:07:36,432
In step two, [INAUDIBLE],
do they have to be the same?

1623
01:07:36,432 --> 01:07:37,821
PROFESSOR: This
SNS and this SNS?

1624
01:07:37,821 --> 01:07:38,750
AUDIENCE: Mhm.

1625
01:07:38,750 --> 01:07:41,400
PROFESSOR: Yeah,
because otherwise,

1626
01:07:41,400 --> 01:07:45,685
the server has no way to
conclude that this client got

1627
01:07:45,685 --> 01:07:47,330
our packet.

1628
01:07:47,330 --> 01:07:51,020
If the server didn't check that
this SNS was the same value as

1629
01:07:51,020 --> 01:07:54,197
before, then these actually
would be even worse.

1630
01:07:54,197 --> 01:07:56,405
Because I could fake a
connection from some arbitrary

1631
01:07:56,405 --> 01:07:58,810
IP address, then
get this response.

1632
01:07:58,810 --> 01:08:00,362
Maybe I don't even
get it, because it

1633
01:08:00,362 --> 01:08:01,320
goes to a different IP.

1634
01:08:01,320 --> 01:08:04,114
Then I establish a connection
from some other IP address.

1635
01:08:04,114 --> 01:08:05,530
And then the server
is maintaining

1636
01:08:05,530 --> 01:08:06,812
a whole live connection.

1637
01:08:06,812 --> 01:08:09,020
Probably a server crosses
another side waiting for me

1638
01:08:09,020 --> 01:08:10,800
to send data and so on.

1639
01:08:10,800 --> 01:08:13,660
AUDIENCE: But the timestamp is
going to be different, right?

1640
01:08:13,660 --> 01:08:15,288
So how can the
server recalculate

1641
01:08:15,288 --> 01:08:17,708
that with a new timestamp
and null the one before

1642
01:08:17,708 --> 01:08:19,443
if it doesn't store any state?

1643
01:08:19,443 --> 01:08:21,859
PROFESSOR: So the way this
works is these timestamps, as I

1644
01:08:21,859 --> 01:08:23,150
was saying, are course grained.

1645
01:08:23,150 --> 01:08:24,899
So they're on a
scale of minutes.

1646
01:08:24,899 --> 01:08:26,631
So if you connect
within the same minute,

1647
01:08:26,631 --> 01:08:30,540
then you're in good shape.

1648
01:08:30,540 --> 01:08:33,820
And if you connect on the
minute boundary, well, too bad.

1649
01:08:33,820 --> 01:08:35,569
Yet another problem
with the scheme-- it's

1650
01:08:35,569 --> 01:08:37,155
imperfect in many ways.

1651
01:08:37,155 --> 01:08:39,180
But most operating
systems, including Linux,

1652
01:08:39,180 --> 01:08:42,440
actually have ways of detecting
if there's too many entries

1653
01:08:42,440 --> 01:08:44,689
building up in this table
that aren't being completed.

1654
01:08:44,689 --> 01:08:46,750
It switches to this
other scheme instead

1655
01:08:46,750 --> 01:08:48,590
to make sure it doesn't
overflow this table.

1656
01:08:48,590 --> 01:08:49,071
Yeah.

1657
01:08:49,071 --> 01:08:50,737
AUDIENCE: So if the
attacker has control

1658
01:08:50,737 --> 01:08:53,400
of a lot of IP addresses,
and they do this,

1659
01:08:53,400 --> 01:08:55,324
and even if you
switch it the same--

1660
01:08:55,324 --> 01:08:57,032
PROFESSOR: Yeah, so
then actually there's

1661
01:08:57,032 --> 01:08:58,644
not much you can do.

1662
01:08:58,644 --> 01:09:00,060
The reason that
we were so worried

1663
01:09:00,060 --> 01:09:01,560
about this scheme
in the first place

1664
01:09:01,560 --> 01:09:04,485
is because we wanted to
filter out or somehow

1665
01:09:04,485 --> 01:09:06,828
distinguish between the
attacker and the good guys.

1666
01:09:06,828 --> 01:09:09,290
And if the attacker
has more IP addresses

1667
01:09:09,290 --> 01:09:11,420
and just controls more
machines than the good guys,

1668
01:09:11,420 --> 01:09:14,003
then he can just connect to our
server and request lots of web

1669
01:09:14,003 --> 01:09:16,210
pages or maintain connections.

1670
01:09:16,210 --> 01:09:18,100
And it's very hard
then for the server

1671
01:09:18,100 --> 01:09:21,060
to distinguish whether these
are legitimate clients or just

1672
01:09:21,060 --> 01:09:23,350
the attacker tying up
resources of the server.

1673
01:09:23,350 --> 01:09:24,880
So you're absolutely right.

1674
01:09:24,880 --> 01:09:27,170
This only addresses the
case where the attacker

1675
01:09:27,170 --> 01:09:29,060
has a small number
of IP addresses

1676
01:09:29,060 --> 01:09:32,130
and wants to amplify his effect.

1677
01:09:32,130 --> 01:09:34,109
But it is a worry.

1678
01:09:34,109 --> 01:09:38,819
And in fact, today it might
be that some attackers control

1679
01:09:38,819 --> 01:09:40,488
a large number of
compromised machines,

1680
01:09:40,488 --> 01:09:42,529
like just desktop machines
of someone that didn't

1681
01:09:42,529 --> 01:09:44,331
patch their machine correctly.

1682
01:09:44,331 --> 01:09:46,580
And then they can just mount
denial of service attacks

1683
01:09:46,580 --> 01:09:48,960
from this distributed set of
machines all over the world.

1684
01:09:48,960 --> 01:09:53,680
And that's pretty hard
to defend against.

1685
01:09:53,680 --> 01:09:56,030
So another actually interesting
thing I want to mention

1686
01:09:56,030 --> 01:10:02,200
is denial of service attacks,
but in the particular way

1687
01:10:02,200 --> 01:10:05,049
that other protocols
make them worse.

1688
01:10:05,049 --> 01:10:07,340
I guess other protocols allow
denial of service attacks

1689
01:10:07,340 --> 01:10:08,131
in the first place.

1690
01:10:08,131 --> 01:10:08,692
I'm sorry.

1691
01:10:08,692 --> 01:10:11,150
But there are some that are
protocols that are particularly

1692
01:10:11,150 --> 01:10:13,370
susceptible to abuse.

1693
01:10:13,370 --> 01:10:16,510
And probably a good
example of that

1694
01:10:16,510 --> 01:10:19,150
is, again, this DNS protocol
that we were looking at before.

1695
01:10:19,150 --> 01:10:21,890
So the DNS protocol--
we still have it

1696
01:10:21,890 --> 01:10:24,990
here-- involves the
client sending a request

1697
01:10:24,990 --> 01:10:27,540
to the server and the server
sending a response back

1698
01:10:27,540 --> 01:10:29,300
to the client.

1699
01:10:29,300 --> 01:10:34,310
And in many cases, the response
is larger than the request.

1700
01:10:34,310 --> 01:10:36,890
The request could be just,
tell me about mit.edu.

1701
01:10:36,890 --> 01:10:38,710
And the response might
be all the records

1702
01:10:38,710 --> 01:10:41,290
the server has about
mit.edu-- the email address,

1703
01:10:41,290 --> 01:10:44,660
the mail server for mit.edu,
the assigned record if it's

1704
01:10:44,660 --> 01:10:46,030
using DNS SEC, and so on.

1705
01:10:46,030 --> 01:10:47,630
So the query might be 100 bytes.

1706
01:10:47,630 --> 01:10:50,946
The response could well
be over 1,000 bytes.

1707
01:10:50,946 --> 01:10:53,120
So suppose that
you want to flood

1708
01:10:53,120 --> 01:10:57,510
some guy with lots of
packets or lots of bandwidth.

1709
01:10:57,510 --> 01:10:59,074
Well, you might
only be able to send

1710
01:10:59,074 --> 01:11:00,240
a small amount of bandwidth.

1711
01:11:00,240 --> 01:11:03,030
But what you could do is you
could fake queries to DNS

1712
01:11:03,030 --> 01:11:04,725
servers on behalf of that guy.

1713
01:11:04,725 --> 01:11:06,170
So you only have
to send 100 bytes

1714
01:11:06,170 --> 01:11:10,360
to some DNS server pretending to
be a query from that poor guy.

1715
01:11:10,360 --> 01:11:12,880
And the DNS server is going
to send 1,000 bytes to him

1716
01:11:12,880 --> 01:11:14,260
on your behalf.

1717
01:11:14,260 --> 01:11:17,920
So this is a problematic
feature of this protocol.

1718
01:11:17,920 --> 01:11:21,510
Because it allows you to
amplify bandwidth attacks.

1719
01:11:21,510 --> 01:11:23,285
And partly for
the same reason we

1720
01:11:23,285 --> 01:11:26,250
were talking about with
TCP's SYN flooding attacks,

1721
01:11:26,250 --> 01:11:28,740
it's very hard for the
server, for the DNS server,

1722
01:11:28,740 --> 01:11:32,110
in this case, to know whether
this request is valid or not.

1723
01:11:32,110 --> 01:11:34,439
Because there's no
authentication or no sort

1724
01:11:34,439 --> 01:11:35,980
of sequence number
exchanges going on

1725
01:11:35,980 --> 01:11:38,188
to tell that this is the
right guy connecting to you,

1726
01:11:38,188 --> 01:11:39,520
et cetera.

1727
01:11:39,520 --> 01:11:42,450
So in fact this is still
a problem in DNS today.

1728
01:11:42,450 --> 01:11:45,180
And it gets used
quite frequently

1729
01:11:45,180 --> 01:11:47,730
to attack people with
bandwidth attacks.

1730
01:11:47,730 --> 01:11:50,184
So if you have a certain
amount of bandwidth,

1731
01:11:50,184 --> 01:11:51,600
you'll be that
much more effective

1732
01:11:51,600 --> 01:11:54,380
if you reflect your attack
off of a DNS server.

1733
01:11:54,380 --> 01:11:57,400
And these DNS servers are
very well provisioned.

1734
01:11:57,400 --> 01:11:59,460
And they basically have
to respond to every query

1735
01:11:59,460 --> 01:12:00,127
out there.

1736
01:12:00,127 --> 01:12:01,960
Because if they stop
responding to requests,

1737
01:12:01,960 --> 01:12:03,530
then probably some legitimate
requests are going to get

1738
01:12:03,530 --> 01:12:04,030
dropped.

1739
01:12:04,030 --> 01:12:05,846
So this is a big
problem in practice.

1740
01:12:05,846 --> 01:12:06,346
Yeah.

1741
01:12:06,346 --> 01:12:08,786
AUDIENCE: So if you can still
see it on the DNS server,

1742
01:12:08,786 --> 01:12:15,140
[INAUDIBLE] requests
and never reply to--

1743
01:12:15,140 --> 01:12:17,820
PROFESSOR: Right, yeah, so
it's possible to maybe modify

1744
01:12:17,820 --> 01:12:20,757
the DNS server to keep some
sort of state like this.

1745
01:12:20,757 --> 01:12:22,965
AUDIENCE: That's the reason
why this still works now,

1746
01:12:22,965 --> 01:12:24,170
because they don't store state?

1747
01:12:24,170 --> 01:12:25,878
PROFESSOR: Yeah, well
I think some people

1748
01:12:25,878 --> 01:12:29,015
are starting to modify DNS
server to try to store state.

1749
01:12:29,015 --> 01:12:32,020
A lot of times, there's so
many DNS servers out there

1750
01:12:32,020 --> 01:12:33,520
that it doesn't matter.

1751
01:12:33,520 --> 01:12:37,498
Even if you appear to do 10
queries against every DNS

1752
01:12:37,498 --> 01:12:38,900
server, that's
still every packet

1753
01:12:38,900 --> 01:12:42,060
gets amplified by some
significant factor.

1754
01:12:42,060 --> 01:12:43,450
And they have to respond.

1755
01:12:43,450 --> 01:12:46,125
Because maybe that client really
is trying to issue this query.

1756
01:12:46,125 --> 01:12:47,000
So this is a problem.

1757
01:12:47,000 --> 01:12:49,190
Yeah, so you're right, if
this was one DNS server,

1758
01:12:49,190 --> 01:12:51,170
then this would be maybe
not as big of a deal.

1759
01:12:51,170 --> 01:12:53,870
The problem is also that
the root servers for DNS,

1760
01:12:53,870 --> 01:12:55,430
for example, aren't
a single machine.

1761
01:12:55,430 --> 01:12:57,360
It's actually racks
and racks of servers.

1762
01:12:57,360 --> 01:12:59,120
Because they're so heavily used.

1763
01:12:59,120 --> 01:13:02,085
And trying to maintain a state
across all these machines

1764
01:13:02,085 --> 01:13:03,430
is probably nontrivial.

1765
01:13:03,430 --> 01:13:05,850
So as it gets abused
more, probably it

1766
01:13:05,850 --> 01:13:09,582
will be more worthwhile
to maintain this state.

1767
01:13:09,582 --> 01:13:11,082
I guess a general
principle you want

1768
01:13:11,082 --> 01:13:15,120
to follow in any
protocol-- well,

1769
01:13:15,120 --> 01:13:17,340
might be a good
principle-- is to make

1770
01:13:17,340 --> 01:13:19,855
the client do at least as much
work as the server is doing.

1771
01:13:19,855 --> 01:13:22,450
So here, the problem is the
client isn't doing as much work

1772
01:13:22,450 --> 01:13:23,310
as the server.

1773
01:13:23,310 --> 01:13:27,280
That's why the server can help
the client amplify this effect.

1774
01:13:27,280 --> 01:13:29,120
If you were redesigning
DNS from scratch,

1775
01:13:29,120 --> 01:13:30,970
and this was really
your big concern,

1776
01:13:30,970 --> 01:13:33,510
then it'd probably be fairly
straightforward to fix this.

1777
01:13:33,510 --> 01:13:36,200
The client has to
send a request that

1778
01:13:36,200 --> 01:13:40,090
has extra padding bytes just
there just wasting bandwidth.

1779
01:13:40,090 --> 01:13:42,610
And then the server is
going to respond back

1780
01:13:42,610 --> 01:13:44,880
with a response that's
at most as big as that.

1781
01:13:44,880 --> 01:13:46,400
And if you want a response
that's bigger, maybe

1782
01:13:46,400 --> 01:13:48,858
the server will say, sorry,
your padding wasn't big enough.

1783
01:13:48,858 --> 01:13:49,780
Send me more padding.

1784
01:13:49,780 --> 01:13:53,300
And this way, you guarantee that
the DNS server cannot be used

1785
01:13:53,300 --> 01:13:58,676
ever to amplify these
kinds of bandwidth attacks.

1786
01:13:58,676 --> 01:14:00,050
Actually, these
kinds of problems

1787
01:14:00,050 --> 01:14:02,390
happen also at higher
levels as well.

1788
01:14:02,390 --> 01:14:04,660
So in web
applications, you often

1789
01:14:04,660 --> 01:14:07,505
have web services that do
lots and lots of computation

1790
01:14:07,505 --> 01:14:08,825
on behalf of a single request.

1791
01:14:08,825 --> 01:14:11,200
And there's often denial of
service attacks at that level

1792
01:14:11,200 --> 01:14:15,200
where adversaries know that
a certain operation is very

1793
01:14:15,200 --> 01:14:17,290
expensive, and they'll
just ask for that operation

1794
01:14:17,290 --> 01:14:18,940
to be done over and over again.

1795
01:14:18,940 --> 01:14:22,520
And unless you carefully design
your protocol and application

1796
01:14:22,520 --> 01:14:24,610
to allow the client
to prove that, oh, I'm

1797
01:14:24,610 --> 01:14:28,670
burning at least as much work
as you, or something like this,

1798
01:14:28,670 --> 01:14:32,803
then it's hard to defend
against these things as well.

1799
01:14:32,803 --> 01:14:34,760
Make sense?

1800
01:14:34,760 --> 01:14:36,950
All right, so I
guess the last thing

1801
01:14:36,950 --> 01:14:38,990
I want to briefly touch
on about the paper

1802
01:14:38,990 --> 01:14:41,150
we talked about as well
is these routing attacks.

1803
01:14:41,150 --> 01:14:43,120
And the reason these
attacks are interesting

1804
01:14:43,120 --> 01:14:46,740
is they're maybe popping up
a level above these protocol

1805
01:14:46,740 --> 01:14:48,200
transport level issues.

1806
01:14:48,200 --> 01:14:50,710
And look at what goes
wrong in an application.

1807
01:14:50,710 --> 01:14:52,960
And the routing protocol is
a particularly interesting

1808
01:14:52,960 --> 01:14:53,460
example.

1809
01:14:53,460 --> 01:14:56,360
Because it's often
the place where

1810
01:14:56,360 --> 01:14:58,670
trust and sort of initial
configuration gets

1811
01:14:58,670 --> 01:15:01,230
bootstrapped in the first place.

1812
01:15:01,230 --> 01:15:04,200
And it's easy to sort
of get that wrong.

1813
01:15:04,200 --> 01:15:07,800
And even today, there's not
great authentication mechanisms

1814
01:15:07,800 --> 01:15:08,790
for that.

1815
01:15:08,790 --> 01:15:11,560
Perhaps the clearest
example is the DHCP protocol

1816
01:15:11,560 --> 01:15:13,660
that all of you guys use
when you open a computer

1817
01:15:13,660 --> 01:15:16,017
or connect to some
wireless or wired network.

1818
01:15:16,017 --> 01:15:17,850
The computer just sends
out a packet saying,

1819
01:15:17,850 --> 01:15:20,370
I want an IP address
and other stuff.

1820
01:15:20,370 --> 01:15:23,900
And some DHCP server at MIT
typically receives that packet

1821
01:15:23,900 --> 01:15:27,957
and sends you back, here's an
IP address that you should use.

1822
01:15:27,957 --> 01:15:29,790
And also here's a DNS
server you should use,

1823
01:15:29,790 --> 01:15:33,030
and other interesting
configuration data.

1824
01:15:33,030 --> 01:15:35,980
And the problem is that the
DHCP request packet is just

1825
01:15:35,980 --> 01:15:37,990
broadcasting on the
local network trying

1826
01:15:37,990 --> 01:15:39,040
to reach the DHCP server.

1827
01:15:39,040 --> 01:15:40,350
Because you actually
don't know what

1828
01:15:40,350 --> 01:15:41,934
the DHCP is going
to be ahead of time.

1829
01:15:41,934 --> 01:15:44,433
You're just plugging into the
network, the first time you've

1830
01:15:44,433 --> 01:15:45,310
been here, let's say.

1831
01:15:45,310 --> 01:15:47,970
And your client doesn't
know what else to do

1832
01:15:47,970 --> 01:15:49,770
or who to trust.

1833
01:15:49,770 --> 01:15:52,890
And consequently, any
machine on the local network

1834
01:15:52,890 --> 01:15:54,660
could intercept
these DHCP requests

1835
01:15:54,660 --> 01:15:56,734
and respond back
with any IP address

1836
01:15:56,734 --> 01:15:59,150
that the client could use, and
also maybe tell the client,

1837
01:15:59,150 --> 01:16:01,525
hey you should use my DNS
server instead of the real one.

1838
01:16:01,525 --> 01:16:03,774
And then you could intercept
those future DNS requests

1839
01:16:03,774 --> 01:16:04,890
from the client and so on.

1840
01:16:04,890 --> 01:16:06,900
That make sense?

1841
01:16:06,900 --> 01:16:09,640
So I think these protocols are
fairly tricky to get right.

1842
01:16:09,640 --> 01:16:12,300
And on a global scale,
the protocols like BGP

1843
01:16:12,300 --> 01:16:14,940
allow any participant to
announce a particular IP

1844
01:16:14,940 --> 01:16:18,505
address prefix for the
world to sort of know about

1845
01:16:18,505 --> 01:16:21,200
and route packets
toward the attacker.

1846
01:16:21,200 --> 01:16:25,053
There's certainly been attacks
where some router participating

1847
01:16:25,053 --> 01:16:29,546
in BGP says, oh,
I'm a very quick way

1848
01:16:29,546 --> 01:16:31,409
to reach this particular
IP address range.

1849
01:16:31,409 --> 01:16:32,950
And then all the
routers in the world

1850
01:16:32,950 --> 01:16:36,090
say, OK, sure, we'll send
those packets to you.

1851
01:16:36,090 --> 01:16:40,330
And probably the most
frequent abuse of this

1852
01:16:40,330 --> 01:16:42,432
is by spammers who
want to send spam,

1853
01:16:42,432 --> 01:16:44,720
but their old IP addresses
are blacklisted everywhere,

1854
01:16:44,720 --> 01:16:46,000
because they are sending spam.

1855
01:16:46,000 --> 01:16:47,910
So they just pick some
random IP address.

1856
01:16:47,910 --> 01:16:50,332
They announce that, oh yeah,
this IP address is now here.

1857
01:16:50,332 --> 01:16:52,290
And then they sort of
announce this IP address,

1858
01:16:52,290 --> 01:16:54,080
send spam from it,
and then disconnect.

1859
01:16:54,080 --> 01:16:57,935
And it gets abused a
fair amount this way.

1860
01:16:57,935 --> 01:17:00,382
It's sort of getting less now.

1861
01:17:00,382 --> 01:17:01,590
But it's kind of hard to fix.

1862
01:17:01,590 --> 01:17:04,560
Because in order
to fix it, you have

1863
01:17:04,560 --> 01:17:07,434
to know whether someone really
owns that IP address or not.

1864
01:17:07,434 --> 01:17:09,100
And it's hard to do
without establishing

1865
01:17:09,100 --> 01:17:12,100
some global database of,
maybe, cryptographic keys

1866
01:17:12,100 --> 01:17:13,890
for every ISP in the world.

1867
01:17:13,890 --> 01:17:16,510
And it takes quite a
bit of effort by someone

1868
01:17:16,510 --> 01:17:18,080
to build this database.

1869
01:17:18,080 --> 01:17:20,640
The same actually applies
to DNS SEC as well.

1870
01:17:20,640 --> 01:17:23,350
In order to know which
signature to look for in DNS,

1871
01:17:23,350 --> 01:17:25,690
you have to have a
cryptographic key associated

1872
01:17:25,690 --> 01:17:27,420
with every entity in the world.

1873
01:17:27,420 --> 01:17:28,677
And it's not there now.

1874
01:17:28,677 --> 01:17:30,010
Maybe it'll get built up slowly.

1875
01:17:30,010 --> 01:17:34,910
But it's certainly one big
problem for adopting DNS SEC.

1876
01:17:34,910 --> 01:17:37,542
All right, so I guess the
thing to take away from this

1877
01:17:37,542 --> 01:17:39,500
is maybe just a bunch of
lessons about what not

1878
01:17:39,500 --> 01:17:41,200
to do in general in protocols.

1879
01:17:41,200 --> 01:17:43,074
But also actually one
thing I want to mention

1880
01:17:43,074 --> 01:17:46,307
is that while probably
secrecy and integrity are

1881
01:17:46,307 --> 01:17:48,390
good properties and driving
force of higher levels

1882
01:17:48,390 --> 01:17:50,637
of abstraction, like in
cryptographic protocols

1883
01:17:50,637 --> 01:17:53,220
in the application-- and we'll
look at that in next lectures--

1884
01:17:53,220 --> 01:17:55,303
one thing that you really
do want from the network

1885
01:17:55,303 --> 01:17:57,384
is some sort of availability
and DOS resistance.

1886
01:17:57,384 --> 01:17:59,050
Because these properties
are much harder

1887
01:17:59,050 --> 01:18:00,850
to achieve at higher
levels in the stack.

1888
01:18:00,850 --> 01:18:02,266
So you really want
to avoid things

1889
01:18:02,266 --> 01:18:04,710
like maybe these
amplification attacks, maybe

1890
01:18:04,710 --> 01:18:09,250
these SYN flooding attacks,
maybe these RST attacks

1891
01:18:09,250 --> 01:18:11,680
where you can shoot down an
arbitrary person's connection.

1892
01:18:11,680 --> 01:18:14,096
These are things that are
really damaging at the low level

1893
01:18:14,096 --> 01:18:16,190
and that are hard
to fix higher up.

1894
01:18:16,190 --> 01:18:19,155
But the integrity and
confidentiality you

1895
01:18:19,155 --> 01:18:20,780
can more or less
solve with encryption.

1896
01:18:20,780 --> 01:18:23,310
And we'll talk about how we
do that in the next lecture

1897
01:18:23,310 --> 01:18:23,910
on Cerberus.

1898
01:18:23,910 --> 01:18:25,760
See you guys then.
