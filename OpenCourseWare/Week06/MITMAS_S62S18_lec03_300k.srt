1
00:00:00,850 --> 00:00:03,220
Konten berikut diberikan
di bawah lisensi

2
00:00:03,220 --> 00:00:04,610
Creative Commons.

3
00:00:04,610 --> 00:00:06,820
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,820 --> 00:00:10,910
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,910 --> 00:00:13,480
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:13,480 --> 00:00:17,440
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:17,440 --> 00:00:18,313
di ocw.mit.edu.

8
00:00:22,948 --> 00:00:24,490
TADGE DRYJA: Hari ini,
saya akan berbicara

9
00:00:24,490 --> 00:00:29,770
tentang tanda tangan (dijital) dan
berbagai hal yang berhubungan

10
00:00:29,770 --> 00:00:30,490
dengan tanda tangan.

11
00:00:30,490 --> 00:00:33,343
Di tugas, Anda
bekerja dengan tanda tangan,

12
00:00:33,343 --> 00:00:35,510
tetapi Anda bekerja dengan
tanda tangan berbasis hash, yang

13
00:00:35,510 --> 00:00:38,405
sebenarnya tidak digunakan
di bitcoin sama sekali.

14
00:00:38,405 --> 00:00:39,580
Tapi kita akan berbicara tentang itu.

15
00:00:39,580 --> 00:00:40,080
OK.

16
00:00:40,080 --> 00:00:43,630
Jadi jika Anda sudah
mengerjakan pekerjaan rumah,

17
00:00:43,630 --> 00:00:46,810
ada tanda tangan
lamport, betul?

18
00:00:46,810 --> 00:00:49,040
Itu adalah tanda tangan berbasis hash.

19
00:00:49,040 --> 00:00:52,010
Dan mereka menggunakan fungsi hash.

20
00:00:52,010 --> 00:00:53,940
Jadi itu cukup jelas.

21
00:00:53,940 --> 00:00:54,940
Anda dapat memahaminya.

22
00:00:54,940 --> 00:00:57,350
Tidak ada hal yang
super gila.

23
00:00:57,350 --> 00:00:58,720
Kodenya cukup singkat.

24
00:00:58,720 --> 00:00:59,830
Jadi itu keren.

25
00:00:59,830 --> 00:01:03,340
Apa kekurangan dari
tanda tangan lamport ini?

26
00:01:03,340 --> 00:01:05,342
Siapapun-- ya?

27
00:01:05,342 --> 00:01:06,800
AUDIENS: Anda hanya
bisa menggunakannya sekali.

28
00:01:06,800 --> 00:01:07,410
TADGE DRYJA: Ya.

29
00:01:07,410 --> 00:01:07,910
OK.

30
00:01:07,910 --> 00:01:09,045
Jadi tambahannya.

31
00:01:09,045 --> 00:01:09,670
Ini adalah hash.

32
00:01:09,670 --> 00:01:10,480
Itu keren.

33
00:01:10,480 --> 00:01:13,570
Satu kali pakai.

34
00:01:13,570 --> 00:01:18,830
Kemungkinan kekurangan lain
dibandingkan sistem lain,

35
00:01:18,830 --> 00:01:20,350
jika Anda memperhatikan.

36
00:01:20,350 --> 00:01:26,420
Lainnya adalah mereka cukup
besar, betul kan?

37
00:01:26,420 --> 00:01:28,080
Anda bisa mengatasinya.

38
00:01:28,080 --> 00:01:30,740
Tetapi jika Anda mencari
di forge?,

39
00:01:30,740 --> 00:01:33,260
atau file tersebut
dengan tanda tangannya,

40
00:01:33,260 --> 00:01:37,930
itu seperti, apa, 8K
untuk sebuah tanda tangan--

41
00:01:37,930 --> 00:01:40,520
8 kilobyte-- cukup besar.

42
00:01:40,520 --> 00:01:42,470
Kuncinya are 16 kilobyte--

43
00:01:42,470 --> 00:01:43,400
menyebalkan.

44
00:01:43,400 --> 00:01:46,790
Kunci privat
juga 16 kilobyte.

45
00:01:46,790 --> 00:01:55,080
Jadi ya, tanda tangan 8K,
16K kunci privat/publik.

46
00:01:55,080 --> 00:01:58,800
Itu adalah kekurangannya.

47
00:01:58,800 --> 00:02:00,820
Saya tidak punya
slide, saya

48
00:02:00,820 --> 00:02:04,810
akan membuatnya lebih
menyenangkan dan interaktif.

49
00:02:04,810 --> 00:02:07,930
Apa solusi-solusi yang bisa ditawarkan
untuk masalah-masalah ini?

50
00:02:07,930 --> 00:02:11,710
Jadi kita sebenarnya bisa
memitigasi/mengatasi

51
00:02:11,710 --> 00:02:15,280
kedua hal ini dengan
hasil yang cukup memuaskan.

52
00:02:15,280 --> 00:02:17,470
Bagaimana dengan yang pertama,
satu kali pakai?

53
00:02:17,470 --> 00:02:20,170
Apa yang menjadi cara
yang cukup nampak

54
00:02:20,170 --> 00:02:23,090
untuk mengatasi
masalah satu kali pakai?

55
00:02:23,090 --> 00:02:26,903
Dan saya rasa jawabannya
itu terlalu bodoh.

56
00:02:26,903 --> 00:02:29,070
Jawabannya terdengar bodoh,
dan itu bisa saja bekerja.

57
00:02:29,070 --> 00:02:30,140
Jadi ya?

58
00:02:30,140 --> 00:02:33,200
AUDIENS: Tidak menunjukkan
potongan-potongan kunci privat?

59
00:02:33,200 --> 00:02:37,303
Sebagai gantinya, tunjukkan hal lain.

60
00:02:37,303 --> 00:02:39,220
TADGE DRYJA: Mungkin
ada cara yang pintar.

61
00:02:39,220 --> 00:02:40,780
Tapi itu mungkin terlalu pintar.

62
00:02:40,780 --> 00:02:47,200
Sesuatu yang sangat sederhana,
OK, saya hanya bisa menggunakan kunci sekali.

63
00:02:47,200 --> 00:02:49,850
Bagaimana saya bisa menggunakan "kunci"
dalam tanda kutip, lebih dari sekali?

64
00:02:49,850 --> 00:02:50,350
Ya?

65
00:02:50,350 --> 00:02:51,050
AUDIENS: Buat yang lain.

66
00:02:51,050 --> 00:02:51,330
TADGE DRYJA: Ya.

67
00:02:51,330 --> 00:02:52,540
Anda dapat membuat kunci yang lain.

68
00:02:52,540 --> 00:02:56,500
Jadi Anda dapat berkata, saya
punya kunci publik 16 kilobyte ini.

69
00:02:56,500 --> 00:03:00,050
Saya akan membuat sebuah
kunci publik 32 kilobyte.

70
00:03:00,050 --> 00:03:03,040
Dan itu hanyalah 2 kunci
publik ditempelkan.

71
00:03:06,550 --> 00:03:08,410
Dan sekarang, jika saya
membuat tanda tangan,

72
00:03:08,410 --> 00:03:10,540
Saya cukup menambahkan bit
ekstra di depan.

73
00:03:10,540 --> 00:03:13,870
San saya katakan, tanda tangan
ini menggunakan kunci 0

74
00:03:13,870 --> 00:03:15,490
atau tanda tangan ini
menggunakan kunci 1,

75
00:03:15,490 --> 00:03:18,100
dan kita mendapatkan seluruh
tanda tangan sesudahnya.

76
00:03:18,100 --> 00:03:21,280
Dan saat Anda melihat ke
kunci publik 32 kilobyte ini,

77
00:03:21,280 --> 00:03:23,560
dan Anda katakan, OK,
itu dimulai dengan nol,

78
00:03:23,560 --> 00:03:28,090
berarti menggunakan kunci pertama,
subkunci pertama

79
00:03:28,090 --> 00:03:30,580
dalam blok kunci
32 byte ini.

80
00:03:30,580 --> 00:03:32,340
Dan dalam kasus ini,
menggunakan satu,

81
00:03:32,340 --> 00:03:35,928
sehingga itu menggunakan
subkey yang belakangan disebut,

82
00:03:35,928 --> 00:03:36,720
Jadi itu dapat bekerja.

83
00:03:36,720 --> 00:03:41,020
Dengan begitu Anda dapat
menggunakan kunci publik Anda dua kali,

84
00:03:41,020 --> 00:03:44,260
dengan biaya ukuran kunci
publik Anda menjadi dobel, di mana

85
00:03:44,260 --> 00:03:48,043
tidak terlalu bagus, bukan?

86
00:03:48,043 --> 00:03:49,210
Dan itu tidak terlalu efisien.

87
00:03:49,210 --> 00:03:51,220
Tapi itu bisa bekerja.

88
00:03:51,220 --> 00:03:51,790
OK.

89
00:03:51,790 --> 00:03:58,700
Ada cara pintar lain untuk
melakukannya lebih efisien?

90
00:03:58,700 --> 00:03:59,770
Atau tunggu.

91
00:03:59,770 --> 00:04:04,330
Jadi OK, juga, saya
akan memberikan Anda petunjuk.

92
00:04:04,330 --> 00:04:10,210
Pada kasus ini, mari kita katakan
pub (publik) sub 0 dan pub sub 1, betul?

93
00:04:10,210 --> 00:04:13,780
Dan berikutnya, 32 byte
pubkey (kunci publik) hanyalah mereka

94
00:04:13,780 --> 00:04:15,730
digabungkan bersama, bukan--

95
00:04:15,730 --> 00:04:16,930
pub0, pub1.

96
00:04:20,240 --> 00:04:27,270
Apa yang terjadi terhadap kunci
privat di kasus ini, ya?

97
00:04:27,270 --> 00:04:30,000
Bagaimana kunci privat
bekerja di sini?

98
00:04:30,000 --> 00:04:34,650
Sama-sama mengembang, saya rasa.

99
00:04:34,650 --> 00:04:40,200
Ada yang punya cara untuk
memitigasi berkembangnya ukuran

100
00:04:40,200 --> 00:04:42,410
kunci privat dalam kasus ini?

101
00:04:42,410 --> 00:04:45,540
Jadi kunci privatnya adalah
preimage (asal mula) di sini, betul?

102
00:04:45,540 --> 00:04:48,833
Mereka berkembang menjadi
blok kunci publik ini.

103
00:04:48,833 --> 00:04:50,250
Jadi Anda bisa sekedar
bilang, OK, saya

104
00:04:50,250 --> 00:04:54,000
punya dua kali ukuran kunci
privat menjadi dua kali ukuran

105
00:04:54,000 --> 00:04:55,050
kunci publik.

106
00:04:55,050 --> 00:04:56,520
Bisakah Anda melakukannya
lebih efisien?

107
00:04:56,520 --> 00:04:57,020
Ya?

108
00:04:57,020 --> 00:04:59,070
AUDIENS: Bisakah Anda cukup
melakukan hash terhadap kunci privat?

109
00:04:59,070 --> 00:05:02,610
sehingga Anda punya 2 hash
bukan cuma 1?

110
00:05:02,610 --> 00:05:04,400
TADGE DRYJA: Ya.

111
00:05:04,400 --> 00:05:08,470
Jadi misalkan Anda punya
blok 16K ini,

112
00:05:08,470 --> 00:05:12,240
dan Anda ingin ini berubah
menjadi dua kunci publik.

113
00:05:12,240 --> 00:05:15,520
Jadi itu dasar cara
yang bagus untuk melakukannya.

114
00:05:15,520 --> 00:05:17,730
Dan kurang lebih
akan seperti itu.

115
00:05:17,730 --> 00:05:21,115
Bagaimana tepatnya-- apa cara
untuk melakukannya?

116
00:05:21,115 --> 00:05:23,640
AUDIENS: Anda dapat mempertahankan
kunci privat yang sama seperti sebelumnya

117
00:05:23,640 --> 00:05:26,550
dan tambahkan sesuatu seperti
nol atau satu untuk mengindikasikan--

118
00:05:26,550 --> 00:05:27,540
TADGE DRYJA: Ya.

119
00:05:27,540 --> 00:05:29,690
Jadi ini adalah fungsi
hash, ya?

120
00:05:29,690 --> 00:05:34,320
Dan seperti sebelumnya, kita katakan,
OK hash dari ini adalah blok 0,

121
00:05:34,320 --> 00:05:36,570
ini adalah blok 1,
ini adalah blok 2.

122
00:05:36,570 --> 00:05:40,272
Jadi ide dari pub--

123
00:05:40,272 --> 00:05:41,270
kita lihat.

124
00:05:41,270 --> 00:05:42,460
Apakah ini terlihat?

125
00:05:42,460 --> 00:05:44,287
Mungkin terlalu kecil, ya?

126
00:05:44,287 --> 00:05:44,870
AUDIENS: Ya.

127
00:05:44,870 --> 00:05:45,845
TADGE DRYJA: Ya, OK.

128
00:05:45,845 --> 00:05:47,480
Mari kita buat ini lebih besar.

129
00:05:50,680 --> 00:05:52,460
Maaf.

130
00:05:52,460 --> 00:05:52,960
OK.

131
00:05:52,960 --> 00:06:00,680
Jadi pada diagram ini, Anda sudah
punya kunci privat Anda saat ini.

132
00:06:00,680 --> 00:06:02,030
Dan ini dalam blok besar ini.

133
00:06:02,030 --> 00:06:05,940
Dan ada 256 darinya, tapi kita
coba buat supaya tetap kecil.

134
00:06:05,940 --> 00:06:08,660
Dan idenya adalah ini adalah
blok 32 byte dengan bilangan acak

135
00:06:08,660 --> 00:06:09,410
di dalamnya.

136
00:06:09,410 --> 00:06:12,110
Dan Anda lakukan hash
untuk mendapatkan kunci publik.

137
00:06:15,290 --> 00:06:17,832
Jadi misalkan, OK, pub2--

138
00:06:17,832 --> 00:06:21,430
dan ini adalah publik, ini
adalah privat, dan, kita katakan,

139
00:06:21,430 --> 00:06:23,410
rahasia--

140
00:06:23,410 --> 00:06:30,050
pub2 hanyalah hash dari
secret2, betul?

141
00:06:30,050 --> 00:06:30,550
Tapi ya.

142
00:06:30,550 --> 00:06:33,050
Apa yang bisa kita lakukan adalah
kita bisa memiliki dua fungsi hash

143
00:06:33,050 --> 00:06:34,540
berbeda.

144
00:06:34,540 --> 00:06:36,760
Dan ada cara yang sangat
sederhana untuk membuat

145
00:06:36,760 --> 00:06:38,650
fungsi hash yang sangat
berbeda-beda

146
00:06:38,650 --> 00:06:43,180
adalah dengan cara, OK,
hash0 sudah terdefinisi

147
00:06:43,180 --> 00:06:48,310
sebagai fungsi hash tentang apapun
masukan x Anda direkatkan

148
00:06:48,310 --> 00:06:50,230
dengan angka 0.

149
00:06:50,230 --> 00:06:56,260
Kemudian hash1, kita definisikan
sebagai x koma 1 dan seterusnya.

150
00:06:56,260 --> 00:06:57,670
Dan ini sebenarnya aman.

151
00:06:57,670 --> 00:06:59,260
Anda dapat melakukan ini.

152
00:06:59,260 --> 00:07:02,345
Ada pertanyaan atau
mungkin keberatan?

153
00:07:02,345 --> 00:07:04,970
AUDIENS: Saya berpikir jika
seseorang tahu fungsi hash

154
00:07:04,970 --> 00:07:06,763
yang Anda gunakan, bukankah
mereka hanya mendefinisikan

155
00:07:06,763 --> 00:07:09,180
x karena mereka tahu bahwa
itu tidak akan membantu [TIDAK TEDENGAR] x.

156
00:07:09,180 --> 00:07:09,700
[TIDAK TERDENGAR]

157
00:07:09,700 --> 00:07:10,420
TADGE DRYJA: Ya.

158
00:07:10,420 --> 00:07:11,110
Ya.

159
00:07:11,110 --> 00:07:19,140
Jadi tidak benar-benar ada entropi
atau rahasia antara 0 dan 1 ini.

160
00:07:19,140 --> 00:07:22,420
Tetapi itu murni
berdasarkan pada x, ya?

161
00:07:22,420 --> 00:07:26,140
Tapi idenya adalah,
yah, jika saya melakukan ini,

162
00:07:26,140 --> 00:07:30,880
dan saya katakan, OK, yah
pub2 adalah hashnya

163
00:07:30,880 --> 00:07:34,890
dari secret2 digabungkan dengan
0, yah, jika anda tahu secret2,

164
00:07:34,890 --> 00:07:36,290
Anda bisa kembali.

165
00:07:36,290 --> 00:07:37,330
Karena pengaruh 0 sudah jelas.

166
00:07:37,330 --> 00:07:40,210
Namun idenya adalah jika Anda tidak 
tahu nilai secret2, maka fakta bahwa Anda

167
00:07:40,210 --> 00:07:45,040
mengetahui byte terakhir dari masukan 
hash tidak akan terlalu membantu Anda.

168
00:07:45,040 --> 00:07:48,400
Karena ada sekumpulan data ini
yang tidak Anda ketahui.

169
00:07:48,400 --> 00:07:50,650
Dan Anda tidak akan mampu 
menemukan sebuah preimage.

170
00:07:50,650 --> 00:07:52,540
Kamu akan berpikir, oke, saya
tahu preimage

171
00:07:52,540 --> 00:07:55,540
untuk public2 berakhir dengan sebuah byte 0

172
00:07:55,540 --> 00:07:59,080
Apakah nilai 32 byte lainnya
yang muncul sebelumnya?

173
00:07:59,080 --> 00:08:01,404
Anda tetap tidak bisa kembali
untuk membuat sebuah preimage

174
00:08:01,404 --> 00:08:05,615
AUDIENS: Namun sepertinya
ada semacam--

175
00:08:05,615 --> 00:08:08,470
Apa ya-- Anda akan membuat sebuah
pernyataan serupa yang mengatkaan, oh

176
00:08:08,470 --> 00:08:10,360
Jika byte terakhir
tidak penting,

177
00:08:10,360 --> 00:08:13,600
lalu byte kedua terakhir
juga tidak penting, kan?

178
00:08:17,950 --> 00:08:20,620
TADGE DRYJA: Jadi serangannya
adalah saya punya pub2

179
00:08:20,620 --> 00:08:23,320
yang adalah keluaran hash 32 byte.

180
00:08:23,320 --> 00:08:27,820
Saya ingin tahu
benda apakah ini.

181
00:08:27,820 --> 00:08:29,800
Sekarang, saya ingin mengetahui apa
isi byte yang terakhir, yah?

182
00:08:29,800 --> 00:08:32,320
Itu akan menjadi,
misalnya, 33 byte,

183
00:08:32,320 --> 00:08:34,780
dan byte terakhir itu adalah sebuah 0.

184
00:08:34,780 --> 00:08:37,570
Dan ini akan menjadi
beberapa angka acak

185
00:08:37,570 --> 00:08:38,500
Jadi saya memiliki beberapa petunjuk
tentang bagaimana preimage nya.

186
00:08:38,500 --> 00:08:43,539
Saya mendapatkan informasi mengenai gambar awal.

187
00:08:43,539 --> 00:08:45,970
Saya tahu byte terakhirnya adalah sebuah 0.

188
00:08:45,970 --> 00:08:47,950
Tapi itu tidak
membantu karena saya tidak

189
00:08:47,950 --> 00:08:51,160
tahu semua byte sebelum itu.

190
00:08:51,160 --> 00:08:54,130
Jadi saya tidak bisa benar-benar melakukan--

191
00:08:54,130 --> 00:08:56,770
Saya tidak bisa menandai karena saya
harus mampu mengungkapkan

192
00:08:56,770 --> 00:08:57,945
semua hal ini.

193
00:08:57,945 --> 00:09:00,070
Dan cara fungsi hash bekerja,
jika itu adalah fungsi hash yang baik

194
00:09:00,070 --> 00:09:03,722
function, faktanya bahwa Anda
tahu beberapa bagian dari preimage

195
00:09:03,722 --> 00:09:05,680
tidak seharusnya memberikan Anda
petunjuk ke bagian-bagian lain

196
00:09:05,680 --> 00:09:07,270
dari preimage.

197
00:09:07,270 --> 00:09:08,930
Karena itu terlihat sangat acak.

198
00:09:08,930 --> 00:09:14,380
Dan menambahkan sesuatu di akhir
ini seharusnya tidak mengungkapkan apapun.

199
00:09:14,380 --> 00:09:16,660
Ada fungsi-fungsi hash
di mana ini bisa sangat membahayakan,

200
00:09:16,660 --> 00:09:19,840
dan Anda bisa mempertimbangkannya seperti
fungsi hash yang rusak, di mana

201
00:09:19,840 --> 00:09:22,690
jika saya tambahkan banyak
data yang telah diketahui di akhir,

202
00:09:22,690 --> 00:09:27,110
itu mungkin memberi saya sifat-sifat dari
kunci publik yang dapat saya temukan.

203
00:09:27,110 --> 00:09:30,070
[TIDAK TERDENGAR],, sejauh yang
kami tahu, ini berfungsi dengan baik.

204
00:09:30,070 --> 00:09:32,440
Sebagian besar fungsi hash
bekerja dengan baik dengan cara ini.

205
00:09:32,440 --> 00:09:34,750
Jadi yah, Anda dapat melakukannya.

206
00:09:34,750 --> 00:09:36,370
Dan kemudian Anda dapat
berkata, oke, yah, saya

207
00:09:36,370 --> 00:09:42,710
akan menggunakan fungsi hash
0 untuk membuat pubkey 0, bukan?

208
00:09:42,710 --> 00:09:44,020
Ini adalah pubkey 0.

209
00:09:44,020 --> 00:09:50,470
Dan jika saya menggunakan fungsi hash
1, saya membuat pubkey 1.

210
00:09:50,470 --> 00:09:55,910
Sekarang saya memiliki sebuah 16 kilobyte--
Saya hapus ini--

211
00:09:58,152 --> 00:09:59,985
Jadi sekarang, yang bisa saya lakukan
adalah saya bisa berkata, oke, yah,

212
00:09:59,985 --> 00:10:03,990
Saya punya kunci rahasia,
kunci privat sebesar 16 kilobyte,

213
00:10:03,990 --> 00:10:10,050
tapi saya punya pubkey (kunci
publik) sebesar 32 kilobyte

214
00:10:10,050 --> 00:10:11,927
yang bisa saya gunakan 2 kali
dan mempunyai 2 subkey

215
00:10:11,927 --> 00:10:14,260
jadi saya tidak perlu menyimpan
sebesar data kunci privat milik saya.

216
00:10:14,260 --> 00:10:15,250
Jadi itu keren.

217
00:10:15,250 --> 00:10:18,228
itu membuatnya 
sedikit lebih efisien. 

218
00:10:18,228 --> 00:10:20,770
Apakah ada yang mempunyai ide 
bagaimana membuatnya lebih efisien

219
00:10:20,770 --> 00:10:21,770
untuk penyimpanan kunci private?

220
00:10:24,260 --> 00:10:27,480
Anda sebenarnya bisa membuatnya
sangat efisien 

221
00:10:27,480 --> 00:10:30,408
dengan menggunakan ide ini.

222
00:10:30,408 --> 00:10:31,360
Ada ide?

223
00:10:35,644 --> 00:10:36,600
Ya.

224
00:10:36,600 --> 00:10:37,310
Baik, Anda--

225
00:10:40,220 --> 00:10:42,380
Jadi beberapa petunjuk.

226
00:10:42,380 --> 00:10:44,000
Ini sangat berguna, bukan?

227
00:10:44,000 --> 00:10:46,190
Idenya adalah, yah,
bahkan jika Anda tahu

228
00:10:46,190 --> 00:10:49,550
sufiks seperti apa
dari semua hal ini,

229
00:10:49,550 --> 00:10:51,290
jika Anda tidak 
tahu x, Anda tidak

230
00:10:51,290 --> 00:10:54,740
akan mampu menemukan 
preimagenya, betul?

231
00:10:54,740 --> 00:10:57,540
Jadi mungkin tambahkan
beberapa hal di sini.

232
00:10:57,540 --> 00:10:58,040
Ada ide?

233
00:11:01,640 --> 00:11:02,600
Oh, ya?

234
00:11:02,600 --> 00:11:04,560
AUDIENS: Bisakah Anda melakukan
hash pada indeksnya?

235
00:11:04,560 --> 00:11:05,610
TADGE DRYJA: Betul.

236
00:11:05,610 --> 00:11:06,110
Betul.

237
00:11:06,110 --> 00:11:10,210
Jadi daripada hanya
mengatakan 0 dan 1

238
00:11:10,210 --> 00:11:14,650
dapat kita katakan di sini, yah, bagaimana
kalau hanya memiliki satu bagian?

239
00:11:14,650 --> 00:11:25,510
Ada satu bagian, dan
memiliki angka x yang acak.

240
00:11:25,510 --> 00:11:27,880
Yah, ini merupakan hash dari x koma 0

241
00:11:27,880 --> 00:11:31,840
Ini adalah hash dari x koma 1.

242
00:11:31,840 --> 00:11:35,330
Ini adalah hash dari x koma 2.

243
00:11:35,330 --> 00:11:35,830
OK.

244
00:11:35,830 --> 00:11:36,330
Jadi, ya.

245
00:11:36,330 --> 00:11:40,600
Jadi yang bisa Anda lakukan adalah Anda dapat--

246
00:11:40,600 --> 00:11:43,690
ini sebelumnya, benar,
saat saya berkata, OK, yah,

247
00:11:43,690 --> 00:11:48,700
tapi ini pada dasarnya bagaimana cara
melakukan kunci privat sebesar 32 byte di mana

248
00:11:48,700 --> 00:11:51,040
kunci privat Anda
sebenarnya cukup kecil,

249
00:11:51,040 --> 00:11:55,330
dan Anda hanya menurunkan
semua kunci publik

250
00:11:55,330 --> 00:11:59,110
dengan menambahkan angka-angka di
belakang, menggabungkannya

251
00:11:59,110 --> 00:11:59,990
menjadi hash Anda.

252
00:11:59,990 --> 00:12:01,240
Dan sekarang Anda seperti, OK, keren.

253
00:12:01,240 --> 00:12:04,420
Saya mempunyai sebuah kunci privat
sebesar 32 byte, dan saya

254
00:12:04,420 --> 00:12:06,640
dapat membuat kunci publik yang
sangat besar dari mereka,

255
00:12:06,640 --> 00:12:08,260
dan itu masih aman, bukan?

256
00:12:08,260 --> 00:12:11,410
Karena saya dapat menambahkan angka
apapun yang saya inginkan disini.

257
00:12:11,410 --> 00:12:13,488
Dan saya bisa melakukan ini
jutaan kali,

258
00:12:13,488 --> 00:12:16,030
dan tidak ada yang bisa menemukan
preimage nya, meskipun saya

259
00:12:16,030 --> 00:12:18,580
memberikan Anda semua hash
yang berkaitan ini, bukan?

260
00:12:18,580 --> 00:12:21,900
Itu x koma 0, x koma
1, x koma satu juta.

261
00:12:21,900 --> 00:12:23,340
Saya bisa memberi Anda jutaan dari mereka.

262
00:12:23,340 --> 00:12:25,390
Dan setiap kali saya melakukannya,
itu tidak memberi Anda

263
00:12:25,390 --> 00:12:27,880
wawasan tentang bagaimana
menemukan nilai dari x--

264
00:12:27,880 --> 00:12:29,597
jika itu adalah fungsi hash yang baik.

265
00:12:29,597 --> 00:12:30,680
Jadi itu sangat kuat.

266
00:12:30,680 --> 00:12:33,520
Dan sekarang saya bisa katakan, OK,
masalah kunci privat sudah terpecahkan.

267
00:12:33,520 --> 00:12:37,420
Saya memiliki 0 dari 1 pertumbuhan
di kunci privat saya

268
00:12:37,420 --> 00:12:39,670
Saya dapat membuat kunci publik
sebanyak yang saya inginkan, tidak pernah

269
00:12:39,670 --> 00:12:40,570
bertambah besar.

270
00:12:40,570 --> 00:12:42,112
Keren.

271
00:12:42,112 --> 00:12:44,320
Namun masih punya masalah dengan
kunci publik ini.

272
00:12:44,320 --> 00:12:46,820
Katakanlah saya ingin
menandatangani empat kali.

273
00:12:46,820 --> 00:12:47,320
OK.

274
00:12:47,320 --> 00:12:50,957
Yah, saya akan membuat kunci
publik sebesar 64 kilobyte.

275
00:12:54,640 --> 00:12:56,270
Sekarang saya bisa menandatangani empat kali.

276
00:12:56,270 --> 00:12:56,770
Bagus.

277
00:12:56,770 --> 00:13:00,820
Tapi ukuran kunci publik saya membesar
sesuai dengan jumlah tandatangan yang

278
00:13:00,820 --> 00:13:04,100
ingin saya lakukan.

279
00:13:04,100 --> 00:13:07,250
Ada ide tentang bagaimana Anda
bisa memitigasinya?

280
00:13:07,250 --> 00:13:10,130
atau bagaimana Anda masih bisa
membuat sistem yang dapat digunakan,

281
00:13:10,130 --> 00:13:11,060
terlepas dari fakta ini?

282
00:13:14,410 --> 00:13:18,270
Ada beberapa 
teknik berbeda.

283
00:13:18,270 --> 00:13:18,770
Ada ide?

284
00:13:21,000 --> 00:13:21,500
Oke.

285
00:13:21,500 --> 00:13:25,180
Jadi salah satunya adalah
setiap saya menandatangani,

286
00:13:25,180 --> 00:13:29,830
Saya juga menandatangani kunci publik saya berikutnya.

287
00:13:29,830 --> 00:13:31,540
Anda bisa melakukan itu.

288
00:13:31,540 --> 00:13:33,160
Terdapat beberapa kerugian, bukan?

289
00:13:33,160 --> 00:13:37,540
Jadi idenya adalah pertama saya mempublikasikan
satu kunci publik sebesar 16 kilobyte.

290
00:13:37,540 --> 00:13:41,620
Dan kemudian saya berkata, oke, ketika saya menandatangani,
saya akan menandatangani pesan saya.

291
00:13:41,620 --> 00:13:45,610
Dan digabungkan dengan
pesan itu adalah kunci publik saya berikutnya.

292
00:13:45,610 --> 00:13:48,040
Jadi saya menandatangani sesuatu
dan juga menunjukkan

293
00:13:48,040 --> 00:13:51,190
apa kunci publik saya berikutnya
yang akan saya tandatangani.

294
00:13:51,190 --> 00:13:54,160
Lalu saya masih bisa mempertahankan
kunci privat yang kecil

295
00:13:54,160 --> 00:13:55,570
dan tetap menandatangani.

296
00:13:55,570 --> 00:13:58,690
Masalahnya adalah, agar
seseorang dapat memverifikasi

297
00:13:58,690 --> 00:14:01,370
mereka akan perlu melihat
semua tanda saya sebelumnya

298
00:14:01,370 --> 00:14:01,870
bukan?

299
00:14:01,870 --> 00:14:05,430
Jadi jika saya berkata, hei,
ini adalah kunci publik ke-500 saya

300
00:14:05,430 --> 00:14:07,180
yang saya tandatangani,
ini pesannya,

301
00:14:07,180 --> 00:14:09,722
Anda harus kembali
dan melihat seluruh riwayat

302
00:14:09,722 --> 00:14:14,000
tandatangan saya, di mana ini bukan hal bagus.

303
00:14:14,000 --> 00:14:14,500
Oke.

304
00:14:14,500 --> 00:14:19,418
Jadi ide lain bagaimana
menangani kunci publik yang besar?

305
00:14:19,418 --> 00:14:20,710
Cara apa yang bisa Anda lakukan?

306
00:14:23,500 --> 00:14:25,570
Jadi beberapa petunjuk.

307
00:14:25,570 --> 00:14:28,700
Apakah ada jenis
fungsi data yang

308
00:14:28,700 --> 00:14:31,570
telah kita lihat disini di mana
fungsi itu menerima data dengan

309
00:14:31,570 --> 00:14:34,630
ukuran yang tidak tentu dan keluaran
dengan ukuran tetap?

310
00:14:34,630 --> 00:14:36,610
[TERTAWA]

311
00:14:36,610 --> 00:14:38,250
Faktanya, itu
satu-satunya hal yang kita

312
00:14:38,250 --> 00:14:40,750
bicarakan sejauh ini.

313
00:14:40,750 --> 00:14:43,867
Jadi apa yang akan Anda lakukan untuk membuat
kunci publik Anda berukuran kecil?

314
00:14:43,867 --> 00:14:44,492
AUDIENS: Hash.

315
00:14:44,492 --> 00:14:45,450
TADGE DRYJA: Lakukan hash terhadap mereka.

316
00:14:45,450 --> 00:14:46,030
Baik.

317
00:14:46,030 --> 00:14:46,530
Oke.

318
00:14:46,530 --> 00:14:49,620
Jadi Anda mengatakan, baik,
ya, kunci publik berukuran 32 byte.

319
00:14:49,620 --> 00:14:52,050
Baik, anda hanya
berkomitmen pada kunci publik

320
00:14:52,050 --> 00:14:54,570
dengan hasil hash dari
seluruh hal tersebut, bukan?

321
00:14:54,570 --> 00:15:02,040
Dan saya katakan, baik, saya mendapatkan
16 kilobyte dari kunci publik.

322
00:15:02,040 --> 00:15:04,580
Saya baru saja meng-hash itu, bukan?

323
00:15:04,580 --> 00:15:09,600
Dan sekarang saya mempunyai sebuah
kunci publik berukuran 32 byte.

324
00:15:09,600 --> 00:15:11,240
Dan saya telah berkomitmen.

325
00:15:11,240 --> 00:15:12,000
Itu bekerja, bukan?

326
00:15:12,000 --> 00:15:14,160
Saya telah berkomitmen ke kunci publik saya.

327
00:15:14,160 --> 00:15:19,990
Namun, ketika saya menandatangani, saya perlu
menyediakan seluruh kunci publik

328
00:15:19,990 --> 00:15:21,570
agar Anda dapat memverifikasinya.

329
00:15:21,570 --> 00:15:25,150
Saya perlu menyediakan  
16 kunci publik orisinal ini,

330
00:15:25,150 --> 00:15:27,620
versi orisinal kunci publik,
setelah saya menandatanganinya.

331
00:15:27,620 --> 00:15:34,880
Jadi sekarang tanda tangan saya berbubah
dari 8K menjadi, berapa, 24K.

332
00:15:34,880 --> 00:15:38,530
Jadi saya belum membuatnya 
menjadi lebih efisien, ya,

333
00:15:38,530 --> 00:15:42,840
dalam hal totalnya terhadap
kunci publik dan tandatangan

334
00:15:42,840 --> 00:15:44,680
tetap berukuran sama--

335
00:15:44,680 --> 00:15:46,660
sebenarnya, sedikit lebih besar.

336
00:15:46,660 --> 00:15:48,220
Tapi ini semacam permainan.

337
00:15:48,220 --> 00:15:53,260
Karena kunci publik 
itu, mungkin

338
00:15:53,260 --> 00:15:56,050
seperti saya menunjukkan itu 
kepada Anda sebelumnya,

339
00:15:56,050 --> 00:15:57,695
dan ruang penyimpanan kita
terbatas di sana.

340
00:15:57,695 --> 00:15:59,320
Kemudian, ketika saya
melakukan tanda tangan,

341
00:15:59,320 --> 00:16:01,960
saya memiliki lebih banyak ruang
atau waktu atau semacamnya.

342
00:16:01,960 --> 00:16:03,250
Jadi ini sebenarnya berguna.

343
00:16:03,250 --> 00:16:05,020
Dan sebenarnya,
teknik ini digunakan

344
00:16:05,020 --> 00:16:09,400
dalam Bitcoin dan bermacam-macam
mata uang kripto

345
00:16:09,400 --> 00:16:12,220
di mana Anda dapat menyebut ini
sebagai hash kunci publik--

346
00:16:17,660 --> 00:16:21,300
hash kunci publik, atau mereka mengatakan PKH.

347
00:16:21,300 --> 00:16:23,562
Dan keuntungan utamanya
adalah ukuran, benar?

348
00:16:23,562 --> 00:16:25,770
Anda dapat mengatakan, yah, jika saya
memiliki kunci publik yang sangat besar

349
00:16:25,770 --> 00:16:29,040
saya dapat berkomitmen untuk itu dengan mengirimkan
ke hash dari kunci publik

350
00:16:29,040 --> 00:16:31,230
Dan kemudian, ketika saya
ingin menandatangani,

351
00:16:31,230 --> 00:16:33,780
saya mengungkapkan kunci publik yang sebenarnya.

352
00:16:33,780 --> 00:16:35,020
Anda bisa melakukannya dengan cara itu.

353
00:16:35,020 --> 00:16:35,520
Oke.

354
00:16:35,520 --> 00:16:38,370
Jadi ini
cukup keren, bukan?

355
00:16:38,370 --> 00:16:42,840
Kita sekarang telah mengubah sistem kita,
yang memiliki kunci privat cukup besar--

356
00:16:42,840 --> 00:16:45,660
16 kilobyte--,
mengubahnya

357
00:16:45,660 --> 00:16:47,010
menjadi kunci privat berukuran 32 byte.

358
00:16:47,010 --> 00:16:47,610
Bagus.

359
00:16:47,610 --> 00:16:50,970
Dan juga, ini adalah 0
dari 1-- tidak pernah berkembang.

360
00:16:50,970 --> 00:16:52,050
Hebat.

361
00:16:52,050 --> 00:16:55,680
Kita telah mengambil sistem dengan
besar, berpotensi besar--

362
00:16:55,680 --> 00:16:59,130
32 kilobyte, 64
kilobyte-- kunci publik

363
00:16:59,130 --> 00:17:01,080
Kami telah menguranginya menjadi 32 byte

364
00:17:01,080 --> 00:17:01,630
Hebat.

365
00:17:01,630 --> 00:17:02,130
Oke.

366
00:17:02,130 --> 00:17:05,579
Kami sekarang telah membuat hal ini
jauh lebih efisien, jauh lebih

367
00:17:05,579 --> 00:17:06,450
berguna.

368
00:17:06,450 --> 00:17:08,880
Masalahnya--
tanda tangannya masih besar.

369
00:17:08,880 --> 00:17:11,250
Mereka sebenarnya
menjadi sedikit lebih besar

370
00:17:11,250 --> 00:17:14,490
karena menyertakan kunci
publik lengkap dalam tanda tangan.

371
00:17:14,490 --> 00:17:17,940
Dan katakanlah kita memiliki
salah satu dari hal-hal ini,

372
00:17:17,940 --> 00:17:20,190
di mana kita membuat
sekumpulan kunci publik

373
00:17:20,190 --> 00:17:22,109
dan berkomitmen untuk itu
sejak awal.

374
00:17:22,109 --> 00:17:25,890
Jadi Anda berkata, oke, saya punya
kunci publik berukuran 64 kilobyte.

375
00:17:25,890 --> 00:17:28,410
Saya dapat berkomitmen untuk
semuanya dengan melakukan hash.

376
00:17:28,410 --> 00:17:32,460
Namun, kemudian, ketika saya mengungkapkannya dan
ingin memberi Anda tanda tangan,

377
00:17:32,460 --> 00:17:37,050
tanda tangan saya sekarang
menjadi apa saja--

378
00:17:37,050 --> 00:17:38,600
72, bukan?

379
00:17:38,600 --> 00:17:41,820
Tanda tangannya akan
menjadi 72 kilobyte--

380
00:17:41,820 --> 00:17:45,090
sangat besar.

381
00:17:45,090 --> 00:17:48,570
Jadi saya bisa menambahkan banyak
kunci, tapi saya hanya

382
00:17:48,570 --> 00:17:50,700
memindahkan masalahnya
ke tempat lain--

383
00:17:50,700 --> 00:17:52,680
di dalam tanda tangan, bukan?

384
00:17:52,680 --> 00:17:55,920
Ada cara yang lebih baik
untuk berkomitmen ke banyak kunci publik.

385
00:17:55,920 --> 00:17:59,820
Ini mungkin tidak terlalu jelas
kecuali Anda pernah melihat sebelumnya.

386
00:17:59,820 --> 00:18:01,990
Tapi jika sudah,
tahukah Anda apa

387
00:18:01,990 --> 00:18:05,682
cara yang lebih baik untuk berkomitmen
pada banyak kunci publik?

388
00:18:05,682 --> 00:18:07,390
Atau Anda bisa
langsung memikirkannya

389
00:18:07,390 --> 00:18:09,265
dan itu akan seperti, wow,
Anda seharusnya

390
00:18:09,265 --> 00:18:12,610
menamai barang ini dengan nama Anda.

391
00:18:12,610 --> 00:18:13,730
Ada ide?

392
00:18:13,730 --> 00:18:15,010
Oke.

393
00:18:15,010 --> 00:18:17,140
Jadi apa yang dapat Anda lakukan--

394
00:18:17,140 --> 00:18:19,000
sedikit tidak jelas--

395
00:18:19,000 --> 00:18:21,100
Anda dapat membuat pohon, bukan?

396
00:18:21,100 --> 00:18:23,860
Jadi idenya adalah alih-alih
hanya mengatakan,

397
00:18:23,860 --> 00:18:28,090
oh, saya akan mengambil
empat kunci publik besar saya,

398
00:18:28,090 --> 00:18:31,240
memasukkan semuanya dalam satu baris, mengambil
hash dari semuanya

399
00:18:31,240 --> 00:18:33,610
dan mempublikasikannya
sebagai hash publik saya,

400
00:18:33,610 --> 00:18:36,790
saya akan meiliki desain yang
sedikit lebih rumit.

401
00:18:36,790 --> 00:18:40,860
Dan desain itu
adalah pohon biner.

402
00:18:40,860 --> 00:18:41,690
OK.

403
00:18:41,690 --> 00:18:46,220
Jadi idenya adalah ini empat
kunci publik milik saya yang masing-masing

404
00:18:46,220 --> 00:18:47,510
membutuhkan 64K.

405
00:18:47,510 --> 00:18:49,550
Saya bisa membuat
hash-hash penengah ini.

406
00:18:49,550 --> 00:18:52,310
Jadi saya membuat sebuah pohon biner
di mana saya bilang, OK, ini

407
00:18:52,310 --> 00:18:56,570
adalah hash dari dua kunci
pertama yang saling menempel

408
00:18:56,570 --> 00:19:00,820
Ini adalah hash dari dua kunci
kedua yang saling menempel

409
00:19:00,820 --> 00:19:04,420
Bagian atas adalah hash dari
dua hash penengah ini

410
00:19:04,420 --> 00:19:06,790
yang ditempelkan.

411
00:19:06,790 --> 00:19:10,510
Dan kemudian, bagian atas
adalah akar saya, yang

412
00:19:10,510 --> 00:19:12,760
setara dengan hash pubkey saya.

413
00:19:12,760 --> 00:19:17,440
Jadi saya bisa mencetak ini,
dan itu membuat saya berkomitmen pada

414
00:19:17,440 --> 00:19:20,020
keempat kunci publik saya.

415
00:19:20,020 --> 00:19:24,580
Jadi mungkin tidak terlalu terlihat jelas.

416
00:19:24,580 --> 00:19:26,410
Apakah anda melihat 
keuntungan yang bisa didapat

417
00:19:26,410 --> 00:19:29,530
jika dibandingkan dengan sekedar
menggabungkan keempat kuncinya

418
00:19:29,530 --> 00:19:30,730
dan melakukan hashing terhadapnya?

419
00:19:30,730 --> 00:19:31,040
Ya?

420
00:19:31,040 --> 00:19:31,998
AUDIENS: Saya bingung.

421
00:19:31,998 --> 00:19:33,970
Dimana kunci privat milik 
Anda dalam hal ini?

422
00:19:33,970 --> 00:19:36,620
TADGE DRYJA: Kunci privatnya 
ada di sini, bukan?

423
00:19:36,620 --> 00:19:38,060
Kunci privatnya tidak ditampilkan.

424
00:19:38,060 --> 00:19:39,820
Tapi saya punya kunci privat.

425
00:19:39,820 --> 00:19:42,123
Itu berubah menjadi pubkey ini.

426
00:19:42,123 --> 00:19:43,540
Dan kita bisa menggunakan 
teknik ini.

427
00:19:43,540 --> 00:19:47,650
di mana kita baru saja memiliki, sungguh,
satu kunci privat berukuran 32 byte

428
00:19:47,650 --> 00:19:51,310
dan membuat semua potongan yang 
berbeda dari kunci-kunci publik

429
00:19:51,310 --> 00:19:54,100
dengan menyatukan 
indeks yang berbeda.

430
00:19:54,100 --> 00:19:54,600
Ya?

431
00:19:54,600 --> 00:19:57,880
AUDIENS: Anda bisa melakukan [Tidak Terdengar]
sistem-sistem dan waktu log-in sebagai gantinya

432
00:19:57,880 --> 00:19:59,120
dari waktu linier.

433
00:19:59,120 --> 00:20:00,710
TADGE DRYJA: Iya, betul.

434
00:20:00,710 --> 00:20:04,880
Saya bisa buktikan itu, hei,
ini adalah kunci publik 0, yang

435
00:20:04,880 --> 00:20:10,910
ada di sini, hash akar ini, dan
saya tidak harus mengungkapkan keempatnya,

436
00:20:10,910 --> 00:20:12,130
untuk melakukannya.

437
00:20:12,130 --> 00:20:13,370
Jadi iya.

438
00:20:13,370 --> 00:20:15,640
Apakah yang lain punya,
mungkin, ide yang sama?

439
00:20:15,640 --> 00:20:16,500
Iya, OK.

440
00:20:16,500 --> 00:20:17,000
OK.

441
00:20:17,000 --> 00:20:19,610
Jadi bagaimana kita melakukannya?

442
00:20:22,210 --> 00:20:23,070
Anda jelas tahu.

443
00:20:23,070 --> 00:20:23,670
Ada lagi?

444
00:20:23,670 --> 00:20:24,820
Iya.

445
00:20:24,820 --> 00:20:27,440
AUDIENS: Jadi dengan asumsi bahwa Anda
menginginkan kunci publik 0,

446
00:20:27,440 --> 00:20:31,680
Anda akan mempublikasikan itu dan
1, dan juga hash dari 2, 3. 

447
00:20:31,680 --> 00:20:33,150
TADGE DRYJA: Betul, iya.

448
00:20:33,150 --> 00:20:35,800
Dan kemudian Anda bisa
membuktikan sampai ke atas.

449
00:20:35,800 --> 00:20:37,230
Jadi, saya mempunyai beberapa warna kecil.

450
00:20:37,230 --> 00:20:43,740
Idenya adalah sang verifikator
yang tugasnya melakukan verifikasi tanda tangan,

451
00:20:43,740 --> 00:20:46,680
ia sudah tahu
akarnya, kan?

452
00:20:46,680 --> 00:20:49,130
Karena Anda telah mempublikasikan sebelumnya
bahwa itu adalah kunci publik anda,

453
00:20:49,130 --> 00:20:51,450
sebagai kunci publik akar
dan kunci publik hash Anda.

454
00:20:51,450 --> 00:20:54,300
Kemudian verifikator
juga diberikan

455
00:20:54,300 --> 00:20:57,390
kunci publik 0 yang berkata,
hei, ini tanda tangannya.

456
00:20:57,390 --> 00:20:58,510
Ini pesannya.

457
00:20:58,510 --> 00:21:00,870
Ini adalah kunci publik 0.

458
00:21:00,870 --> 00:21:02,460
Jadi Anda mendapatkan kedua
benda tersebut.

459
00:21:02,460 --> 00:21:07,650
Sekarang, sang pembukti perlu
membuktikan bahwa kunci publik 0

460
00:21:07,650 --> 00:21:09,870
terkandung di dalam akarnya.

461
00:21:09,870 --> 00:21:13,860
Dan untuk melakukan hal tersebut, hanya 2
hal, untuk sang pembukti butuh tambahkan

462
00:21:13,860 --> 00:21:16,380
adalah publ--

463
00:21:16,380 --> 00:21:21,510
OK, jadi sang pembukti mengatakan,
ini kunci publik 1.

464
00:21:21,510 --> 00:21:25,770
Itu mengizinkan sang verifikator
untuk menghitung ini.

465
00:21:25,770 --> 00:21:27,510
Dan kemudian sang pembukti
mengatakan, hei, ini

466
00:21:27,510 --> 00:21:32,190
hash 2, 3, yang mengizinkan
verifikator untuk menghitung akarnya

467
00:21:32,190 --> 00:21:33,800
dan kemudian memeriksa apakah itu sama.

468
00:21:33,800 --> 00:21:36,300
Jadi, Anda hanya membutuhkan dua
hash tambahan daripada empat.

469
00:21:36,300 --> 00:21:39,127
Jadi menghemat sebagian ruang.

470
00:21:39,127 --> 00:21:41,460
Itu tidak menghemat sebegitu banyak
ruang ketika Anda hanya memiliki empat.

471
00:21:41,460 --> 00:21:45,540
Itu menghemat banyak ruang
ketika Anda memiliki 1.000, kan?

472
00:21:45,540 --> 00:21:49,050
Jadi Anda dapat menambahkan 0 dari n elemen.

473
00:21:49,050 --> 00:21:51,330
Dan ukuran akar
tetap sama.

474
00:21:51,330 --> 00:21:53,190
Akar tersebut akan tetap 
berukuran 32 byte, terlepas dari

475
00:21:53,190 --> 00:21:56,000
berapa banyak node daun yang kamu miliki.

476
00:21:56,000 --> 00:21:58,110
Dan Anda dapat membuktikan
sebuah elemen dengan log n--

477
00:21:58,110 --> 00:22:00,176
oh, tanda kurung tersebut
salah--

478
00:22:00,176 --> 00:22:02,340
0 log n hash penengah.

479
00:22:02,340 --> 00:22:06,510
Jadi bila Anda memiliki 1.000 kunci,
akar kamu tetap berukuran 32 bytes,

480
00:22:06,510 --> 00:22:10,830
dan bukti Anda akan menjadi
tidak terlalu besar, bukan--

481
00:22:10,830 --> 00:22:15,000
320 bytes lebih,
yang berarti lebih kecil dari

482
00:22:15,000 --> 00:22:17,550
tanda tangan, bukan?

483
00:22:17,550 --> 00:22:18,580
Jadi ini sangat keren.

484
00:22:18,580 --> 00:22:21,450
Dan Anda dapat menggunakan ini
dengan lebih praktis

485
00:22:21,450 --> 00:22:24,150
dibandingkan dengan tanda tangan
lamport sederhana yang

486
00:22:24,150 --> 00:22:25,680
berada di kumpulan masalah pertama.

487
00:22:25,680 --> 00:22:29,760
Karena itu, bila
Anda hanya melakukan

488
00:22:29,760 --> 00:22:32,640
satu kunci dan satu tanda tangan,
ukurannya akan kurang lebih sama.

489
00:22:32,640 --> 00:22:34,920
Tetapi ini membuat kamu
dapat menggunakannya berkali-kali,

490
00:22:34,920 --> 00:22:37,230
memungkinkan Anda menyimpan kunci privat
yang lebih kecil,

491
00:22:37,230 --> 00:22:39,180
berkomitmen kepada kunci publik
yang jauh lebih kecil.

492
00:22:39,180 --> 00:22:40,740
Ini adalah sistem yang lebih dapat digunakan.

493
00:22:40,740 --> 00:22:46,072
Meski demikian tanda tangan itu
masih cukup besar, bukan?

494
00:22:46,072 --> 00:22:48,030
Tanda tangan Anda akan 
menjadi lebih dari 8

495
00:22:48,030 --> 00:22:49,620
kilobytes, cukup oke, bukan?

496
00:22:49,620 --> 00:22:51,690
Komputer dapat menangani
8 kilobytes.

497
00:22:51,690 --> 00:22:55,230
Itu disebut sebagai pohon
Merkle yang dibuat oleh Ralph Merkle

498
00:22:55,230 --> 00:22:58,680
pada sekitar tahun 1976.

499
00:22:58,680 --> 00:23:01,820
Dan itu awalnya dibuat
tepat untuk tujuan itu.

500
00:23:01,820 --> 00:23:04,900
Bagaimanapun, jadi ini 
disebut pohon Merkle.

501
00:23:04,900 --> 00:23:07,120
Ralph Merkle.

502
00:23:07,120 --> 00:23:09,025
Pada saat ini, dia tidak benar-benar
bekerja pada bidang kriptografi.

503
00:23:09,025 --> 00:23:11,590
Dia bekerja pada bidang
bioteknologi sekarang, Saya kira.

504
00:23:11,590 --> 00:23:12,456
Bagaimanapun.

505
00:23:12,456 --> 00:23:14,013
Tapi dia keren.

506
00:23:14,013 --> 00:23:15,930
Dan dia mendapatkan, seperti,
semuanya dinamai menurut namanya.

507
00:23:15,930 --> 00:23:18,190
Jadi Anda akan melihat
kata Merkle dimana pun.

508
00:23:18,190 --> 00:23:21,160
Dan itu, Anda tahu, dia
menemukan sesuatu yang keren.

509
00:23:21,160 --> 00:23:21,873
Hebat.

510
00:23:21,873 --> 00:23:23,290
Ini adalah
salah satu hal,

511
00:23:23,290 --> 00:23:24,490
meskipun, dimana itu
sepertinya, ya,

512
00:23:24,490 --> 00:23:25,950
Saya mungkin bisa
memikirkan itu, kan?

513
00:23:25,950 --> 00:23:28,270
Ini semacam pohon 
biner dan fungsi hash.

514
00:23:28,270 --> 00:23:30,560
Tidak ada hal yang gila.

515
00:23:30,560 --> 00:23:32,710
Tapi jadi ada 
banyak jenis pohon Merkle.

516
00:23:32,710 --> 00:23:35,440
Anda bisa membuat hal yang berbeda.

517
00:23:35,440 --> 00:23:36,330
Hal itu digunakan pada Bitcoin.

518
00:23:36,330 --> 00:23:39,520
Hal ini digunakan di banyak
mata uang kripto yang berbeda.

519
00:23:39,520 --> 00:23:40,750
Oh, keren.

520
00:23:40,750 --> 00:23:46,060
Ini cara yang sangat ampuh 
untuk mengambil dalam jumlah banyak

521
00:23:46,060 --> 00:23:48,770
dari hal yang berbeda dan memberikan
kepada mereka dalam satu hal kecil.

522
00:23:48,770 --> 00:23:49,270
OK.

523
00:23:49,270 --> 00:23:50,530
Jadi ini sangat keren.

524
00:23:50,530 --> 00:23:52,360
Tapi kita bisa melakukannya lebih baik.

525
00:23:52,360 --> 00:23:54,820
Hal selanjutnya adalah 
hal-hal yang pasti

526
00:23:54,820 --> 00:23:58,180
tidak pernah terpikirkan 
oleh saya karena ini jauh lebih

527
00:23:58,180 --> 00:24:00,400
kompleks dari sekedar, seperti,
hei, mari kita gunakan pohon biner

528
00:24:00,400 --> 00:24:02,530
dengan hash.

529
00:24:02,530 --> 00:24:05,260
Dan saya akan menyebutkan
RSA dan kemudian masuk

530
00:24:05,260 --> 00:24:10,510
ke ECDSA dan tanda tangan
[TIDAK TERDENGAR] kurva elips, yang

531
00:24:10,510 --> 00:24:15,012
melakukan hal berbeda dan tidak
didasarkan pada fungsi hash saja.

532
00:24:15,012 --> 00:24:16,720
Jadi saya akan berbicara tentang
RSA selama beberapa menit,

533
00:24:16,720 --> 00:24:19,067
dan kemudian kita akan jeda
sebentar, seperti istirahat.

534
00:24:19,067 --> 00:24:20,900
Dan kemudian kita akan membahas
hal-hal tentang kurva elips.

535
00:24:20,900 --> 00:24:21,400
Oke.

536
00:24:21,400 --> 00:24:23,260
Jadi RSA ditemukan oleh warga MIT.

537
00:24:23,260 --> 00:24:24,790
R adalah Ron--

538
00:24:24,790 --> 00:24:26,290
tidak, saya pikir R
adalah singkatan dari Rivest,

539
00:24:26,290 --> 00:24:29,870
tetapi Ron Rivest ada di
CSAIL, dan dia masih

540
00:24:29,870 --> 00:24:32,230
mengerjakan hal-hal terkait kripto yang keren.

541
00:24:32,230 --> 00:24:34,960
Ini tidak digunakan dalam Bitcoin
atau mata uang apa pun, sebenarnya--

542
00:24:34,960 --> 00:24:38,560
yah, apa pun mata uang kripto 
yang beroperasi saat ini.

543
00:24:38,560 --> 00:24:42,880
Karena tanda tangan
dan kunci

544
00:24:42,880 --> 00:24:45,550
sedikit lebih besar daripada
sistem yang akan kita lihat nanti--

545
00:24:45,550 --> 00:24:50,500
lebih kecil dari hal berbasis 
hash, tetapi masih sedikit lebih besar.

546
00:24:50,500 --> 00:24:52,420
Digunakan dalam kas chaumian
buta.

547
00:24:52,420 --> 00:24:55,070
Karena Anda dapat melakukan tanda 
tangan buta, di mana Anda berkata,

548
00:24:55,070 --> 00:24:58,272
Oke, saya akan meminta Anda
menandatangani sesuatu untuk saya,

549
00:24:58,272 --> 00:24:59,980
dan kemudian setelah Anda
memberi saya tanda tangan,

550
00:24:59,980 --> 00:25:04,000
saya dapat memisahkan tanda tangannya.

551
00:25:04,000 --> 00:25:05,650
Karena saya akan meminta
Anda menandatangani sesuatu

552
00:25:05,650 --> 00:25:07,870
yang Anda tidak tahu apa yang
Anda tanda tangani, bukan?

553
00:25:07,870 --> 00:25:10,630
Saya akan menutupi pesan
ini dan membutakannya

554
00:25:10,630 --> 00:25:12,550
sehingga Anda menandatangani
pesan, dan kemudian saya 

555
00:25:12,550 --> 00:25:15,310
bisa mendapatkan tanda tangan Anda
pada pesan yang sebenarnya

556
00:25:15,310 --> 00:25:17,080
tanpa Anda tahu
apa yang Anda tanda tangani.

557
00:25:17,080 --> 00:25:19,540
Jadi pada dasarnya, idenya
adalah, saya sebenarnya

558
00:25:19,540 --> 00:25:26,230
memiliki pesan aksen sama dengan
pesan ditambah keacakan.

559
00:25:26,230 --> 00:25:28,210
Dan saya katakan, hei, bisakah
Anda menandatangani m aksen?

560
00:25:28,210 --> 00:25:28,990
Dan anda berkata, oke.

561
00:25:28,990 --> 00:25:33,970
Saya membuat tanda tangan di m
aksen dengan kunci privat saya.

562
00:25:33,970 --> 00:25:36,370
Dan kita akan menyebutnya s aksen.

563
00:25:36,370 --> 00:25:41,420
Dan kemudian yang bisa saya lakukan
adalah saya bisa s sama dengan s aksen

564
00:25:41,420 --> 00:25:45,050
dikurangi keacakan,
atau, sebenarnya, beberapa fungsi

565
00:25:45,050 --> 00:25:46,520
dari keacakan itu.

566
00:25:46,520 --> 00:25:48,240
Dan sekarang saya punya tanda tangan.

567
00:25:48,240 --> 00:25:51,530
Dan ini adalah tanda 
tangan yang sah di m.

568
00:25:51,530 --> 00:25:52,760
Jadi itu keren.

569
00:25:52,760 --> 00:25:54,802
Ini seperti, hei, bisakah Anda
menandatangani pesan ini untuk saya?

570
00:25:54,802 --> 00:25:57,670
Dan kami tidak akan memberi tahu
Anda apa yang Anda tanda tangani.

571
00:25:57,670 --> 00:25:59,420
Itu sepertinya tidak berguna,
seperti mengapa saya

572
00:25:59,420 --> 00:26:01,430
menandatangani sesuatu yang saya tidak
tahu apa yang saya tanda tangani?

573
00:26:01,430 --> 00:26:05,180
Tapi itu bisa digunakan dalam
kas buta chaumian itu.

574
00:26:05,180 --> 00:26:08,150
Karena saya kemudian memiliki bukti
bahwa, yah, bank ini tidak

575
00:26:08,150 --> 00:26:10,550
tahu apa yang mereka tanda tangani,
tetapi mereka menandatanganinya,

576
00:26:10,550 --> 00:26:13,550
dan ini adalah tanda tangan mereka,
dan mereka memberikannya kepada saya.

577
00:26:13,550 --> 00:26:17,090
Dan saya bisa menggunakannya sebagai
benda untuk mewakili uang.

578
00:26:17,090 --> 00:26:19,340
Ada banyak hal keren
yang dapat Anda lakukan dengan ini.

579
00:26:19,340 --> 00:26:24,890
Pengaturan dasar RSA adalah membuat
dua bilangan prima, p dan q.

580
00:26:24,890 --> 00:26:28,880
Dan kemudian hitung n, yang
merupakan hasil dari p kali q.

581
00:26:28,880 --> 00:26:31,400
Jadi ini tampaknya cukup
mudah, bukan?

582
00:26:31,400 --> 00:26:32,660
Ini tidak terlalu sulit.

583
00:26:32,660 --> 00:26:34,583
Semua orang tahu apa itu
bilangan prima.

584
00:26:34,583 --> 00:26:36,500
Sekarang Anda memiliki bilangan 
komposit ini, p dikali q.

585
00:26:39,470 --> 00:26:43,040
Bagaimana cara membuat pertanyaan
penuntun untuk slide berikutnya?

586
00:26:43,040 --> 00:26:46,532
Apakah ini ada hubungannya dengan
hal-hal yang telah kita lihat?

587
00:26:46,532 --> 00:26:48,740
Ini sama sekali tidak terlihat
seperti fungsi hash, bukan?

588
00:26:48,740 --> 00:26:51,080
Tetapi apakah ada properti yang
mirip dengan fungsi hash di

589
00:26:51,080 --> 00:26:51,580
sini?

590
00:26:54,230 --> 00:26:55,995
Ya?

591
00:26:55,995 --> 00:26:57,620
AUDIENS: Sulit
untuk mengarahkan gambar.

592
00:26:57,620 --> 00:26:58,860
Sulit untuk [TIDAK TERDENGAR].

593
00:26:58,860 --> 00:26:59,700
TADGE DRYJA: Ya.

594
00:26:59,700 --> 00:27:02,570
Ini adalah fungsi satu arah
di mana jika saya tahu p dan q,

595
00:27:02,570 --> 00:27:04,610
saya bisa menghitung n, bukan?

596
00:27:04,610 --> 00:27:08,810
Tapi diberikan n, saya tidak bisa
menemukan p dan q, bukan?

597
00:27:08,810 --> 00:27:10,760
Jika mereka kecil,
tentu, saya periksa saja.

598
00:27:10,760 --> 00:27:14,150
Dan ada berbagai macam
algoritma untuk menemukan faktor.

599
00:27:14,150 --> 00:27:18,020
Tetapi jika p dan q cukup besar,
seperti ratusan bit panjangnya

600
00:27:18,020 --> 00:27:20,690
atau ribuan
bit panjangnya, mencari n

601
00:27:20,690 --> 00:27:24,380
mungkin tidak dapat dilakukan, sedangkan
jika p dan q sangat panjang,

602
00:27:24,380 --> 00:27:27,170
mencari hasil perkalian keduanya
akan sangat mudah dilakukan.

603
00:27:27,170 --> 00:27:31,950
Sekalipun besar, mengalikan
dua bilangan bulat sangat mudah.

604
00:27:31,950 --> 00:27:34,880
Jadi ini adalah fungsi satu arah
tetapi bukan fungsi hash.

605
00:27:34,880 --> 00:27:38,540
Dan banyak sistem tanda tangan
ini menggunakan fungsi satu arah,

606
00:27:38,540 --> 00:27:41,810
tetapi fungsi satu arah yang lebih rumit
yang bukan fungsi hash,

607
00:27:41,810 --> 00:27:45,810
dan masih memiliki hal-hal
keren yang dapat Anda lakukan.

608
00:27:45,810 --> 00:27:49,760
Jadi saya tidak akan membahas
RSA secara sangat detil.

609
00:27:49,760 --> 00:27:51,917
Saya akan membahasnya
dengan sangat cepat,

610
00:27:51,917 --> 00:27:53,750
dan Anda akan seperti,
huh, bagaimana cara kerjanya?

611
00:27:53,750 --> 00:27:56,230
Tapi jika menurut kalian itu
menarik, kalian bisa mencarinya

612
00:27:56,230 --> 00:27:57,980
dan mungkin kalian pergi
ke CSAIL dan bertanya kepada Ron

613
00:27:57,980 --> 00:28:00,350
bagaimana cara kerjanya, walaupun mungkin
coba cari dulu.

614
00:28:00,350 --> 00:28:02,100
Dia mungkin sering menjelaskannya
berkali-kali.

615
00:28:04,880 --> 00:28:06,600
Tetapi itu memiliki sifat yang berbeda.

616
00:28:06,600 --> 00:28:09,050
Jadi bisa dibilang, saya
akan menggunakan p kali

617
00:28:09,050 --> 00:28:12,440
q sama dengan n ini sebagai fungsi hash
dan membuat tanda tangan lamport

618
00:28:12,440 --> 00:28:16,850
darinya di mana kunci pribadi saya
adalah sekelompok besar pasangan p dan q,

619
00:28:16,850 --> 00:28:20,000
dan kunci publik saya adalah
sekelompok besar n, dan saya

620
00:28:20,000 --> 00:28:21,590
mengungkapkannya dan sebagainya.

621
00:28:21,590 --> 00:28:22,460
Anda bisa melakukan itu.

622
00:28:22,460 --> 00:28:24,350
Itu akan berhasil.

623
00:28:24,350 --> 00:28:26,240
Tetapi Anda dapat melakukan hal-hal 
yang jauh lebih hebat

624
00:28:26,240 --> 00:28:29,360
karena sifat matematika
dari hal-hal ini.

625
00:28:29,360 --> 00:28:32,590
Jadi ya, saya akan
membahasnya dengan sangat cepat.

626
00:28:32,590 --> 00:28:35,480
Tetapi jika Anda tahu sesuatu,
ini cukup keren

627
00:28:35,480 --> 00:28:40,730
Idenya adalah Anda dapat melakukan
banyak perkalian

628
00:28:40,730 --> 00:28:43,580
dan modulo eksponensial n.

629
00:28:43,580 --> 00:28:47,810
Dan karena n
hampir bilangan prima,

630
00:28:47,810 --> 00:28:49,640
ada beberapa
properti menarik,

631
00:28:49,640 --> 00:28:53,180
dimana jika Anda mengetahui
faktor dari n,

632
00:28:53,180 --> 00:28:54,965
Anda memiliki jalan pintas ini
yang dapat Anda lakukan.

633
00:28:54,965 --> 00:28:56,840
Dan seseorang yang tidak
mengetahui faktor n

634
00:28:56,840 --> 00:28:58,290
tidak dapat melakukan jalan pintas ini.

635
00:28:58,290 --> 00:29:02,090
Jadi Anda mempublikasikan e, yang merupakan
konstanta-- ini semacam

636
00:29:02,090 --> 00:29:04,490
sebuah parameter sistem.

637
00:29:04,490 --> 00:29:06,560
Jadi RSA digunakan hari ini di
semua tempat.

638
00:29:06,560 --> 00:29:08,780
Jika komputer Anda
terbuka dan Anda telah

639
00:29:08,780 --> 00:29:10,670
menggunakan web dalam
lima detik terakhir,

640
00:29:10,670 --> 00:29:14,030
komputer Anda sudah
melakukan perhitungan RSA.

641
00:29:14,030 --> 00:29:18,380
Setiap kali Anda terhubung ke sebuah
situs web, anda melakukan RSA.

642
00:29:18,380 --> 00:29:21,202
Jadi umumnya, 65537.

643
00:29:21,202 --> 00:29:22,160
Mereka hanya membuatnya asal.

644
00:29:22,160 --> 00:29:25,800
Anda juga dapat menggunakan
tiga-- angka kecil tertentu.

645
00:29:25,800 --> 00:29:28,670
Dan kemudian d adalah angka
yang dapat Anda hitung

646
00:29:28,670 --> 00:29:30,530
jika Anda tahu apa itu p dan q.

647
00:29:30,530 --> 00:29:34,040
Jadi ini semacam 
kunci privat, bukan?

648
00:29:34,040 --> 00:29:36,740
p dan q sendiri dapat 
dilihat sebagai kunci privat.

649
00:29:36,740 --> 00:29:39,080
Tapi sebenarnya Anda bisa 
menghitung angka d ini

650
00:29:39,080 --> 00:29:43,100
dan kemudian membuang p dan q.

651
00:29:43,100 --> 00:29:45,320
Dan ini merupakan cara bagaimana Anda 
menghitung d atau apa pun.

652
00:29:45,320 --> 00:29:49,490
Tapi idenya adalah n adalah kunci publik
Anda, dan d adalah kunci privat Anda.

653
00:29:49,490 --> 00:29:52,430
e selalu sama, dan p dan 
q, Anda dapat membuangnya setelahnya

654
00:29:52,430 --> 00:29:53,740
Lalu apa yang dapat Anda lakukan--

655
00:29:53,740 --> 00:29:58,020
dan tidak akan membahasnya lebih dalam-- 
tetapi Anda dapat berkata, Oke,

656
00:29:58,020 --> 00:30:00,590
tanda tangan s saya adalah 
pesan, kan--

657
00:30:00,590 --> 00:30:03,065
Saya bisa mengambil hashnya 
dan membuat pesan m--

658
00:30:03,065 --> 00:30:06,830
pesan untuk d pangkat modulo n.

659
00:30:06,830 --> 00:30:10,940
Dan jika saya memverifikasi, jika saya mengambil 
tanda tangan dan memangkatkannya dengan e dan modulo

660
00:30:10,940 --> 00:30:13,040
n, itu harus sama dengan
m lagi, yang mana

661
00:30:13,040 --> 00:30:16,760
gila dan luar biasa.

662
00:30:16,760 --> 00:30:18,530
Karena idenya adalah 
untuk menandatangani, oke, saya

663
00:30:18,530 --> 00:30:20,660
cukup memangkatkannya
dengan d modulo n.

664
00:30:20,660 --> 00:30:24,620
Ini akan menjadi beberapa angka
dengan ukuran yang sama dengan n, kan?

665
00:30:24,620 --> 00:30:27,230
Dan kemudian saya memberikan itu kepada seseorang.

666
00:30:27,230 --> 00:30:32,750
Mereka mengambil tanda tangan itu 
ke 65537 pangkat modulo

667
00:30:32,750 --> 00:30:35,480
m lagi dan lihat apakah m--

668
00:30:35,480 --> 00:30:36,800
pesannya-- keluar kembali.

669
00:30:36,800 --> 00:30:39,260
Dan jika ya,
mereka tahu saya menandatangani,

670
00:30:39,260 --> 00:30:43,580
dan saya memiliki kunci
privat yang sesuai dengan n.

671
00:30:43,580 --> 00:30:47,240
Sekarang, hal kerennya adalah saya bisa
menggunakan ini beberapa kali.

672
00:30:47,240 --> 00:30:50,630
Saya dapat menggunakan hal yang
sama jutaan kali

673
00:30:50,630 --> 00:30:54,890
dengan m yang berbeda, dan
itu tidak memberikan bantuan apa pun

674
00:30:54,890 --> 00:30:58,520
tentang cara memfaktorkan n
atau cara menghitung d.

675
00:30:58,520 --> 00:31:04,320
Jadi ini akhir tahun 70-an, juga,
RSA, dan salah satu yang pertama,

676
00:31:04,320 --> 00:31:07,430
hei, kita bisa melakukan lebih baik
daripada fungsi hash.

677
00:31:07,430 --> 00:31:11,060
Ini dikembangkan
sekitar waktu yang sama

678
00:31:11,060 --> 00:31:12,800
dengan tanda tangan berbasis hash.

679
00:31:12,800 --> 00:31:15,830
Semua hal ini
muncul pada saat yang bersamaan.

680
00:31:15,830 --> 00:31:18,650
Anda dapat melakukan banyak hal
keren karena ada

681
00:31:18,650 --> 00:31:25,100
properti ini di mana kita
dapat membuat m aksen tambah m

682
00:31:25,100 --> 00:31:29,070
dan mengambil eksponen dari
semua itu, dan ini masih berfungsi.

683
00:31:29,070 --> 00:31:29,570
Oke.

684
00:31:29,570 --> 00:31:30,487
Jadi itu sangat keren.

685
00:31:30,487 --> 00:31:32,360
Anda bisa melakukan banyak hal keren.

686
00:31:32,360 --> 00:31:36,440
Tetapi ini juga
tidak digunakan di Bitcoin.

687
00:31:36,440 --> 00:31:37,940
Salah satunya adalah ukurannya.

688
00:31:37,940 --> 00:31:42,800
Jadi ukuran kunci lebih kecil
dibandingkan dengan tanda tangan lamport.

689
00:31:42,800 --> 00:31:48,277
Dan biasanya sekitar
berukuran 2 kilobit, atau 256 byte,

690
00:31:48,277 --> 00:31:48,860
yang tidak masalah.

691
00:31:48,860 --> 00:31:51,900
Dan itu sama
ukurannya dengan tanda tangan.

692
00:31:51,900 --> 00:31:53,435
Jadi, jika Anda menggunakan browser web--

693
00:31:56,200 --> 00:31:59,720
aman-- yah, seberapa aman?

694
00:31:59,720 --> 00:32:00,950
Sertifikat, valid.

695
00:32:00,950 --> 00:32:03,700
Oh, browser ini
mungkin tidak menampilkan saya.

696
00:32:03,700 --> 00:32:05,263
Baiklah jangan dipikirkan.

697
00:32:05,263 --> 00:32:06,680
AUDIENS: Di
Firefox, itu akan melakukannya.

698
00:32:06,680 --> 00:32:08,970
TADGE DRYJA: Di Firefox,
ini memberi tahu Anda lebih banyak.

699
00:32:08,970 --> 00:32:09,470
Oke.

700
00:32:09,470 --> 00:32:11,030
Yah, bagaimanapun juga (3x).

701
00:32:11,030 --> 00:32:16,250
Tapi ya, ada kunci RSA di,
pada dasarnya, setiap sertifikat

702
00:32:16,250 --> 00:32:18,020
untuk browser web dan situs web.

703
00:32:18,020 --> 00:32:21,060
Dan biasanya
panjangnya 2.048 bit.

704
00:32:21,060 --> 00:32:23,840
Itu terlihat cukup aman.

705
00:32:23,840 --> 00:32:27,500
Bahkan 1.024 bit
belum diretas.

706
00:32:27,500 --> 00:32:29,000
Tetapi orang-orang berpikir
itu mungkin dilakukan

707
00:32:29,000 --> 00:32:31,720
oleh aktor yang sangat termotivasi.

708
00:32:31,720 --> 00:32:34,550
Jadi ini adalah ukuran yang layak.

709
00:32:34,550 --> 00:32:37,133
Satu hal tentang RSA adalah
sedikit rumit untuk diterapkan,

710
00:32:37,133 --> 00:32:37,633
bukan?

711
00:32:37,633 --> 00:32:39,440
Ada banyak
matematika aneh di sana.

712
00:32:39,440 --> 00:32:41,540
Ini tidak seperti
tanda tangan lamport,

713
00:32:41,540 --> 00:32:44,410
yang seperti, Oke, saya punya
fungsi hash, gunakan itu, bukan?

714
00:32:44,410 --> 00:32:45,920
Agak sulit
untuk menembak diri sendiri

715
00:32:45,920 --> 00:32:49,070
dengan
skema tanda tangan lamport.

716
00:32:49,070 --> 00:32:50,960
Anda bisa, benar, tapi
sudah jelas

717
00:32:50,960 --> 00:32:52,280
jika Anda melakukannya, jadi jika Anda
mengerjakan pekerjaan rumah

718
00:32:52,280 --> 00:32:54,322
dan itu tidak berhasil
sama sekali, dan Anda seperti,

719
00:32:54,322 --> 00:32:57,680
oh, saya hash dua kali, atau,
oh, saya membalik urutan,

720
00:32:57,680 --> 00:33:02,300
atau tidak berhasil.

721
00:33:02,300 --> 00:33:05,150
Tapi tidak ada cara lain di
mana, oh, saya kurang satu,

722
00:33:05,150 --> 00:33:07,190
dan sekarang terungkaplah
semua kunci privat saya.

723
00:33:07,190 --> 00:33:11,270
Itu sulit dilakukan, sedangkan di
RSA, sebenarnya cukup mudah.

724
00:33:11,270 --> 00:33:14,090
Jika nilai p dan q
Anda, misalnya--

725
00:33:14,090 --> 00:33:16,520
apa hal yang benar-benar gila--

726
00:33:16,520 --> 00:33:21,410
jika p atau q minus 1-- jadi jika
p minus 1 atau q minus 1--

727
00:33:21,410 --> 00:33:24,320
mulus-- intinya,
bilangan yang sangat komposit

728
00:33:24,320 --> 00:33:26,330
memiliki banyak faktor kecil--

729
00:33:26,330 --> 00:33:28,460
Anda dapat menemukan
kunci privat seseorang.

730
00:33:28,460 --> 00:33:29,590
Anda bisa memfaktorkannya.

731
00:33:29,590 --> 00:33:31,850
Jadi bukan hanya p
dan q harus bilangan prima.

732
00:33:31,850 --> 00:33:37,700
P minus 1 dan q minus 1
harus tidak terlalu komposit.

733
00:33:37,700 --> 00:33:39,878
Itu tidak bisa menjadi pangkat dari
dua atau sesuatu.

734
00:33:39,878 --> 00:33:41,420
Jika tidak, Anda bisa
kehilangan privasi Anda.

735
00:33:41,420 --> 00:33:46,700
Jadi ada banyak hal
gila yang terjadi dengan RSA.

736
00:33:46,700 --> 00:33:49,640
Bitcoin dan koin lainnya menggunakan
tanda tangan kurva elips,

737
00:33:49,640 --> 00:33:55,760
yang akan saya bicarakan selanjutnya,
yang menggantikan RSA

738
00:33:55,760 --> 00:33:56,700
dalam banyak kasus.

739
00:33:56,700 --> 00:34:04,370
Jadi itu belum benar-benar berkembang
untuk sertifikat web

740
00:34:04,370 --> 00:34:07,220
tetapi banyak jenis
enkripsi lainnya, penandatanganan, hal-hal

741
00:34:07,220 --> 00:34:07,760
seperti itu.

742
00:34:07,760 --> 00:34:11,150
Mata uang dijital juga merupakan salah satu
kegunaan busur kurva elips

743
00:34:11,150 --> 00:34:13,730
tanda tangan karena
mereka agak lebih

744
00:34:13,730 --> 00:34:16,670
kuat dan agak
lebih kecil dan sangat keren.

745
00:34:16,670 --> 00:34:20,090
Dan kita akan membicarakannya
dalam tiga menit.

746
00:34:20,090 --> 00:34:22,699
Jadi istirahat, tiga menit.

747
00:34:22,699 --> 00:34:24,650
Senam.

748
00:34:24,650 --> 00:34:25,949
Ajukan pertanyaan acak.

749
00:34:25,949 --> 00:34:27,540
Bicaralah dengan tetangga.

750
00:34:27,540 --> 00:34:28,040
Oke.

751
00:34:28,040 --> 00:34:32,659
Jadi mereka menggunakan
kurva elips ini,

752
00:34:32,659 --> 00:34:34,790
yang merupakan kurva
berbentuk y kuadrat

753
00:34:34,790 --> 00:34:38,150
ditambah x pangkat tiga ditambah beberapa
koefisien x kuadrat

754
00:34:38,150 --> 00:34:41,239
ditambah beberapa konstanta.

755
00:34:41,239 --> 00:34:43,670
Dan dalam kasus
Bitcoin, ini sangat sederhana.

756
00:34:43,670 --> 00:34:46,960
Itu y kuadrat sama dengan
x pangkat 3 ditambah 7.

757
00:34:46,960 --> 00:34:49,340
Dan itulah
kurva yang digunakan Bitcoin.

758
00:34:49,340 --> 00:34:52,300
Dan seperti inilah tampilannya
jika Anda memplotnya

759
00:34:52,300 --> 00:34:54,920
Dan itu tampaknya sangat sederhana.

760
00:34:54,920 --> 00:34:56,239
Kami benar-benar dapat memahami itu.

761
00:34:56,239 --> 00:34:58,220
Tetapi itu menjadi sedikit aneh.

762
00:34:58,220 --> 00:35:02,330
Dengan kurva eliptik, Anda memiliki
titik-titik ini pada kurva,

763
00:35:02,330 --> 00:35:02,870
benar?

764
00:35:02,870 --> 00:35:06,530
Dan properti lainnya adalah jika
Anda menggambar garis lurus yang

765
00:35:06,530 --> 00:35:08,463
memotong kurva ini--

766
00:35:08,463 --> 00:35:10,130
Anda juga dapat menggambar
garis yang tidak

767
00:35:10,130 --> 00:35:11,218
berpotongan sama sekali, baiklah--

768
00:35:11,218 --> 00:35:13,260
tetapi jika Anda menggambar garis
yang memotong kurva,

769
00:35:13,260 --> 00:35:16,575
dia akan berpotongan
di tiga tempat.

770
00:35:16,575 --> 00:35:18,950
Jadi jika saya menggambar sebuah garis di sini,
dia berpotongan di tiga titik ini.

771
00:35:18,950 --> 00:35:21,560
Jika saya menggambar garis di sini,
dia berpotongan di sini, sini,

772
00:35:21,560 --> 00:35:23,520
dan kemudian akan berpotongan
di suatu tempat di bawah sini.

773
00:35:23,520 --> 00:35:26,690
Dia akan berpotongan menjadi tiga
tempat kecuali saya mengambil garis singgung (tangent).

774
00:35:26,690 --> 00:35:28,430
Jika saya menggambar, dan saya mencoba
menjadi seperti, oh, saya

775
00:35:28,430 --> 00:35:30,230
hanya akan berpotongan
dalam dua, yah, saya

776
00:35:30,230 --> 00:35:32,480
dapat mengambil garis singgung
di sini, dan dia akan

777
00:35:32,480 --> 00:35:34,160
berpotongan di satu tempat lagi.

778
00:35:34,160 --> 00:35:36,430
Apa yang bisa kita lakukan, sebenarny,
adalah kita dapat mengatakan, baik,

779
00:35:36,430 --> 00:35:38,180
jika Anda berpotongan di sebuah
garis singgung, itu

780
00:35:38,180 --> 00:35:40,893
seperti berpotongan dua kali.

781
00:35:40,893 --> 00:35:41,810
Kita bisa memahaminya.

782
00:35:41,810 --> 00:35:43,637
AUDIENS: Bagaimana jika Anda
menggambar sebuah garis vertikal?

783
00:35:43,637 --> 00:35:45,970
TADGE DRYJA: Jika Anda menggambar sebuah
vertikal-- oh, yah, garis

784
00:35:45,970 --> 00:35:47,710
vertikal, lalu ada sebuah
titik tak terhingga,

785
00:35:47,710 --> 00:35:49,498
yang seharusnya tidak terjadi.

786
00:35:49,498 --> 00:35:51,070
AUDIENCE: Tetapi
tak terhingga juga termasuk--

787
00:35:51,070 --> 00:35:51,385
TADGE DRYJA: Yah.

788
00:35:51,385 --> 00:35:53,380
AUDIENS: --dalam
himpunan titik pada kurva?

789
00:35:53,380 --> 00:35:55,130
Jadi seperti ada
tiga poin, sih.

790
00:35:55,130 --> 00:35:56,290
TADGE DRYJA: Yah.

791
00:35:56,290 --> 00:35:57,950
Ada titik di sana--

792
00:35:57,950 --> 00:35:58,450
semacam.

793
00:36:01,150 --> 00:36:02,920
Dalam praktik
penandatanganan dan lain-lain,

794
00:36:02,920 --> 00:36:05,910
Anda mungkin tidak harus menabraknya.

795
00:36:05,910 --> 00:36:08,290
Yah.

796
00:36:08,290 --> 00:36:12,310
Tapi jadi apa yang kita lakukan adalah kita katakan,
Oke, nah, tiga poin berturut-turut di sebuah garis

797
00:36:12,310 --> 00:36:14,630
sama dengan nol.

798
00:36:14,630 --> 00:36:18,590
Jadi jika kita mengambil poin
ini ditambah poin ini

799
00:36:18,590 --> 00:36:20,570
ditambah poin ini, itu nol.

800
00:36:20,570 --> 00:36:25,550
Cara lain untuk mengatakan itu adalah
P ditambah Q dikurangi R sama dengan 0,

801
00:36:25,550 --> 00:36:30,500
atau P ditambah Q sama dengan negatif
R. Dan sifat lainnya adalah

802
00:36:30,500 --> 00:36:34,790
negasi suatu titik
sebenarnya adalah titik yang sama

803
00:36:34,790 --> 00:36:37,160
dengan koordinat y dibalik.

804
00:36:37,160 --> 00:36:40,160
Jadi jika ini
negatif R, kita hanya

805
00:36:40,160 --> 00:36:42,380
turun ke
sisi bawah dari ini,

806
00:36:42,380 --> 00:36:44,857
dan ini positif
R. Demikian pula, dikurangi P

807
00:36:44,857 --> 00:36:45,440
akan berada di sini.

808
00:36:45,440 --> 00:36:47,000
Minus Q akan ada di sini.

809
00:36:47,000 --> 00:36:51,830
Dan jika Anda memiliki titik Z di sini,
negatif Z akan berada di atas sini.

810
00:36:51,830 --> 00:36:53,570
Ini adalah bagaimana itu dibangun.

811
00:36:53,570 --> 00:36:58,460
Namun, kita sebenarnya tidak
gunakan kurva yang bagus ini.

812
00:36:58,460 --> 00:37:00,778
Kita memotongnya menjadi
memodulasi sesuatu.

813
00:37:00,778 --> 00:37:01,278
Yah?

814
00:37:01,278 --> 00:37:03,680
Audiens: Anda memiliki P ditambah Q
sama dengan negatif R. Haruskah itu

815
00:37:03,680 --> 00:37:04,509
menjadi positif R?

816
00:37:08,050 --> 00:37:10,420
TADGE DRYJA: Tidak.

817
00:37:10,420 --> 00:37:11,590
Dalam hal ini, R ada di atas sini.

818
00:37:11,590 --> 00:37:13,360
Benar.

819
00:37:13,360 --> 00:37:14,920
Pada kasus ini--

820
00:37:14,920 --> 00:37:17,470
Tunggu, tunggu.

821
00:37:17,470 --> 00:37:18,352
[SUARA INTERPOSISI]

822
00:37:18,352 --> 00:37:19,310
TADGE DRYJA: Oh, sial.

823
00:37:19,310 --> 00:37:19,810
Maaf.

824
00:37:19,810 --> 00:37:21,790
P ditambah Q sama dengan R. Benar.

825
00:37:21,790 --> 00:37:23,840
Maaf.

826
00:37:23,840 --> 00:37:24,340
OK.

827
00:37:24,340 --> 00:37:25,140
Lupakan.

828
00:37:25,140 --> 00:37:26,180
Yah.

829
00:37:26,180 --> 00:37:29,490
Gambarnya benar.

830
00:37:29,490 --> 00:37:35,002
Tapi jadi pada dasarnya,
P ditambah Q sama dengan R

831
00:37:35,002 --> 00:37:35,960
karena R di bawah sini.

832
00:37:35,960 --> 00:37:36,460
Maaf.

833
00:37:36,460 --> 00:37:37,600
Ya, itu sebabnya.

834
00:37:37,600 --> 00:37:38,120
OK.

835
00:37:38,120 --> 00:37:40,550
Ini adalah R. Ini adalah
negatif R. Jadi ya,

836
00:37:40,550 --> 00:37:47,720
P ditambah Q sama dengan R,
bukan negatif R. Maaf.

837
00:37:47,720 --> 00:37:50,750
Ketika Anda ingin mengalikan
sebuah titik, Anda bisa.

838
00:37:50,750 --> 00:37:52,712
Karena Anda bisa mengambil 
sebuah garis singgung (tangent), benar?

839
00:37:52,712 --> 00:37:54,170
Sehingga Anda dapat menambahkan
titik-titik ini, benar?

840
00:37:54,170 --> 00:37:57,050
Anda dapat mengatakan, oke, saya ingin 
hasil penjumlahan P dan Q,

841
00:37:57,050 --> 00:37:58,500
Dimana akan berada di bawah sini--

842
00:37:58,500 --> 00:38:03,320
R. Saya ingin 2P, sebagai contoh.

843
00:38:03,320 --> 00:38:05,870
Baik, dengan 2P, Saya
dapat mengambil sebuah garis singgung (tangent)

844
00:38:05,870 --> 00:38:07,460
dan kemudian mencari
dimana ia berpotongan

845
00:38:07,460 --> 00:38:09,450
dan kemudian turun
di bawah kurva.

846
00:38:09,450 --> 00:38:13,100
Jadi misalnya, jika ini
adalah G, Saya mengatakan oke, baik, G 

847
00:38:13,100 --> 00:38:16,400
dimulai dari sini, ambil sebuah garis singgung (tangent)
cari dimana ia berpotongan.

848
00:38:16,400 --> 00:38:17,840
dan kemudian turun ke bawah.

849
00:38:17,840 --> 00:38:19,850
Dan ini adalah 2G.

850
00:38:19,850 --> 00:38:22,865
Sehingga ini merupakan cara 
sederhana untuk mengatakan, baik,

851
00:38:22,865 --> 00:38:23,990
Saya tidak benar-benar mengalikan.

852
00:38:23,990 --> 00:38:25,760
Saya hanya menambahkannya dengan 
dirinya sendiri, di mana

853
00:38:25,760 --> 00:38:27,613
perkalian sebenarnya seperti itu.

854
00:38:27,613 --> 00:38:29,030
Dan saya dapat melakukan hal ini
lagi dan lagi.

855
00:38:29,030 --> 00:38:30,620
Jadi saya mengatakan, oh, Saya ingin 4G.

856
00:38:30,620 --> 00:38:33,700
Saya mengambil sebuah garis singgung (tangent) pada 2G,
mencari titik potong di sini,

857
00:38:33,700 --> 00:38:34,370
turun ke bawah.

858
00:38:34,370 --> 00:38:34,870
Oke.

859
00:38:34,870 --> 00:38:35,840
Ini 4G.

860
00:38:35,840 --> 00:38:38,030
Ambil sebuah sebuah garis singgung (tangent)
di sini, dia akan pergi-- 

861
00:38:38,030 --> 00:38:41,630
Saya bisa terus melakukan itu
dan mendapatkan 2G, 4G, 8G.

862
00:38:41,630 --> 00:38:46,460
Dan jika saya ingin hal-hal 
tambahan, seperti, yah, saya ingin 3G,

863
00:38:46,460 --> 00:38:51,670
yah, saya mengambar sebuah garis di antara G
dan 2G, cari titik potong,

864
00:38:51,670 --> 00:38:53,150
dan cari hasil penjumlahannya.

865
00:38:53,150 --> 00:38:53,990
Jadi yah?

866
00:38:53,990 --> 00:38:54,490
Ya?

867
00:38:54,490 --> 00:38:57,370
AUDIENS: Ketika Anda menemukan 
sebuah titik potong dari hal itu

868
00:38:57,370 --> 00:38:59,703
[TIDAK TERDENGAR] titik potong
dari modulo sesuatu,

869
00:38:59,703 --> 00:39:00,240
apakah itu hanya--

870
00:39:00,240 --> 00:39:01,240
TADGE DRYJA: Yah, yah.

871
00:39:01,240 --> 00:39:05,162
Jadi gambarnya terlihat
bagus, dalam kasus ini, bukan?

872
00:39:05,162 --> 00:39:06,620
Ini seperti, hei,
ada kurva di sini.

873
00:39:06,620 --> 00:39:08,490
Dan ini terlihat sangat sederhana.

874
00:39:08,490 --> 00:39:10,970
Dan kita bisa secara grafis
melakukannya di kertas bergaris.

875
00:39:10,970 --> 00:39:13,280
Tetapi ketika Anda benar-benar
melakukannya di komputer,

876
00:39:13,280 --> 00:39:14,960
itu akan lebih terlihat seperti ini.

877
00:39:14,960 --> 00:39:18,890
Semuanya adalah modulo
dari beberapa bilangan prima raksasa.

878
00:39:18,890 --> 00:39:20,300
Anda masih bisa menggambar garis.

879
00:39:20,300 --> 00:39:24,560
Hanya saja sekarang kurvanya 
menjadi semua titik yang tampak gila ini.

880
00:39:24,560 --> 00:39:28,850
Dan Anda masih memiliki
simetri dari sumbu y.

881
00:39:28,850 --> 00:39:32,060
Tetapi cara komputer melakukannya
adalah dengan memodulo sebuah angka.

882
00:39:32,060 --> 00:39:37,770
Sehingga sebenarnya itu tidak
memetakan ke kurva yang baik.

883
00:39:37,770 --> 00:39:40,370
Jadi hal yang menarik
ketika anda melakukan modulo

884
00:39:40,370 --> 00:39:43,892
adalah semua properti
tetap sama, benar?

885
00:39:43,892 --> 00:39:45,350
Dengan angka biasa,
Anda masih bisa

886
00:39:45,350 --> 00:39:47,660
melakukan penjumlahan,
perkalian, pembagian

887
00:39:47,660 --> 00:39:51,500
semua modulo dari sebuah angka, dan
masih berfungsi semua, benar?

888
00:39:51,500 --> 00:39:53,600
Begitu juga dengan ini.

889
00:39:53,600 --> 00:39:57,800
Anda masih harus menggambar
garis yang sama antara P dan Q,

890
00:39:57,800 --> 00:39:59,780
dan Anda sampai di sini.

891
00:39:59,780 --> 00:40:05,240
Dan kemudian anda membalik
sumbu y, dan sekarang ini adalah R.

892
00:40:05,240 --> 00:40:07,670
Demikian pula, Anda bisa
mengambil sebuah sebuah garis singgung--

893
00:40:07,670 --> 00:40:10,610
meskipun sebuah garis singgung lebih sulit
di lihat secara visual karena

894
00:40:10,610 --> 00:40:12,950
tidak ada kurva yang jelas di sini--

895
00:40:12,950 --> 00:40:15,100
tetapi persamaan bekerja dengan cara yang sama.

896
00:40:15,100 --> 00:40:15,600
Oke.

897
00:40:15,600 --> 00:40:20,860
Jadi anda tidak perlu tahu
tepatnya mengapa hal-hal ini bekerja

898
00:40:20,860 --> 00:40:21,360
atau kurva-kurva.

899
00:40:21,360 --> 00:40:24,540
Tapi kita akan melihat
apa yang dapat Anda lakukan dengan ini

900
00:40:24,540 --> 00:40:25,820
dan properti apa yang Anda miliki.

901
00:40:25,820 --> 00:40:26,320
Oke.

902
00:40:26,320 --> 00:40:30,480
Jadi kita telah mendefinisikan
titik ini pada kurva

903
00:40:30,480 --> 00:40:31,860
dan bagaimana kurva ini bekerja.

904
00:40:31,860 --> 00:40:35,520
Dan kemudian kita juga memiliki
angka lama biasa, benar?

905
00:40:35,520 --> 00:40:39,520
Jadi apa yang akan kita lakukan dari sekarang
katakanlah, seperti a dan b,

906
00:40:39,520 --> 00:40:41,760
angka yang disimbolkan huruf kecil kita,
ini adalah skalar.

907
00:40:41,760 --> 00:40:44,880
Skalar hanya berarti
angka lama biasa.

908
00:40:44,880 --> 00:40:49,310
Huruf besar A dan B akan mengacu
ke titik pada kurva, oke?

909
00:40:49,310 --> 00:40:52,080
Jadi mulai sekarang, huruf kecil
adalah angka biasa,

910
00:40:52,080 --> 00:40:54,150
huruf besar adalah titik
pada kurva ini,

911
00:40:54,150 --> 00:40:58,678
atau titik pada bermacam hal ini
yang kita tetap menyebutnya sebagai kurva.

912
00:40:58,678 --> 00:40:59,510
Oke.

913
00:40:59,510 --> 00:41:01,700
Jadi saya akan menunjukkan operasi
apa saja yang dapat kita lakukan,

914
00:41:01,700 --> 00:41:05,090
dan kemudian kita dapat melihat
apa gunanya hal tersebut.

915
00:41:05,090 --> 00:41:07,190
Jadi pertama, skalar.

916
00:41:07,190 --> 00:41:08,990
Anda dapat melakukan penjumlahan, pengurangan,
perkalian, pembagian.

917
00:41:08,990 --> 00:41:10,490
Anda bisa melakukan apa saja
anda mau, benar?

918
00:41:10,490 --> 00:41:14,860
Ini hanya biasa
angka, seperti lima atau 17 atau 22.

919
00:41:14,860 --> 00:41:17,090
Semuanya baik-baik saja, benar?

920
00:41:17,090 --> 00:41:17,780
Mudah.

921
00:41:17,780 --> 00:41:18,947
Semuanya di sini adalah bilangan bulat.

922
00:41:18,947 --> 00:41:21,530
Kita sedang mencari sisa pembagian dari
beberapa bilangan prima yang besar,

923
00:41:21,530 --> 00:41:24,598
Sehingga tidak ada angka di belakang koma.

924
00:41:24,598 --> 00:41:26,390
Saya pikir di kelas ini,
kita mungkin tidak akan pernah

925
00:41:26,390 --> 00:41:28,700
harus menggunakan pecahan,
di mana itu adalah kabar baik,

926
00:41:28,700 --> 00:41:32,360
karena pecahan
selalu membuat saya takut.

927
00:41:32,360 --> 00:41:33,710
Ini juga uint (unsigned int)

928
00:41:33,710 --> 00:41:35,177
Ini seperti
bilangan bulat nonnegatif

929
00:41:35,177 --> 00:41:36,260
Anda bisa melakukan ini bilangan negatif juga.

930
00:41:36,260 --> 00:41:39,470
Tetapi karena Anda
melakukan modulo dengan angka besar,

931
00:41:39,470 --> 00:41:42,380
ini seperti bilangan bulat
nonnegatif yang berputar putar.

932
00:41:42,380 --> 00:41:43,910
Jadi ini sangatlah
bagus untuk komputer.

933
00:41:43,910 --> 00:41:45,410
Komputer dapat menjalankan
ini dengan sangat baik

934
00:41:45,410 --> 00:41:47,030
Komputer juga sangat baik dalam
menghitung pecahan.

935
00:41:47,030 --> 00:41:48,680
Tapi masalahnya adalah,
di dalam kriptografi,

936
00:41:48,680 --> 00:41:51,520
Sering kali bilangan desimal
menyebabkan masalah, bukan,

937
00:41:51,520 --> 00:41:54,950
di mana Anda cukup
dekat, tapi Anda

938
00:41:54,950 --> 00:41:58,670
memiki jumlah konstan dari
bagian pecahan yang Anda bisa simpan.

939
00:41:58,670 --> 00:42:01,010
Bagian pecahan anda terbatas
pada presisi tertentu.

940
00:42:01,010 --> 00:42:02,480
Lalu kesalahan dapat terakumulasi.

941
00:42:02,480 --> 00:42:06,470
Dan seringkali falam kriptografi,
Anda tidak ingin ada kesalahan sama sekali, benar?

942
00:42:06,470 --> 00:42:09,500
Seperti di fungsi hash,
itu sangat ketat.

943
00:42:09,500 --> 00:42:12,140
Jadi dalam banyak hal,
di kriptografi,

944
00:42:12,140 --> 00:42:14,960
Anda lebih sering menggunakan bilangan bulat,
dibanding pecahan atau angka

945
00:42:14,960 --> 00:42:16,110
rasional.

946
00:42:16,110 --> 00:42:16,610
Oke.

947
00:42:16,610 --> 00:42:20,600
Jadi dalam bilangan skalar, ini
hanyalah bilangan bulat,

948
00:42:20,600 --> 00:42:22,520
bahkan bilangan natural.

949
00:42:22,520 --> 00:42:23,480
Anda bisa lakukan ini.

950
00:42:23,480 --> 00:42:25,940
Dalam semua operasi,
yang sudah Anda kenal.

951
00:42:25,940 --> 00:42:28,070
Itu cukup jelas.

952
00:42:28,070 --> 00:42:29,300
Dengan poin-poin.

953
00:42:29,300 --> 00:42:32,960
Jadi Anda bisa menambah dan
mengurangi poinnya, benar?

954
00:42:32,960 --> 00:42:36,020
Kita sudah menunjukkan bagaimana
Anda melakukannya secara visual.

955
00:42:36,020 --> 00:42:38,030
dan kemudian persamaannya
untuk itu, komputer

956
00:42:38,030 --> 00:42:39,810
dapat mengerjakannya dengan cepat.

957
00:42:39,810 --> 00:42:41,630
Tetapi, ini tidak terdefinisi.

958
00:42:41,630 --> 00:42:46,320
Perkalian dan pembagian
dengan dua poin tidak terdefinisi.

959
00:42:46,320 --> 00:42:49,042
Tidak jelas 
bagaimana Anda melakukannya.

960
00:42:49,042 --> 00:42:50,750
Ini bukan sesuatu
di dalam sistem ini, benar?

961
00:42:50,750 --> 00:42:51,400
Ini adalah sebuah kelompok.

962
00:42:51,400 --> 00:42:53,210
Anda sudah mendapat satu operasi.

963
00:42:53,210 --> 00:42:55,052
Anda tidak memiliki selain yang ini.

964
00:42:55,052 --> 00:42:56,510
Jadi Anda bisa menambah dan
mengurangi poin,

965
00:42:56,510 --> 00:42:58,430
tetapi Anda tidak bisa mmengalikan mereka.

966
00:42:58,430 --> 00:42:59,820
Adakah pertanyaan mengenai ini?

967
00:42:59,820 --> 00:43:03,010
Ini sangat penting.

968
00:43:03,010 --> 00:43:03,990
Masuk akal?

969
00:43:03,990 --> 00:43:04,490
Ya?

970
00:43:04,490 --> 00:43:08,100
AUDIENS: Dalam kasus sebelumnya,
ketika Anda sedang menambahkan poin,

971
00:43:08,100 --> 00:43:09,380
apa yang didefinisikan sebagai penjumlahan?

972
00:43:09,380 --> 00:43:12,630
Apakah Anda hanya menambahkan
komponen y?

973
00:43:12,630 --> 00:43:14,840
TADGE DRYJA: Anda menggunakan
koordinat x dan y

974
00:43:14,840 --> 00:43:15,720
untuk dijumlahkan, benar?

975
00:43:18,093 --> 00:43:19,760
Jadi saat Anda melakukan
ini di komputer,

976
00:43:19,760 --> 00:43:21,135
Anda mengatakan,
Oke, baik, apa

977
00:43:21,135 --> 00:43:22,665
koordinat x dan y dari P?

978
00:43:22,665 --> 00:43:24,290
Apa koordinat x- dan
koordinat y dari Q?

979
00:43:27,980 --> 00:43:31,440
Temukan kemiringan disini dan
di mana dia memotong sumbunya.

980
00:43:31,440 --> 00:43:33,560
Lalu lihat di mana dia akan
memotong kurvanya

981
00:43:33,560 --> 00:43:34,615
di titik yang lain.

982
00:43:34,615 --> 00:43:38,290
AUDIENS: Penjumlahan sebenarnya
didefinisikan sebagai perhitungan poin tersebut.

983
00:43:38,290 --> 00:43:41,400
Ini bukanlah fungsi dari penjumlahan
koordinat x dan y.

984
00:43:41,400 --> 00:43:42,230
AUDIENS: Saya mengerti.

985
00:43:42,230 --> 00:43:42,980
TADGE DRYJA: yah.

986
00:43:42,980 --> 00:43:45,380
Jadi, yang saya maksud-- yah.

987
00:43:45,380 --> 00:43:47,900
Tapi persamaannya akan menjadi--

988
00:43:47,900 --> 00:43:50,150
karena komputer tidak 
benar-benar melihat kurvanya,

989
00:43:50,150 --> 00:43:51,140
Anda cukup bilang, Oke.

990
00:43:51,140 --> 00:43:52,700
Temukan Px- dan koordinat y.

991
00:43:52,700 --> 00:43:54,200
Temukan Qx- dan koordinat y.

992
00:43:54,200 --> 00:43:57,410
Temukan sisi miring, lalu
Temukan dimana dia berpotongan,

993
00:43:57,410 --> 00:44:03,800
lalu hitung itu untuk mendapat R nya.

994
00:44:03,800 --> 00:44:04,300
Oke.

995
00:44:04,300 --> 00:44:05,770
Dan ya.

996
00:44:05,770 --> 00:44:06,970
Anda bisa menambah dan mengurangi.

997
00:44:06,970 --> 00:44:09,760
Anda tidak bisa mengkalikan dan
membagi titik ini.

998
00:44:09,760 --> 00:44:10,420
Masuk akal?

999
00:44:10,420 --> 00:44:11,670
Adakah pertanyaan lain?

1000
00:44:11,670 --> 00:44:12,325
Ya?

1001
00:44:12,325 --> 00:44:13,700
AUDIENS: Bagaimana
cara Anda menguranginya?

1002
00:44:13,700 --> 00:44:14,990
TADGE DRYJA: Ah.

1003
00:44:14,990 --> 00:44:18,920
Anda hanya perlu turun, benar?

1004
00:44:18,920 --> 00:44:22,880
Jadi jika saya ingin mengurangkan P dan Q, saya
harus mengatakan P ditambah negatif Q.

1005
00:44:22,880 --> 00:44:26,030
Dan negatif Q tepat berada
di sini, tepat dibawah sumbu.

1006
00:44:26,030 --> 00:44:27,980
Jadi saya katakan, oke, saya ingin
P dikurang Q. Saya lanjutkan ke sini.

1007
00:44:27,980 --> 00:44:28,730
Temukanlah.

1008
00:44:28,730 --> 00:44:31,920
Dia akan berada di
atas sana di suatu tempat.

1009
00:44:31,920 --> 00:44:32,420
Jadi ya.

1010
00:44:32,420 --> 00:44:37,050
Anda hanya tinggal menambahkan
bilangan negatif dari angka tersebut.

1011
00:44:37,050 --> 00:44:40,470
Saya pikir itu adalah hal yang lain.

1012
00:44:40,470 --> 00:44:43,320
Minus B-- negatif B-- 
juga merupakan operasi yang bisa saya lakukan.

1013
00:44:43,320 --> 00:44:47,608
Saya bisa menegasikan sesuatu,
Ini memungkinkan saya untuk melakukan pengurangan.

1014
00:44:47,608 --> 00:44:49,650
AUDIENS: Bagi
kalian dengan latar belakang matematika,

1015
00:44:49,650 --> 00:44:51,530
ini mendefinisikan
operasi grup

1016
00:44:51,530 --> 00:44:54,337
di dalam bilangan 
asli, modulo--

1017
00:44:54,337 --> 00:44:55,670
TADGE DRYJA: Yang mana adalah yang besar.

1018
00:44:55,670 --> 00:44:56,950
AUDIENS: --dan menggunakan
kurva elips ini.

1019
00:44:56,950 --> 00:44:59,340
Lalu ini adalah A. dan
satu-satunya hal yang terdefinisi

1020
00:44:59,340 --> 00:45:01,640
adalah penjumlahkan dan pengurangan
dan bukan perkalian.

1021
00:45:01,640 --> 00:45:03,090
TADGE DRYJA: Baik.

1022
00:45:03,090 --> 00:45:04,920
Anda bisa melakukan
operasi grup yang sama

1023
00:45:04,920 --> 00:45:06,420
tanpa menggunakan kurva elips.

1024
00:45:06,420 --> 00:45:08,910
Jadi Anda bisa saja
melakukan modulo eksponensial

1025
00:45:08,910 --> 00:45:10,440
bilangan prima yang besar.

1026
00:45:10,440 --> 00:45:11,940
Saya akan menggunakan
kurva karena itu

1027
00:45:11,940 --> 00:45:15,600
yang digunakan di semua
sistem yang sebenarnya.

1028
00:45:15,600 --> 00:45:19,380
Tetapi Anda bisa semacam melupakan tentang
kurvanya setelah ini, benar?

1029
00:45:19,380 --> 00:45:25,140
Anda dapat mengatakan, baik, lihat, kita hanya
memiliki beberapa variabel huruf besar ini

1030
00:45:25,140 --> 00:45:26,460
dan beberapa variabel huruf kecil ini.

1031
00:45:26,460 --> 00:45:29,070
Dan faktanya bahwa itu ada di
kurva, kita dapat semacam memisahkan

1032
00:45:29,070 --> 00:45:31,650
dan mengetahui bahwa kita
memiliki beberapa jenis yang berbeda,

1033
00:45:31,650 --> 00:45:32,460
pada dasarnya.

1034
00:45:32,460 --> 00:45:34,110
Dan ketika Anda berada di dalam
komputer, Anda seperti,

1035
00:45:34,110 --> 00:45:35,100
ya, itu intinya.

1036
00:45:35,100 --> 00:45:35,970
Itu adalah sebuah nilai skalar.

1037
00:45:35,970 --> 00:45:37,670
Ini adalah
operasi yang dapat saya lakukan,

1038
00:45:37,670 --> 00:45:39,820
dan saya dapat menjalankan fungsi nya.

1039
00:45:39,820 --> 00:45:40,320
Oke.

1040
00:45:40,320 --> 00:45:46,080
Jadi langkah selanjutnya, ketika Anda
mencampur skalar dan titik,

1041
00:45:46,080 --> 00:45:48,000
jadi operasi campuran.

1042
00:45:48,000 --> 00:45:54,480
Anda tidak dapat menambah sebuah titik dan sebuah
bilangan bulat atau mengurangi sebuah titik

1043
00:45:54,480 --> 00:45:55,380
dan sebuah bilangan bulat.

1044
00:45:55,380 --> 00:45:56,490
Itu tidak terdefinisi, benar?

1045
00:45:56,490 --> 00:46:00,300
Anda mengatakan, oke,
ini titik p minus 7.

1046
00:46:00,300 --> 00:46:02,130
Jadi, apakah itu artinya
memindahkan sumbu x?

1047
00:46:02,130 --> 00:46:03,840
Apakah itu arti nya memindahkan y?

1048
00:46:03,840 --> 00:46:05,320
Itu tidak terdefinisi.

1049
00:46:05,320 --> 00:46:07,410
Namun, Anda dapat melakukan ini, benar?

1050
00:46:07,410 --> 00:46:10,020
Anda dapat mengalikan dan membagi.

1051
00:46:10,020 --> 00:46:13,530
Jadi Anda dapat mengatakan, baik,
A dikali 2, baik,

1052
00:46:13,530 --> 00:46:14,700
Anda dapat mengambil garis singgung, benar?

1053
00:46:14,700 --> 00:46:19,080
Itu hanya A ditambah A. Atau A dikali
7, kita hanya menjabarkan menjadi

1054
00:46:19,080 --> 00:46:21,720
A ditambah A ditambah A ditambah A sebanyak 17 kali.

1055
00:46:21,720 --> 00:46:23,580
Kita juga dapat membagi,
yang sedikit aneh

1056
00:46:23,580 --> 00:46:27,600
karena kita harus
menemukan invers dari B

1057
00:46:27,600 --> 00:46:29,640
lalu kalikan dengan itu--

1058
00:46:29,640 --> 00:46:33,825
invers perkalian
dari B modulo orde nya.

1059
00:46:33,825 --> 00:46:35,958
Tetapi bagaimana pun, Anda dapat melakukan ini.

1060
00:46:35,958 --> 00:46:37,500
Ini sedikit
lebih rumit karena Anda

1061
00:46:37,500 --> 00:46:39,810
harus menghitung berapakah, seperti,
B pangkat negatif 1

1062
00:46:39,810 --> 00:46:40,920
dan dikali oleh itu.

1063
00:46:40,920 --> 00:46:41,760
Anda dapat melakukannya.

1064
00:46:41,760 --> 00:46:45,468
Jadi Anda dapat melakukan hal ini di mana
Anda memiliki titik-titik dikali skalar.

1065
00:46:45,468 --> 00:46:46,260
Tetapi Anda tidak dapat menjumlahkannya.

1066
00:46:46,260 --> 00:46:46,440
Yah?

1067
00:46:46,440 --> 00:46:48,110
AUDIENS: Jadi 2A adalah
pada dasarnya menggabungkan

1068
00:46:48,110 --> 00:46:50,480
garis singgung dengan A,
[TIDAK TERDENGAR] awal.

1069
00:46:50,480 --> 00:46:51,300
TADGE DRYJA: Ya.

1070
00:46:51,300 --> 00:46:54,060
Jadi itu ada di sini.

1071
00:46:54,060 --> 00:46:55,800
Jika ini adalah G, ini adalah 2G.

1072
00:46:55,800 --> 00:47:00,140
Cari garis singgung nya, cari
perpotongan nya, lalu negasikan.

1073
00:47:00,140 --> 00:47:00,640
Oke.

1074
00:47:00,640 --> 00:47:03,260
Jadi Anda dapat melakukan itu.

1075
00:47:03,260 --> 00:47:03,760
Itu keren.

1076
00:47:03,760 --> 00:47:06,220
Anda tidak dapat melakukan itu.

1077
00:47:06,220 --> 00:47:06,720
Oke.

1078
00:47:06,720 --> 00:47:10,540
Jadi daftar dari
operasi yang dapat kita lakukan.

1079
00:47:10,540 --> 00:47:11,690
Ini dia.

1080
00:47:11,690 --> 00:47:13,600
Dan ini semacam,
jika Anda memikirkan tentang itu,

1081
00:47:13,600 --> 00:47:15,410
Anda dapat melakukan semua
aktivitas keren ini.

1082
00:47:15,410 --> 00:47:17,260
Dia semacam menakjubkan,
semua hal gila

1083
00:47:17,260 --> 00:47:19,690
yang dapat Anda dapat lakukan hanya dengan
operasi ini, benar?

1084
00:47:19,690 --> 00:47:22,010
Dengan angka-angka biasa, Anda
dapat melakukan apa pun yang Anda inginkan.

1085
00:47:22,010 --> 00:47:23,380
Itu sangat jelas.

1086
00:47:23,380 --> 00:47:26,260
Dan dengan titik ini, Anda
dapat menambah dan mengurangkan nya.

1087
00:47:26,260 --> 00:47:29,380
Dan ketika Anda mencampur nya, Anda
dapat mengalikan dan membagi.

1088
00:47:29,380 --> 00:47:30,590
Dan itu saja.

1089
00:47:30,590 --> 00:47:31,090
Oke.

1090
00:47:31,090 --> 00:47:34,330
Sejauh ini ada pertanyaan?

1091
00:47:34,330 --> 00:47:37,275
Anda tidak perlu terlalu khawatir
tentang kurva dan tentang

1092
00:47:37,275 --> 00:47:38,380
semua hal matematis dan lain nya.

1093
00:47:38,380 --> 00:47:41,105
Tapi Anda hanya mengatakan,
Oke, ini kotak peralatan saya.

1094
00:47:41,105 --> 00:47:41,980
Ini yang dapat saya lakukan.

1095
00:47:44,950 --> 00:47:45,450
Oke.

1096
00:47:45,450 --> 00:47:46,033
Ada pertanyaan?

1097
00:47:46,033 --> 00:47:47,370
Paham?

1098
00:47:47,370 --> 00:47:52,750
Sehingga yang dapat kita lakukan sekarang adalah kita 
dapat mendefinisikan sebuah fungsi satu arah

1099
00:47:52,750 --> 00:47:55,990
seperti fungsi hash,
seperti mengalikan

1100
00:47:55,990 --> 00:47:59,260
p dengan q untuk mendapatkan n.

1101
00:47:59,260 --> 00:48:01,390
Apa yang akan kita butuhkan,
selain ini,

1102
00:48:01,390 --> 00:48:05,170
adalah semuanya memilih beberapa titik pada
kurva, dan kita menyebutnya G.

1103
00:48:05,170 --> 00:48:06,130
Dan itu acak.

1104
00:48:06,130 --> 00:48:08,770
Dan kita ingin itu menjadi
acak dan dapat diverifikasi.

1105
00:48:08,770 --> 00:48:12,220
Kita semua harus
setuju pada sebuah titik.

1106
00:48:12,220 --> 00:48:15,760
Dan kita akan menyebutnya
titik pembangkit.

1107
00:48:15,760 --> 00:48:20,290
Dan properti lainnya adalah, karena
itu semua adalah modulo, angka ini,

1108
00:48:20,290 --> 00:48:23,950
jika B terlalu besar, Anda akan
berputar, benar,

1109
00:48:23,950 --> 00:48:26,380
karena itu semua adalah modulo, n ini.

1110
00:48:26,380 --> 00:48:28,690
Sehingga disebut sebagai
titik pembangkit karena--

1111
00:48:28,690 --> 00:48:30,550
dan setiap titik pada
kurva dapat menjadi satu--

1112
00:48:30,550 --> 00:48:33,790
jika Anda tetap, mengatakan,
2G, 3G, 4G, 5G,

1113
00:48:33,790 --> 00:48:37,360
pada akhirnya, Anda akan
kembali ke G, benar?

1114
00:48:37,360 --> 00:48:40,840
Semuanya terbatas.

1115
00:48:40,840 --> 00:48:44,080
Oke apakah ada
yang memiliki ide, Oke,

1116
00:48:44,080 --> 00:48:48,070
bagaimana kita akan membuat beberapa
fungsi satu arah yang keren

1117
00:48:48,070 --> 00:48:49,960
diberikan operasi ini
dan fakta

1118
00:48:49,960 --> 00:48:53,250
bahwa kita memiliki
titik yang disepakati?

1119
00:48:53,250 --> 00:48:55,140
Ini tidak sangat jelas,
tapi sebenarnya

1120
00:48:55,140 --> 00:48:56,850
cukup mudah.

1121
00:48:56,850 --> 00:48:58,302
Begitu Anda melihatnya.
Anda akan, oh.

1122
00:49:01,020 --> 00:49:01,530
Ada ide?

1123
00:49:01,530 --> 00:49:01,710
Yah.

1124
00:49:01,710 --> 00:49:03,285
AUDIENS: jadi Anda
ambil poin G Anda,

1125
00:49:03,285 --> 00:49:05,935
dan Anda kalikan
dengan beberapa skalar,

1126
00:49:05,935 --> 00:49:09,550
dan Anda publikasikan di mana
titiknya adalah skalar [TIDAK TERDENGAR].

1127
00:49:09,550 --> 00:49:11,260
TADGE DRYJA: Ya, ya.

1128
00:49:11,260 --> 00:49:11,760
Oke.

1129
00:49:11,760 --> 00:49:13,630
Jadi kunci privat Anda--

1130
00:49:13,630 --> 00:49:15,720
katakanlah kunci
privat, a huruf kecil,

1131
00:49:15,720 --> 00:49:18,930
itu hanya sekitar 256 bit
bilangan acak, skalar,

1132
00:49:18,930 --> 00:49:23,490
persis sama dengan 32 byte
seperti dalam tanda tangan lamport.

1133
00:49:23,490 --> 00:49:26,340
Dan kunci publik Anda
hanyalah a kali G.

1134
00:49:26,340 --> 00:49:30,810
Dan kunci publik Anda
sekarang adalah titik pada kurva.

1135
00:49:30,810 --> 00:49:32,280
Kita akan menyebutnya
huruf A kapital.

1136
00:49:32,280 --> 00:49:35,340
Dan Anda mempunyai 32 byte
koordinat x, benar--

1137
00:49:35,340 --> 00:49:38,540
karena x itu
dimensinya 256 bit--

1138
00:49:38,540 --> 00:49:39,930
32 bit koordinat y.

1139
00:49:39,930 --> 00:49:41,250
Jadi itu 64 bit--

1140
00:49:41,250 --> 00:49:42,150
cukup kecil.

1141
00:49:42,150 --> 00:49:45,420
Adakah yang memiliki
optimasi cepat lainnya

1142
00:49:45,420 --> 00:49:47,520
tentang bagaimana Anda dapat mengurangi ini?

1143
00:49:47,520 --> 00:49:50,430
Jadi ada banyak
optimasi yang terjadi

1144
00:49:50,430 --> 00:49:52,410
di semua sistem
mata uang kripto yang berbeda.

1145
00:49:52,410 --> 00:49:53,827
Karena mereka tidak
terlalu skalabel.

1146
00:49:53,827 --> 00:49:58,592
Tapi apakah ada ide
untuk menurunkannya?

1147
00:49:58,592 --> 00:50:00,232
AUDIENS: Bisakah Anda melakukan hash?

1148
00:50:00,232 --> 00:50:01,190
TADGE DRYJA: Anda bisa.

1149
00:50:01,190 --> 00:50:02,065
Jadi Anda dapat melakukan hash terhadapnya.

1150
00:50:02,065 --> 00:50:05,460
Anda akan membuatnya sampai 32 byte.

1151
00:50:05,460 --> 00:50:08,888
Ada cara yang lebih berguna.

1152
00:50:08,888 --> 00:50:11,430
Tapi jika Anda meng-hash itu, Anda masih
harus mengungkapkan itu nanti, benar?

1153
00:50:11,430 --> 00:50:14,190
Jadi itu membantu, membuat
sebuah hash pubkey.

1154
00:50:14,190 --> 00:50:16,640
Dan itulah yang dilakukan
Bitcoin pada awalnya

1155
00:50:16,640 --> 00:50:19,980
adalah Anda akan memiliki
kunci publik 64 byte.

1156
00:50:19,980 --> 00:50:22,320
Lalu Anda akan mengirimkan
hash dari mereka.

1157
00:50:22,320 --> 00:50:25,500
Ada cara yang lebih baik.

1158
00:50:25,500 --> 00:50:26,470
Ide lain?

1159
00:50:26,470 --> 00:50:26,970
Oke.

1160
00:50:26,970 --> 00:50:31,770
Jadi masalahnya adalah
itu simetris, benar?

1161
00:50:31,770 --> 00:50:36,630
Jadi kurva nya simetris
terhadap sumbu x.

1162
00:50:39,490 --> 00:50:40,750
Ide lain?

1163
00:50:40,750 --> 00:50:41,380
ya.

1164
00:50:41,380 --> 00:50:43,880
AUDIENS: Bisakah Anda mengkodekan
satu dari koordinat x atau koordinat y

1165
00:50:43,880 --> 00:50:44,948
dan katakan sisi mana?

1166
00:50:44,948 --> 00:50:45,740
TADGE DRYJA: Benar.

1167
00:50:45,740 --> 00:50:49,643
Jadi Anda mengambil koordinat x
dan menyandikan itu.

1168
00:50:49,643 --> 00:50:50,810
Lalu hanya satu bit tersebut--

1169
00:50:50,810 --> 00:50:51,790
4-- itu ada di atas.

1170
00:50:51,790 --> 00:50:53,030
Itu ada di bawah.

1171
00:50:53,030 --> 00:50:56,210
Lalu biarkan mereka mencari tahu
dengan jelas dimana itu, benar?

1172
00:50:56,210 --> 00:50:58,760
Jadi Anda bisa menyandikan
koordinat x saja dan 1 bit

1173
00:50:58,760 --> 00:51:01,370
untuk y, lalu Anda
turun ke 33 byte.

1174
00:51:01,370 --> 00:51:03,830
Ini sedikit menyebalkan
karena 33 byte, baik,

1175
00:51:03,830 --> 00:51:06,160
satu dari byte tersebut
akan menjadi tidak terisi.

1176
00:51:06,160 --> 00:51:08,780
Ini hanya akan memiliki satu
bit di dalamnya untuk naik atau turun.

1177
00:51:08,780 --> 00:51:10,200
Tapi begitulah.

1178
00:51:10,200 --> 00:51:13,200
Jadi Anda bisa melakukan itu, dan
itu juga sangat keren.

1179
00:51:13,200 --> 00:51:14,060
Oke.

1180
00:51:14,060 --> 00:51:17,210
Sejauh ini ada pertanyaan?

1181
00:51:17,210 --> 00:51:21,310
AUDIENS: Bisakah Anda menyandikan
[TIDAK TERDENGAR] dan sama

1182
00:51:21,310 --> 00:51:22,252
naik dan turun?

1183
00:51:22,252 --> 00:51:24,136
Bisakah kamu hanya menyandikan
[TIDAK TERDENGAR]??

1184
00:51:24,136 --> 00:51:25,550
TADGE DRYJA: Huh.

1185
00:51:25,550 --> 00:51:26,720
Mungkin.

1186
00:51:26,720 --> 00:51:29,750
Tapi saya tidak berpikir
ini akan menjadi lebih kecil.

1187
00:51:29,750 --> 00:51:31,910
Saya kira Anda mungkin
perlu memiliki ukuran yang sama

1188
00:51:31,910 --> 00:51:33,577
jika Anda menggunakan
sistem koordinat yang lain.

1189
00:51:36,110 --> 00:51:37,790
Hm.

1190
00:51:37,790 --> 00:51:39,907
Yah, Anda perlu menyandikan sebuah kemiringan--

1191
00:51:39,907 --> 00:51:41,240
AUDIENS: Ya, [TIDAK TERDENGAR].

1192
00:51:41,240 --> 00:51:42,865
TADGE DRYJA: Dan Anda mengatakan
itu berpotongan,

1193
00:51:42,865 --> 00:51:44,960
dan itu di kemiringan, dan
sisi sumbu yang mana?

1194
00:51:44,960 --> 00:51:46,700
AUDIENS: Ya, dan jika memotong
beberapa kali,

1195
00:51:46,700 --> 00:51:47,450
yang mana dari--

1196
00:51:47,450 --> 00:51:48,350
TADGE DRYJA: Anda mungkin bisa.

1197
00:51:48,350 --> 00:51:50,170
Saya pikir Anda akan
berakhir dengan ukuran yang sama.

1198
00:51:50,170 --> 00:51:50,715
Tapi yah.

1199
00:51:50,715 --> 00:51:52,340
Tapi mungkin lebih cepat
untuk beberapa hal.

1200
00:51:52,340 --> 00:51:54,710
Ada macam-macam
pengkodean yang berbeda.

1201
00:51:54,710 --> 00:51:57,990
AUDIENS: Saya menjamin bahwa Anda
memiliki bilangan bulat pada akhirnya.

1202
00:51:57,990 --> 00:51:58,795
TADGE DRYJA: Yah.

1203
00:51:58,795 --> 00:52:00,170
Jadi mungkin Anda tidak
berada di lengkungan.

1204
00:52:00,170 --> 00:52:01,640
Tapi ada
masalah serupa di sini

1205
00:52:01,640 --> 00:52:03,320
di mana mungkin tidak
berada di lengkungan.

1206
00:52:03,320 --> 00:52:06,360
Anda dapat mengkodekan suatu titik
itu juga di luar lengkungan.

1207
00:52:06,360 --> 00:52:08,930
Dan ketika Anda sebenarnya
menerima sebuah kunci publik,

1208
00:52:08,930 --> 00:52:11,515
seperti melalui sebuah kabel
pada sistem ini,

1209
00:52:11,515 --> 00:52:12,890
langkah pertama
yang seharusnya kalian lakukan adalah

1210
00:52:12,890 --> 00:52:14,432
memastikan bahwa 
kunci publiknya valid,

1211
00:52:14,432 --> 00:52:16,217
dan itu seharusnya pada terletak pada kurva.

1212
00:52:16,217 --> 00:52:18,050
Karena ada banyaknya
titik-titik yang tidak.

1213
00:52:18,050 --> 00:52:20,690
Dan terkadang kalian bisa bermain-
main dengan kode yang seperti itu.

1214
00:52:20,690 --> 00:52:20,820
Yah?

1215
00:52:20,820 --> 00:52:23,240
AUDIENS: Bisakah Anda menjelaskan tentang
perkalian skalar lagi?

1216
00:52:23,240 --> 00:52:24,010
bagaimana hasilnya?

1217
00:52:24,010 --> 00:52:24,677
TADGE DRYJA: OK.

1218
00:52:24,677 --> 00:52:29,120
Jadi perkalian skalar--
a kali G adalah, pada dasarnya,

1219
00:52:29,120 --> 00:52:32,960
pemecahan dari G ditambah G
tambah G tambah G tambah G sebanyak a kali.

1220
00:52:32,960 --> 00:52:36,890
Dan G tambah G adalah menemukan
tangent G

1221
00:52:36,890 --> 00:52:39,980
dan kemudian menemukan
titik potongnya, benar?

1222
00:52:39,980 --> 00:52:44,870
Jadi ini adalah G. Ini adalah 2G,
betul-- tangent, titik potong,

1223
00:52:44,870 --> 00:52:46,940
dan negasinya.

1224
00:52:46,940 --> 00:52:50,810
Dan Anda dapat melakukannya
berjuta-juta kali.

1225
00:52:50,810 --> 00:52:53,900
Bagaimanapun, karena Anda bisa
mencari nilai 2G, lalu Anda

1226
00:52:53,900 --> 00:52:57,320
bisa menggandakan 2G untuk mendapatkan 4G
dan menggandakan 4G untuk mendapatkan 8G,

1227
00:52:57,320 --> 00:53:00,140
dan kita bisa mendapatkan nilai
pangkat dua dari G

1228
00:53:00,140 --> 00:53:02,240
dan menambahkan
pangkat 2 tersebut untuk melakukan

1229
00:53:02,240 --> 00:53:06,650
perhitungan yang jauh lebih efisien
sehingga kita bisa secara praktis

1230
00:53:06,650 --> 00:53:07,570
membuat--

1231
00:53:07,570 --> 00:53:12,890
karena a kecil akan menjadi
bilangan desimal 50 digit yang sangat besar

1232
00:53:12,890 --> 00:53:14,290
atau apapun itu.

1233
00:53:14,290 --> 00:53:17,450
Maka Anda akan
melakukan dua, empat, enam,

1234
00:53:17,450 --> 00:53:20,820
delapan, ekspansi biner 
dan menambahkan semuanya.

1235
00:53:20,820 --> 00:53:22,220
OK.

1236
00:53:22,220 --> 00:53:24,570
Yah?

1237
00:53:24,570 --> 00:53:29,860
AUDIENS: Jadi Anda membuang 
beberapa bagian menjadi ukuran bulir kecil

1238
00:53:29,860 --> 00:53:30,800
untuk mendapatkan nilai ini.

1239
00:53:30,800 --> 00:53:32,642
Anda [TIDAK TERDENGAR]
lengkungan yang kontinu.

1240
00:53:32,642 --> 00:53:33,350
TADGE DRYJA: Iya

1241
00:53:33,350 --> 00:53:37,630
AUDIENS: Itu bagaikan mempunyai
306 bit pada bagian aslinya,

1242
00:53:37,630 --> 00:53:40,810
Anda seharusnya tidak bisa mendapatkan
sampai 32 bit, betul?

1243
00:53:40,810 --> 00:53:42,830
Karena Anda hanya ingin meyakinkan
bahwa Anda--

1244
00:53:42,830 --> 00:53:43,707
TADGE DRYJA: Ini?

1245
00:53:43,707 --> 00:53:44,332
AUDIENS: Yah.

1246
00:53:46,580 --> 00:53:49,150
Jika anda menghilangkan satu byte 
presisi,

1247
00:53:49,150 --> 00:53:52,640
apakah Anda akan kehilangan
tenaga?

1248
00:53:52,640 --> 00:53:55,580
TADGE DRYJA: Apa yang bisa sedikit Anda lakukan-- 
apa yang bisa Anda lakukan

1249
00:53:55,580 --> 00:53:58,520
adalah Anda hanya bisa mengatakan,
lihat, saya hanya

1250
00:53:58,520 --> 00:54:06,140
akan memperbolehkan akses kunci publik
yang ada pada posisi atas, komponen

1251
00:54:06,140 --> 00:54:07,070
y positif.

1252
00:54:07,070 --> 00:54:09,545
Dan yang lain
tidak diperbolehkan.

1253
00:54:09,545 --> 00:54:11,420
Anda bisa memiliki hal tersebut sebagai
aturan dalam sistem Anda,

1254
00:54:11,420 --> 00:54:14,810
kemudian anda dapat menyingkirkan
bit y.

1255
00:54:14,810 --> 00:54:19,430
Tapi masalahnya adalah
koordinat y tersebut

1256
00:54:19,430 --> 00:54:23,103
mempengaruhi beberapa hal
seperti tanda tangan, hal-hal

1257
00:54:23,103 --> 00:54:24,020
yang akan Anda gunakan nanti.

1258
00:54:24,020 --> 00:54:28,580
Jadi anda bisa bilang, OK, lihat,
secara implisit bit y positif.

1259
00:54:28,580 --> 00:54:32,240
Dan Anda akan kehilangan keamanan 1 bit.

1260
00:54:32,240 --> 00:54:34,250
Karena terdapat
perbedaan antara

1261
00:54:34,250 --> 00:54:37,742
hal positif dan negatif
jika Anda melakukan penandatanganan.

1262
00:54:37,742 --> 00:54:38,460
Tapi yah.

1263
00:54:38,460 --> 00:54:40,950
Dan beberapa sistem melakukan itu.

1264
00:54:40,950 --> 00:54:42,340
Dan itu membuat hal-hal menjadi lebih mudah.

1265
00:54:42,340 --> 00:54:44,180
Ada beberapa sistem
tanda tangan yang melakukan itu.

1266
00:54:44,180 --> 00:54:44,680
OK.

1267
00:54:44,680 --> 00:54:46,990
Saya akan berpindah
ke bagian selanjutnya.

1268
00:54:50,690 --> 00:54:52,610
ECDSA digunakan pada bitcoin.

1269
00:54:52,610 --> 00:54:56,010
Saya tidak
akan menjelaskan itu.

1270
00:54:56,010 --> 00:54:58,400
Itu sistem tanda tangan yang buruk.

1271
00:54:58,400 --> 00:55:02,420
Jadi alasan mengapa ini terjadi
digunakan adalah sistem yang lebih baik

1272
00:55:02,420 --> 00:55:04,490
sudah dipatenkan.

1273
00:55:04,490 --> 00:55:11,180
Jadi ada sistem tanda tangan
yang lebih jelas, lebih nyata

1274
00:55:11,180 --> 00:55:14,240
lebih bersih, dan lebih kuat yang
dipatenkan oleh seorang Jerman ini,

1275
00:55:14,240 --> 00:55:15,170
Claus Schnorr.

1276
00:55:15,170 --> 00:55:17,660
Jadi tidak ada yang menggunakannya, atau
mungkin hanya sedikit orang yang menggunakannya.

1277
00:55:17,660 --> 00:55:21,860
Tapi secara umum, dengan adanya open
source dan standar-standar web,

1278
00:55:21,860 --> 00:55:25,590
teknologi yang dipatenkan benar-benar
menjadi sulit untuk berkembang.

1279
00:55:25,590 --> 00:55:27,140
Dan semua
kriptografer berkata,

1280
00:55:27,140 --> 00:55:29,360
baiklah, kita akan membuat
sistem lain ini

1281
00:55:29,360 --> 00:55:32,540
cukup berbeda sehingga
tidak melanggar paten.

1282
00:55:32,540 --> 00:55:36,200
Dan itu agak jelek.

1283
00:55:36,200 --> 00:55:38,720
Dia benar berfungsi sebagai
skema tanda tangan.

1284
00:55:38,720 --> 00:55:40,760
Tapi sebenarnya, Saya
akan menjelaskan

1285
00:55:40,760 --> 00:55:46,100
tanda tangan Schnorr,
yang jauh lebih masuk akal,

1286
00:55:46,100 --> 00:55:48,410
lebih mudah dimengerti
dan dimanipulasi,

1287
00:55:48,410 --> 00:55:50,840
dan patennya telah kedaluwarsa,
sehingga kita semua bisa menggunakannya

1288
00:55:50,840 --> 00:55:53,780
Dan itu mungkin akan
masuk ke Bitcoin.

1289
00:55:53,780 --> 00:55:56,490
Dan beberapa mata uang kripto
menggunakan tanda tangan Schnorr.

1290
00:55:56,490 --> 00:56:02,180
Saya pikir Monero menggunakan
tanda tangan seperti Schnorr.

1291
00:56:02,180 --> 00:56:05,480
Tetapi Bitcoin akan
mungkin memasukkannya

1292
00:56:05,480 --> 00:56:08,130
ke dalam Bitcoin pada
tahun berikutnya dan seterusnya.

1293
00:56:08,130 --> 00:56:10,220
Jadi hal-hal ini akan
lebih mudah diaplikasikan,

1294
00:56:10,220 --> 00:56:11,310
dan bisa kita pakai.

1295
00:56:11,310 --> 00:56:12,185
Lalu ada kode keluar.

1296
00:56:12,185 --> 00:56:13,620
Anda bisa menggunakannya sekarang.

1297
00:56:13,620 --> 00:56:14,120
OK.

1298
00:56:14,120 --> 00:56:14,410
Yah.

1299
00:56:14,410 --> 00:56:15,008
Maaf.

1300
00:56:15,008 --> 00:56:16,800
Paten sudah kedaluwarsa--
bebas untuk menggunakan 

1301
00:56:16,800 --> 00:56:18,350
algo yang lebih baik namun tidak boleh disebutkan namanya

1302
00:56:18,350 --> 00:56:20,352
Jadi yah.

1303
00:56:20,352 --> 00:56:22,310
Orang-orang tidak menyebutnya
tanda tangan Schnorr sesering itu.

1304
00:56:22,310 --> 00:56:24,800
Karena ini jadi seperti, yah, ini
adalah orang yang mencegah kita

1305
00:56:24,800 --> 00:56:28,900
untuk menggunakannya selama 20 tahun.

1306
00:56:28,900 --> 00:56:31,300
Dan terdapat beberapa modifikasi padanya.

1307
00:56:31,300 --> 00:56:31,800
OK.

1308
00:56:31,800 --> 00:56:36,350
Jadi tanda tangan kurva eliptik,
karena tidak ada nama yang lebih baik.

1309
00:56:36,350 --> 00:56:38,360
Ini adalah sebuah
penyederhanaan.

1310
00:56:38,360 --> 00:56:41,000
Dan ada bacaan
tentang bagaimana Anda bisa

1311
00:56:41,000 --> 00:56:41,907
melakukannya secara benar.

1312
00:56:41,907 --> 00:56:43,490
Tapi ini memang memberi
Anda ide yang benar.

1313
00:56:43,490 --> 00:56:48,170
Dan untuk satu penandatangan,
ini aman, dan berhasil.

1314
00:56:48,170 --> 00:56:51,050
Tapi setelahnya, Anda mungkin ingin
menambah hal lainnya

1315
00:56:51,050 --> 00:56:54,360
Jadi idenya adalah Anda punya
pesan Anda m, betul?

1316
00:56:54,360 --> 00:56:56,570
Sama seperti di lamport,
sama seperti di RSA, Anda

1317
00:56:56,570 --> 00:56:59,620
punya sebuah pesan m dan
kunci privat huruf kecil a.

1318
00:56:59,620 --> 00:57:03,755
Dan kunci publik Anda adalah
a kali G seperti yang kita katakan.

1319
00:57:03,755 --> 00:57:05,630
Kemudian, ketika Anda ingin
menandatangani, Anda sebenarnya

1320
00:57:05,630 --> 00:57:10,490
membuat pasangan kunci sekali pakai
untuk tanda tangan saja.

1321
00:57:10,490 --> 00:57:12,530
Dan mereka biasanya menyebutnya k.

1322
00:57:12,530 --> 00:57:15,650
Dan k adalah bilangan acak baru.

1323
00:57:15,650 --> 00:57:17,150
Itu adalah kunci privatnya.

1324
00:57:17,150 --> 00:57:20,308
Dan Anda akan
mengalikannya dengan G.

1325
00:57:20,308 --> 00:57:22,100
Dan mereka menyebut ini R.
Saya tidak tahu mengapa mereka

1326
00:57:22,100 --> 00:57:25,460
menggunakan huruf-huruf ini, tapi bagaimanapun juga.

1327
00:57:25,460 --> 00:57:30,680
K dikalikan G adalah R. R adalah kunci publik
lain yang Anda gunakan hanya

1328
00:57:30,680 --> 00:57:33,720
untuk tanda tangan ini.

1329
00:57:33,720 --> 00:57:37,170
Dan tanda tangannya sendiri
cukup mudah.

1330
00:57:37,170 --> 00:57:40,590
Sebagai penanda tangan, Anda
menghitung s, yaitu k--

1331
00:57:40,590 --> 00:57:42,750
kunci privat baru ini
yang baru saja Anda buat--

1332
00:57:42,750 --> 00:57:47,160
dikurangi hash dari
pesan Anda dipasangkan dengan R,

1333
00:57:47,160 --> 00:57:49,990
kunci public ini-- sehingga Anda mengkodekan
kunci publiknya dalam 33 byte,

1334
00:57:49,990 --> 00:57:50,910
tempelkan di sini--

1335
00:57:50,910 --> 00:57:55,650
dikalikan dengan a, kunci
privat normal Anda.

1336
00:57:55,650 --> 00:57:57,990
Kemudian tanda tangan Anda
adalah pasangan--

1337
00:57:57,990 --> 00:58:00,990
poin R dan skalar s.

1338
00:58:00,990 --> 00:58:03,390
Ini cukup banyak
untuk diproses.

1339
00:58:03,390 --> 00:58:06,150
Namun sebenarnya
tidak terlalu buruk, bukan?

1340
00:58:06,150 --> 00:58:07,110
Ini adalah sebuah skalar--

1341
00:58:07,110 --> 00:58:08,490
atas 32 bytes-- yang Anda buat

1342
00:58:08,490 --> 00:58:14,400
Hash-nya, ini adalah sebuah pesan,
juga akan seberapa panjang.

1343
00:58:14,400 --> 00:58:15,348
Ini 33 byte.

1344
00:58:15,348 --> 00:58:16,890
Lalu Anda menggabungkannya
menjadi satu-- hash.

1345
00:58:16,890 --> 00:58:20,550
Anda akan mendapatkan
32 byte skalar lainnya.

1346
00:58:20,550 --> 00:58:23,320
Anda kalikan kedua skalar tersebut.

1347
00:58:23,320 --> 00:58:26,760
Jadi sebenarnya, satu-satunya
operasi kurva eliptik

1348
00:58:26,760 --> 00:58:29,160
di sini adalah menghitung berapa nilai R.

1349
00:58:29,160 --> 00:58:30,810
Saat Anda sebenarnya
menghitung s,

1350
00:58:30,810 --> 00:58:33,840
semua hal ini hanyalah skalar,
jadi itu sangat cepat.

1351
00:58:33,840 --> 00:58:36,090
Jadi dalam hal komputer
praktis,

1352
00:58:36,090 --> 00:58:39,720
melakukan operasi ini
sedikit lambat.

1353
00:58:39,720 --> 00:58:42,270
Karena Anda melakukan
penambahan poin itu sebanyak

1354
00:58:42,270 --> 00:58:44,160
berkali-kali.

1355
00:58:44,160 --> 00:58:47,430
Jadi kode yang cukup baik,
CPU yang cukup baik, dapat

1356
00:58:47,430 --> 00:58:53,100
melakukan ribuan
operasi seperti ini

1357
00:58:53,100 --> 00:58:56,610
per detik, di mana hal tersebut cukup baik.

1358
00:58:56,610 --> 00:58:59,190
Anda bisa melakukan dalam jumlah yang banyak,
tapi itu lumayan lambat.

1359
00:58:59,190 --> 00:59:01,770
Dan itu lebih lambat
dibandingkan dengan fungsi hash.

1360
00:59:01,770 --> 00:59:04,770
Anda dapat melakukan jutaan iterasi
dari sebuah hash function per detik

1361
00:59:04,770 --> 00:59:07,350
pada bagian inti, atau Anda bisa
lakukan, mungkin, 1.000 atau 2.000

1362
00:59:07,350 --> 00:59:11,980
hal semacam ini, jadi
masih cukup cepat tapi lebih lambat.

1363
00:59:11,980 --> 00:59:16,585
Jadi prosedur penandatanganan ini
membutuhkan sedikit waktu.

1364
00:59:16,585 --> 00:59:18,210
Sebenarnya ini membutuhkan
waktu yang sangat sedikit.

1365
00:59:18,210 --> 00:59:23,100
Karena Anda hanya mengurangi
dan mengalikan bilangan bulat

1366
00:59:23,100 --> 00:59:25,810
skalar 32 byte, yang jauh lebih cepat.

1367
00:59:25,810 --> 00:59:26,310
OK.

1368
00:59:26,310 --> 00:59:29,300
Jadi apakah ini masuk akal?

1369
00:59:29,300 --> 00:59:31,750
Kita akan masuk sedikit ke
bagaimana Anda tidak bisa memalsukan ini.

1370
00:59:31,750 --> 00:59:32,250
OK.

1371
00:59:32,250 --> 00:59:32,750
Maaf.

1372
00:59:32,750 --> 00:59:33,680
Jadi pertama verifikasi.

1373
00:59:33,680 --> 00:59:34,280
Maaf.

1374
00:59:34,280 --> 00:59:39,140
Jadi bagaimana Anda, jika
ada yang mengetahui atau bisa berpikir,

1375
00:59:39,140 --> 00:59:43,010
bagaimana Anda
memverifikasi ini, betul?

1376
00:59:43,010 --> 00:59:44,460
Saya mengetahui kunci publiknya--

1377
00:59:44,460 --> 00:59:47,420
A kapital, yaitu
a kecil kali G--

1378
00:59:47,420 --> 00:59:49,340
dan kemudian Anda
memberikan Saya sebuah pesan m,

1379
00:59:49,340 --> 00:59:51,800
dan Anda memberikan saya sebuah
tandatangan, yaitu R dan s.

1380
00:59:51,800 --> 00:59:53,900
Dan mereka telah menghitungnya
dengan cara ini.

1381
00:59:53,900 --> 00:59:57,020
Saya tidak bisa memverifikasi
persamaan ini sendirian

1382
00:59:57,020 --> 00:59:58,610
karena saya tidak tahu berapa nilai k.

1383
00:59:58,610 --> 01:00:00,560
Saya tidak tahu berapa nilai
a kecil, benar?

1384
01:00:00,560 --> 01:00:09,470
Saya hanya diberikan nilai R, s, m, dan
A besar. Lalu bagaimana cara kita memverifikasi ini?

1385
01:00:09,470 --> 01:00:13,510
AUDIENS: apakan saya boleh, contohnya,
mengambil hash dari pesan,

1386
01:00:13,510 --> 01:00:21,124
menggunakan R, lalu mencoba
a acak dan itu--

1387
01:00:21,124 --> 01:00:22,250
pada, maaf.

1388
01:00:22,250 --> 01:00:23,000
TADGE DRYJA: Yah.

1389
01:00:23,000 --> 01:00:24,350
Apakah Anda mempunyai salah satunya?

1390
01:00:24,350 --> 01:00:26,850
AUDIENS: Jadi mencoba secara acak
mungkin [TIDAK TERDENGAR] karena--

1391
01:00:26,850 --> 01:00:27,685
TADGE DRYJA:
Ada banyak, yah.

1392
01:00:27,685 --> 01:00:28,893
AUDIENCE: --ada terlalu banyak.

1393
01:00:28,893 --> 01:00:30,550
Yang lama yang
tidak Anda ketahui.

1394
01:00:30,550 --> 01:00:33,910
Tapi saya pikir ada satu hal lagi
yang Anda bisa lakukan adalah dengan mengambil sedikit s

1395
01:00:33,910 --> 01:00:35,872
dan mengalikannya dengan G besar.

1396
01:00:35,872 --> 01:00:36,580
TADGE DRYJA: Ya.

1397
01:00:36,580 --> 01:00:37,650
AUDIENS: Dan kemudian lakukan beberapa--

1398
01:00:37,650 --> 01:00:38,430
TADGE DRYJA: Ya.

1399
01:00:38,430 --> 01:00:41,320
Jadi ide dasarnya--
ya, Anda benar.

1400
01:00:41,320 --> 01:00:43,630
Kalikan sisi ini
dengan G. Lalu Anda juga

1401
01:00:43,630 --> 01:00:46,330
harus mengalikan
sisi lain dengan G, benar?

1402
01:00:46,330 --> 01:00:50,170
Jadi Anda katakan, OK, baiklah,
sebagai verifikator--

1403
01:00:50,170 --> 01:00:51,732
saya punya R, Saya punya s--

1404
01:00:51,732 --> 01:00:53,590
Saya mengalikan s dengan
G, dan sekarang saya harus

1405
01:00:53,590 --> 01:00:57,800
mengalikan sisi ini dengan G.
Dan seperti apa bentuknya?

1406
01:00:57,800 --> 01:00:59,764
Baik, apakah k kali G?

1407
01:00:59,764 --> 01:01:00,264
AUDIENS: R.

1408
01:01:00,264 --> 01:01:03,490
TADGE DRYJA: R. Berapa
a kecil dikalikan dengan G?

1409
01:01:03,490 --> 01:01:07,140
A besar. Maka, yah.

1410
01:01:07,140 --> 01:01:09,090
Saya mau memastikan.

1411
01:01:09,090 --> 01:01:11,490
Saya mau memastikan bahwa
persamaan ini digunakan,

1412
01:01:11,490 --> 01:01:15,120
benar-- s sama dengan k minus
hash ini dikalikan a kecil.

1413
01:01:15,120 --> 01:01:17,490
Mengkalikan dua sisi
dengan G, Saya mendapatkan s kali G,

1414
01:01:17,490 --> 01:01:21,660
sama dengan k dikali G minus 
hash dikali a kecil dikali

1415
01:01:21,660 --> 01:01:26,070
G. Ini adalah A besar. Ini R.

1416
01:01:26,070 --> 01:01:29,490
Hei, sekarang saya tau semuanya
di sini sebagai verifikator, benar?

1417
01:01:29,490 --> 01:01:30,552
Saya tahu berapa nilai s kali G.

1418
01:01:30,552 --> 01:01:31,260
Saya tahu berapa nilai R.

1419
01:01:31,260 --> 01:01:32,490
Saya tahu berapa nilai A besar.

1420
01:01:32,490 --> 01:01:35,593
Saya tahu apa yang masuk
pada fungsi hash ini.

1421
01:01:35,593 --> 01:01:36,510
Jadi saya hanya mengatakan, OK. 

1422
01:01:36,510 --> 01:01:44,130
Baik, saya susun ulang sedikit,
dan saya katakan, R sama dengan ini?

1423
01:01:44,130 --> 01:01:46,350
Dan jika iya, maka itu
adalah tanda tangan yang valid.

1424
01:01:46,350 --> 01:01:50,620
Jika tidak, maka itu 
bukan tanda tangan yang valid.

1425
01:01:50,620 --> 01:01:51,900
Ada pertanyaan tentang ini?

1426
01:01:51,900 --> 01:01:56,850
Does this makes sense, mostly?

1427
01:01:59,850 --> 01:02:04,620
So for the verification, it's
a bit more CPU-intense, right?

1428
01:02:04,620 --> 01:02:06,030
You're given a scalar.

1429
01:02:06,030 --> 01:02:13,270
You multiply by G. You
also have to multiply A--

1430
01:02:13,270 --> 01:02:14,720
this is actually more costly--

1431
01:02:14,720 --> 01:02:16,870
you have to multiply
A by this hash.

1432
01:02:16,870 --> 01:02:18,370
The reason that's
more costly-- it's

1433
01:02:18,370 --> 01:02:20,660
still a scalar times a point.

1434
01:02:20,660 --> 01:02:25,060
The thing is, since G is
used for multiplying a lot,

1435
01:02:25,060 --> 01:02:29,710
you precompute all sorts
of coefficients times G,

1436
01:02:29,710 --> 01:02:34,590
and you store them in RAM
or in your CPU somewhere.

1437
01:02:34,590 --> 01:02:36,370
So multiplying by G
is a little bit faster

1438
01:02:36,370 --> 01:02:38,620
because you do it a lot,
you can precompute a lot,

1439
01:02:38,620 --> 01:02:41,170
whereas multiplying by A is
different each time for all

1440
01:02:41,170 --> 01:02:42,610
the different signatures.

1441
01:02:42,610 --> 01:02:45,340
So this is a little
bit slower, in general.

1442
01:02:45,340 --> 01:02:48,190
So it takes a little
bit more CPU time

1443
01:02:48,190 --> 01:02:51,820
to verify a signature
than to create one,

1444
01:02:51,820 --> 01:02:53,660
something like twice as much.

1445
01:02:53,660 --> 01:02:55,690
But still, you can
do this pretty fast.

1446
01:02:55,690 --> 01:02:59,000
On a modern computer, you can
do thousands of these a second.

1447
01:02:59,000 --> 01:02:59,500
OK.

1448
01:02:59,500 --> 01:03:01,180
Any questions so far?

1449
01:03:01,180 --> 01:03:05,800
I'll go a little bit into why
this is not forgible, right?

1450
01:03:05,800 --> 01:03:09,220
So I want to forge a signature.

1451
01:03:09,220 --> 01:03:14,980
Well, I don't know little a.

1452
01:03:14,980 --> 01:03:18,430
But why don't I make up
a k and compute s and R?

1453
01:03:18,430 --> 01:03:20,470
But I need a, right?

1454
01:03:20,470 --> 01:03:23,140
So I'm going to say, OK,
this is the equation I want.

1455
01:03:23,140 --> 01:03:28,120
I'll just make up my own
k and make up my own k, s,

1456
01:03:28,120 --> 01:03:31,000
that'll satisfy this.

1457
01:03:31,000 --> 01:03:33,670
Without a, I really can't
make a valid s, right?

1458
01:03:33,670 --> 01:03:34,945
I can make something up here.

1459
01:03:38,410 --> 01:03:42,400
But I can't compute it because
I don't know here, right?

1460
01:03:42,400 --> 01:03:45,260
I can try to grind through hash
functions, but it won't work.

1461
01:03:45,260 --> 01:03:48,040
The basic problem
is if I make up an s

1462
01:03:48,040 --> 01:03:50,860
and solve for R, right--

1463
01:03:50,860 --> 01:03:52,780
I can say, well,
I know what R is--

1464
01:03:52,780 --> 01:03:56,413
but the thing is R is in
the hash function, as well.

1465
01:03:56,413 --> 01:03:58,330
It's the one-wayness of
the hash function that

1466
01:03:58,330 --> 01:04:01,142
actually breaks this, right?

1467
01:04:01,142 --> 01:04:03,100
So I could say, well,
let me solve for R. Well,

1468
01:04:03,100 --> 01:04:10,710
R is the hash of m and R
times a plus s times G.

1469
01:04:10,710 --> 01:04:13,980
If I can come up with a
valid R here, I can do this.

1470
01:04:13,980 --> 01:04:19,650
The problem is R is defined
by the hash of R in this case.

1471
01:04:19,650 --> 01:04:22,630
I can't compute this, and I
can't cancel this out, right?

1472
01:04:22,630 --> 01:04:25,920
So you can see just like, OK,
I need to solve for R. Well,

1473
01:04:25,920 --> 01:04:27,450
but it's already in here.

1474
01:04:27,450 --> 01:04:28,440
I'm stuck.

1475
01:04:28,440 --> 01:04:32,480
If I don't know k, I can't come
up with a signature, either.

1476
01:04:37,110 --> 01:04:37,610
OK.

1477
01:04:37,610 --> 01:04:40,940
There is one footgun
with EC signatures.

1478
01:04:40,940 --> 01:04:46,160
If you use the same R value
for different signatures

1479
01:04:46,160 --> 01:04:50,130
with the same pubkey, you
reveal your private key.

1480
01:04:50,130 --> 01:04:53,420
So k has to be random
and new every time.

1481
01:04:56,515 --> 01:04:57,890
If you look through
the equation,

1482
01:04:57,890 --> 01:04:59,705
you'll see how you can solve--

1483
01:04:59,705 --> 01:05:05,150
if you have two of the same
k's with different s's--

1484
01:05:05,150 --> 01:05:06,770
you can solve for k.

1485
01:05:06,770 --> 01:05:11,910
And then, once you
solve for k given

1486
01:05:11,910 --> 01:05:15,030
this, if you know
what k is, you can

1487
01:05:15,030 --> 01:05:17,400
find what little a is,
right, as a verifier.

1488
01:05:17,400 --> 01:05:19,680
You can say, well,
you gave me s.

1489
01:05:19,680 --> 01:05:21,090
That's part of the signature.

1490
01:05:21,090 --> 01:05:23,760
I know this whole coefficient.

1491
01:05:23,760 --> 01:05:27,410
If I know k, I can solve for
little a by dividing this out.

1492
01:05:27,410 --> 01:05:29,220
So always use a new k value.

1493
01:05:29,220 --> 01:05:31,980
There have been many
cases where people don't.

1494
01:05:31,980 --> 01:05:37,020
Probably the most famous one
is PlayStation 3 used ECDSA.

1495
01:05:37,020 --> 01:05:40,470
And they used a fixed k value
for signing all their code.

1496
01:05:40,470 --> 01:05:43,320
And that allowed people to
calculate their private keys

1497
01:05:43,320 --> 01:05:45,870
and then run pirated games.

1498
01:05:45,870 --> 01:05:47,400
That was actually
the first time I

1499
01:05:47,400 --> 01:05:49,594
learned about elliptic
curve signatures,

1500
01:05:49,594 --> 01:05:53,670
in 2010 or something.

1501
01:05:53,670 --> 01:05:55,800
So actually, there's
interesting tutorials

1502
01:05:55,800 --> 01:05:58,830
written by the hackers who
broke Playstation 3 about how

1503
01:05:58,830 --> 01:05:59,590
this works.

1504
01:05:59,590 --> 01:06:02,500
And that's when I
first read about it.

1505
01:06:02,500 --> 01:06:03,000
OK.

1506
01:06:03,000 --> 01:06:06,370
We're almost out of time.

1507
01:06:06,370 --> 01:06:10,090
Any questions about
this stuff so far?

1508
01:06:10,090 --> 01:06:11,340
OK.

1509
01:06:11,340 --> 01:06:15,787
So this is a
signature algorithm.

1510
01:06:15,787 --> 01:06:16,620
It's like, OK, fine.

1511
01:06:16,620 --> 01:06:17,130
This works.

1512
01:06:17,130 --> 01:06:20,460
I can sign, same as lamport
signatures, same as RSA.

1513
01:06:20,460 --> 01:06:22,530
What's really nice about
the elliptic curve stuff

1514
01:06:22,530 --> 01:06:26,580
is you can do more
than just signatures.

1515
01:06:26,580 --> 01:06:28,890
There's all sorts of
fun things you can do.

1516
01:06:28,890 --> 01:06:31,380
And it seems like a
fairly unexplored area

1517
01:06:31,380 --> 01:06:34,440
in that I've found
fun things that you

1518
01:06:34,440 --> 01:06:36,690
can do that I guess are novel.

1519
01:06:36,690 --> 01:06:38,610
And I'm not an expert
on this at all.

1520
01:06:38,610 --> 01:06:40,800
It's just that it's a
fairly new area of research

1521
01:06:40,800 --> 01:06:43,920
in how to do cool
bitcoiny cryptocurrency

1522
01:06:43,920 --> 01:06:46,290
things with these curves
and points and stuff.

1523
01:06:46,290 --> 01:06:51,900
So I'll go through a couple
fun things you can do.

1524
01:06:51,900 --> 01:06:53,080
Fun with points.

1525
01:06:53,080 --> 01:06:53,580
OK.

1526
01:06:53,580 --> 01:06:55,650
So I'm not using an asterisk.

1527
01:06:55,650 --> 01:06:59,880
Just b times G.
So let's say Alice

1528
01:06:59,880 --> 01:07:04,620
has a public key A. Bob
has a public key B, right,

1529
01:07:04,620 --> 01:07:09,300
which is little a times G
or little b times G. Well,

1530
01:07:09,300 --> 01:07:10,470
this is weird.

1531
01:07:10,470 --> 01:07:12,970
Little a times big B--

1532
01:07:12,970 --> 01:07:16,290
Alice's private key multiplied
by Bob's public key--

1533
01:07:16,290 --> 01:07:18,480
you can do that, right?--

1534
01:07:18,480 --> 01:07:21,850
is equal to Bob's private
key times Alice's public

1535
01:07:21,850 --> 01:07:23,590
key, right?

1536
01:07:23,590 --> 01:07:24,310
It's commutative.

1537
01:07:24,310 --> 01:07:25,860
The multiplication
is commutative.

1538
01:07:25,860 --> 01:07:27,030
That's weird, right?

1539
01:07:27,030 --> 01:07:30,468
It's just a times G times
b, which is the same--

1540
01:07:30,468 --> 01:07:32,010
or it doesn't matter
the order-- it's

1541
01:07:32,010 --> 01:07:36,360
the same as b times G times a,
which is the same as a times

1542
01:07:36,360 --> 01:07:40,320
b times G. And let's
call that C. C-- this

1543
01:07:40,320 --> 01:07:42,950
is called a Diffie-Hellman
key exchange point.

1544
01:07:42,950 --> 01:07:47,550
Diffie and Hellman are two also
late-'70s PhD students who came

1545
01:07:47,550 --> 01:07:49,470
up with all this cool stuff.

1546
01:07:49,470 --> 01:07:50,908
No, wait.

1547
01:07:50,908 --> 01:07:51,950
Diffie was a PhD student.

1548
01:07:51,950 --> 01:07:52,950
Hellman was his advisor?

1549
01:07:52,950 --> 01:07:53,970
I don't remember.

1550
01:07:53,970 --> 01:07:57,540
Anyway, they came
up with this idea.

1551
01:07:57,540 --> 01:07:59,340
And this is a shared point.

1552
01:07:59,340 --> 01:08:02,450
What would this be useful for?

1553
01:08:02,450 --> 01:08:04,070
It's actually super useful.

1554
01:08:04,070 --> 01:08:05,485
Can you think of like, oh, OK.

1555
01:08:05,485 --> 01:08:06,110
We can do this.

1556
01:08:06,110 --> 01:08:09,170
We can compute C. Why
would we want to do that?

1557
01:08:09,170 --> 01:08:11,446
Any applications
you can think of?

1558
01:08:11,446 --> 01:08:12,402
Yeah?

1559
01:08:12,402 --> 01:08:15,270
AUDIENCE: Trying to share
keys with people without both

1560
01:08:15,270 --> 01:08:17,182
of them knowing who
they are and evaluating

1561
01:08:17,182 --> 01:08:18,664
the other set of keys.

1562
01:08:18,664 --> 01:08:19,414
TADGE DRYJA: Yeah.

1563
01:08:19,414 --> 01:08:21,979
It's really cool to share keys.

1564
01:08:21,979 --> 01:08:25,609
So this is also done if
you have a web browser.

1565
01:08:25,609 --> 01:08:28,460
I think it's all elliptic curve
Diffie-Hellman now, mostly.

1566
01:08:28,460 --> 01:08:30,740
But if you have a web browser
and you go to a website,

1567
01:08:30,740 --> 01:08:35,300
this is happening, basically,
for every HTTPS request.

1568
01:08:35,300 --> 01:08:37,550
Because you can
use C as a sort of

1569
01:08:37,550 --> 01:08:41,750
shared key and encrypt
things with it.

1570
01:08:41,750 --> 01:08:45,620
The idea is big A can be public.

1571
01:08:45,620 --> 01:08:48,529
Big B can be public.

1572
01:08:48,529 --> 01:08:50,330
Point C will not be public.

1573
01:08:50,330 --> 01:08:52,130
The only way to
compute it is to know

1574
01:08:52,130 --> 01:08:54,979
either Alice's private
key-- little a--

1575
01:08:54,979 --> 01:08:58,790
or Bob's private key, little b.

1576
01:08:58,790 --> 01:09:02,270
Even though you can
see the public keys,

1577
01:09:02,270 --> 01:09:06,470
you can't compute C from
just the public keys, right?

1578
01:09:06,470 --> 01:09:12,229
Because big A times big
B, that's not defined.

1579
01:09:12,229 --> 01:09:13,910
You can't multiply the points.

1580
01:09:13,910 --> 01:09:16,670
You have to multiply
the point by a scalar.

1581
01:09:16,670 --> 01:09:18,260
And since you don't
know the scalars

1582
01:09:18,260 --> 01:09:20,450
from viewing this
exchange, you can't

1583
01:09:20,450 --> 01:09:23,810
compute C. But Alice and
Bob can both compute C.

1584
01:09:23,810 --> 01:09:25,710
So this is really useful.

1585
01:09:25,710 --> 01:09:30,229
You can compute C. You
can use it for encryption.

1586
01:09:30,229 --> 01:09:33,319
You can use it to prove you
are who you say you are.

1587
01:09:33,319 --> 01:09:36,200
You can use it as an
interactive verification

1588
01:09:36,200 --> 01:09:38,300
where you say, OK, I'm Bob.

1589
01:09:38,300 --> 01:09:41,680
I'm going to make random point.

1590
01:09:41,680 --> 01:09:42,930
I'm going to give that to you.

1591
01:09:42,930 --> 01:09:46,680
Prove you know your
private key-- little a--

1592
01:09:46,680 --> 01:09:50,439
by telling me what C is, right?

1593
01:09:50,439 --> 01:09:54,880
So I can make a random
key here, give it to you.

1594
01:09:54,880 --> 01:09:58,340
You return C. I verify that
that's the right C. And I say,

1595
01:09:58,340 --> 01:10:00,460
OK, well you must know little a.

1596
01:10:00,460 --> 01:10:03,100
You haven't shown me
a little a, but you've

1597
01:10:03,100 --> 01:10:05,260
proven that you know it,
so proof of knowledge

1598
01:10:05,260 --> 01:10:06,680
of the private key.

1599
01:10:06,680 --> 01:10:11,000
So you can use that for
logins instead of passwords.

1600
01:10:11,000 --> 01:10:13,280
And it's much simpler
than a signature.

1601
01:10:13,280 --> 01:10:16,180
So that's really cool.

1602
01:10:16,180 --> 01:10:17,920
All sorts of things
you can do with that.

1603
01:10:17,920 --> 01:10:19,990
The last part, you can
have fun with points.

1604
01:10:19,990 --> 01:10:22,690
And I use this in my software.

1605
01:10:22,690 --> 01:10:25,090
So you say, OK, well,
there's a public key A.

1606
01:10:25,090 --> 01:10:27,430
There's a public
key B. And we'll

1607
01:10:27,430 --> 01:10:32,590
define D as the sum of
these two public keys.

1608
01:10:32,590 --> 01:10:35,110
The thing is if you're
summing these two public keys,

1609
01:10:35,110 --> 01:10:36,820
it's commutative,
and it is the same

1610
01:10:36,820 --> 01:10:41,890
as saying the sum of the two
private keys times G, right?

1611
01:10:41,890 --> 01:10:45,910
a times G plus b times
G is the same as a plus

1612
01:10:45,910 --> 01:10:50,650
b times G, which is another
really cool property.

1613
01:10:50,650 --> 01:10:54,310
So what if I compute
this public key D,

1614
01:10:54,310 --> 01:10:59,410
and I say I want a
signature from public key D?

1615
01:10:59,410 --> 01:11:00,130
You can.

1616
01:11:00,130 --> 01:11:01,900
And you so the
private key, little d,

1617
01:11:01,900 --> 01:11:07,060
which can sign for this, is
just little a plus little b.

1618
01:11:07,060 --> 01:11:09,192
So you can make a combined key.

1619
01:11:09,192 --> 01:11:10,150
And then either party--

1620
01:11:10,150 --> 01:11:14,260
Alice has little a,
Bob has a little b--

1621
01:11:14,260 --> 01:11:16,000
and they could reveal
it to each other

1622
01:11:16,000 --> 01:11:19,750
and allow the other person to
make a signature with D later.

1623
01:11:24,400 --> 01:11:27,010
I use this in the lightning
network software I've had,

1624
01:11:27,010 --> 01:11:30,670
where, basically, you say,
look, we'll compute D,

1625
01:11:30,670 --> 01:11:36,150
and I can give you the
private key, right?

1626
01:11:36,150 --> 01:11:36,750
I'm Bob.

1627
01:11:36,750 --> 01:11:39,330
And I say, OK, here's point b.

1628
01:11:39,330 --> 01:11:40,270
Here's point a.

1629
01:11:40,270 --> 01:11:41,700
We add them together.

1630
01:11:41,700 --> 01:11:45,030
And then, Alice, if I give
you my private key, now

1631
01:11:45,030 --> 01:11:47,550
you can sign, but
I can't, right?

1632
01:11:47,550 --> 01:11:50,610
So I'll give you
the private key to D

1633
01:11:50,610 --> 01:11:52,170
from some information I have.

1634
01:11:52,170 --> 01:11:54,030
Or you could give me
the private key to D

1635
01:11:54,030 --> 01:11:56,370
by sharing little a with me.

1636
01:11:56,370 --> 01:11:58,020
So this is another
useful thing where

1637
01:11:58,020 --> 01:12:00,150
you can have something
where both parties know

1638
01:12:00,150 --> 01:12:03,120
that neither party can
sign unless they give them

1639
01:12:03,120 --> 01:12:05,110
something.

1640
01:12:05,110 --> 01:12:09,450
And you can use that for bitcoin
addresses, things like that.

1641
01:12:09,450 --> 01:12:11,610
Before you even
get to signatures,

1642
01:12:11,610 --> 01:12:13,000
you can share keys and stuff.

1643
01:12:13,000 --> 01:12:15,390
There's all sorts
of super fun things

1644
01:12:15,390 --> 01:12:18,690
you can do with these points
and curves and systems.

1645
01:12:18,690 --> 01:12:22,860
Multisignatures-- I put
a link to a PDF file

1646
01:12:22,860 --> 01:12:26,760
that's very recent and kind
of overkill and over my head,

1647
01:12:26,760 --> 01:12:28,530
as well.

1648
01:12:28,530 --> 01:12:31,600
But you can do signatures where
you aggregate the signatures.

1649
01:12:31,600 --> 01:12:32,100
But

1650
01:12:32,100 --> 01:12:34,333
There's ways to
say, OK, well, I'm

1651
01:12:34,333 --> 01:12:36,000
going to add all these
R points, and I'm

1652
01:12:36,000 --> 01:12:37,333
going to add all these s points.

1653
01:12:37,333 --> 01:12:39,900
And I can have
signatures that are

1654
01:12:39,900 --> 01:12:41,820
from a bunch of
different people that

1655
01:12:41,820 --> 01:12:44,940
collapse into the same
size as a single signature.

1656
01:12:44,940 --> 01:12:47,490
And I can verify that they're
all signing the same thing

1657
01:12:47,490 --> 01:12:49,860
or, possibly, that they're
all signing different things.

1658
01:12:49,860 --> 01:12:52,410
So I have 10
different signatures

1659
01:12:52,410 --> 01:12:55,260
from different people
signing different messages.

1660
01:12:55,260 --> 01:12:57,220
But I can add up
all the s values.

1661
01:12:57,220 --> 01:12:58,440
I have to keep the R values.

1662
01:12:58,440 --> 01:13:01,710
But now these 10 signatures,
instead of being 64 bytes

1663
01:13:01,710 --> 01:13:03,840
each are more like
32 bites each.

1664
01:13:03,840 --> 01:13:07,360
And there's one extra 32
byte value for all of them.

1665
01:13:07,360 --> 01:13:08,970
So there's a lot
of really cool ways

1666
01:13:08,970 --> 01:13:12,330
you can combine things,
make things smaller,

1667
01:13:12,330 --> 01:13:14,920
make things really versatile,
where we can share keys,

1668
01:13:14,920 --> 01:13:17,250
things like that,
which you can't

1669
01:13:17,250 --> 01:13:20,670
do with hash-based
signatures, hash functions.

1670
01:13:20,670 --> 01:13:22,170
And so it's really fun.

1671
01:13:22,170 --> 01:13:24,240
One worry is that if
quantum computers ever

1672
01:13:24,240 --> 01:13:26,850
become really a thing, all
this stuff stops working.

1673
01:13:26,850 --> 01:13:29,070
All the elliptic curve
stuff doesn't work anymore.

1674
01:13:29,070 --> 01:13:31,950
You can figure out what
people's private keys are,

1675
01:13:31,950 --> 01:13:34,320
whereas hash stuff, hash
things like lamport signatures,

1676
01:13:34,320 --> 01:13:36,060
still work.

1677
01:13:36,060 --> 01:13:38,460
So there's some talk
of hey, we should

1678
01:13:38,460 --> 01:13:42,360
prepare for if that ever happens
and make efficient, effective

1679
01:13:42,360 --> 01:13:44,520
hash-based signatures
and use them

1680
01:13:44,520 --> 01:13:46,608
in something like
Bitcoin or Ethereum.

1681
01:13:46,608 --> 01:13:48,900
People haven't yet because
the overhead is really high.

1682
01:13:48,900 --> 01:13:50,940
It's really big.

1683
01:13:50,940 --> 01:13:52,710
The real thing is
all these fun things

1684
01:13:52,710 --> 01:13:55,270
might disappear in
the next 10, 20 years.

1685
01:13:55,270 --> 01:13:55,770
Who knows?

1686
01:13:55,770 --> 01:13:56,880
But there's lots of cool stuff.

1687
01:13:56,880 --> 01:13:57,880
What do we do with this?

1688
01:13:57,880 --> 01:13:59,760
So we're not going
to do anything yet

1689
01:13:59,760 --> 01:14:01,350
in terms of problem sets.

1690
01:14:01,350 --> 01:14:03,540
It's a little hard to
program it directly.

1691
01:14:03,540 --> 01:14:04,730
But there's libraries.

1692
01:14:04,730 --> 01:14:06,355
And the libraries
have fairly easy use,

1693
01:14:06,355 --> 01:14:08,980
where it's multiply
by G is a function,

1694
01:14:08,980 --> 01:14:11,140
and multiply by this
point is a function.

1695
01:14:11,140 --> 01:14:13,140
So this is groundwork for
cool stuff you can do.

1696
01:14:13,140 --> 01:14:15,420
And it's really nice
because it's a new area.

1697
01:14:15,420 --> 01:14:18,570
And I'm not an expert on this,
but I've come up with stuff

1698
01:14:18,570 --> 01:14:20,640
that people have cited me on.

1699
01:14:20,640 --> 01:14:23,350
And they're like, yeah, I guess
no one thought of that before.

1700
01:14:23,350 --> 01:14:25,240
There's a lot of things.

1701
01:14:25,240 --> 01:14:26,760
There's one very
recent one called

1702
01:14:26,760 --> 01:14:28,453
Taproot, where it's one line.

1703
01:14:28,453 --> 01:14:29,370
You're like, oh, yeah.

1704
01:14:29,370 --> 01:14:30,750
That works.

1705
01:14:30,750 --> 01:14:33,930
And it's just these sort of
elliptic curve operations.

1706
01:14:33,930 --> 01:14:35,220
It's like, yeah, that works.

1707
01:14:35,220 --> 01:14:36,352
That's really useful.

1708
01:14:36,352 --> 01:14:37,560
How did no one think of that?

1709
01:14:37,560 --> 01:14:38,370
It's one line.

1710
01:14:38,370 --> 01:14:39,180
Wow.

1711
01:14:39,180 --> 01:14:40,320
So there's just
not a ton of people

1712
01:14:40,320 --> 01:14:41,570
working on this kind of stuff.

1713
01:14:41,570 --> 01:14:43,490
And so it's kind of fun.
