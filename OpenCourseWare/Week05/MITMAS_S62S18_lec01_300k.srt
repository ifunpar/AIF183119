1
00:00:00,845 --> 00:00:03,220
WANITA: Konten berikut diberikan
di bawah lisensi

2
00:00:03,220 --> 00:00:04,610
Creative Commons.

3
00:00:04,610 --> 00:00:06,820
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,820 --> 00:00:10,910
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,910 --> 00:00:13,480
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:13,480 --> 00:00:15,970
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:15,970 --> 00:00:17,820
mitopencourseware@ocw.mit.edu.

8
00:00:22,780 --> 00:00:24,850
NEHA NARULA: OK, mari kita mulai.

9
00:00:24,850 --> 00:00:25,430
OK?

10
00:00:25,430 --> 00:00:26,630
OK baik.

11
00:00:26,630 --> 00:00:28,700
Kita di sini akan berbicara
tentang pembangunan dan desain

12
00:00:28,700 --> 00:00:30,009
mata uang kripto (cryptocurrency).

13
00:00:30,009 --> 00:00:32,509
Saya rasa pertanyaan yang pertama
muncul tentu saja

14
00:00:32,509 --> 00:00:34,940
adalah apa itu cryptocurrency?

15
00:00:34,940 --> 00:00:39,892
Jadi kata ini diciptakan kurang lebih
10 tahun lalu saat--

16
00:00:39,892 --> 00:00:42,350
Saya tidak tahu berapa banyak dari kalian
tahu asal mula ceritanya dari mana

17
00:00:42,350 --> 00:00:45,800
bitcoin muncul, tetapi pada dasarnya
sebuah nama samaran (pseudonym) muncul di internet

18
00:00:45,800 --> 00:00:49,700
meninggalkan sebuah paper ilmiah dan
kode terbuka (open source)

19
00:00:49,700 --> 00:00:52,530
di sebuah forum dan milis,
dan berkata, hei,

20
00:00:52,530 --> 00:00:55,040
saya punya ide ini yang
dinamakan bitcoin.

21
00:00:55,040 --> 00:00:57,055
Ini seperti
uang elektronik.

22
00:00:57,055 --> 00:00:58,430
Ini menurut saya
bagaimana itu bisa bekerja,

23
00:00:58,430 --> 00:01:01,100
dan ini adalah kode jika Anda
ingin menjalankannya dan menjadi bagian

24
00:01:01,100 --> 00:01:02,820
dari jaringan peer-to-peer.

25
00:01:02,820 --> 00:01:04,220
Kita tidak tahu siapa
orang ini.

26
00:01:04,220 --> 00:01:06,710
Orang ini pada dasarnya
menghilang begitu saja

27
00:01:06,710 --> 00:01:09,350
dari internet dan
dari dunia ini.

28
00:01:09,350 --> 00:01:12,470
Tetapi itu membuat sesuatu
yang menangkap

29
00:01:12,470 --> 00:01:16,160
imajinasi banyak orang
dan sudah, bergantung

30
00:01:16,160 --> 00:01:18,200
bagaimana Anda mengukurnya,
membuat nilai ekonomi

31
00:01:18,200 --> 00:01:20,690
senilai milyaran dan
milyaran dolar

32
00:01:20,690 --> 00:01:24,320
dan menginsipirasi banyak
orang untuk berpikir tentang bagaimana

33
00:01:24,320 --> 00:01:27,710
menggunakan teknologi ini untuk
memecahkan banyak sekali masalah

34
00:01:27,710 --> 00:01:30,080
di luar pembayaran elektronik.

35
00:01:30,080 --> 00:01:34,160
Jadi cryptocurrency dan
teknologi di belakangnya

36
00:01:34,160 --> 00:01:39,440
menginsipirasi orang untuk berpikir tentang bagaimana
membantu orang yang tidak terjamah bank formal

37
00:01:39,440 --> 00:01:43,430
membuat banyak hal lebih mudah
diaudit dan ditelusuri

38
00:01:43,430 --> 00:01:46,730
menghilangkan perantara
terpercaya dan institusi

39
00:01:46,730 --> 00:01:51,260
pada situasi tertentu,
dan pada dasarnya menyelesaikan

40
00:01:51,260 --> 00:01:54,770
semua masalah, jika Anda membaca
tentang apa yang bisa

41
00:01:54,770 --> 00:01:56,180
dilakukan blockhain di internet.

42
00:01:56,180 --> 00:01:58,790
Tapi kelas ini bukan
tentang hal tersebut.

43
00:01:58,790 --> 00:02:01,670
Kelas ini bukan berupa
tentang aplikasi.

44
00:02:01,670 --> 00:02:04,970
Kelas ini adalah tentang
teknologi dan infrastruktur.

45
00:02:04,970 --> 00:02:08,120
Anda akan mempelajari bagaimana
membuat cryptocurrency, apa

46
00:02:08,120 --> 00:02:10,190
yang ada di dalam cryptocurrency,
apa yang penting,

47
00:02:10,190 --> 00:02:12,050
apa saja teknik-tekniknya.

48
00:02:12,050 --> 00:02:16,408
Dan aplikasi apa yang Anda pilih
untuk menerapkannya,

49
00:02:16,408 --> 00:02:17,450
itu terserah Anda.

50
00:02:17,450 --> 00:02:20,630
Kita tidak akan membahas hal tentang
identitas dijital atau catatan

51
00:02:20,630 --> 00:02:22,250
kesehatan atau sejenisnya.

52
00:02:22,250 --> 00:02:25,070
Kita akan bicara tentang
teknologinya.

53
00:02:25,070 --> 00:02:28,340
Jadi pertanyaan besarnya adalah
bagaimana cryptocurrency

54
00:02:28,340 --> 00:02:30,560
berbeda dari
mata uang biasa?

55
00:02:30,560 --> 00:02:33,020
Dan hal lain yang
ingin saya tekankan

56
00:02:33,020 --> 00:02:36,870
adalah terminologi-terminologi
pada bidang ini masih berkembang

57
00:02:36,870 --> 00:02:38,660
Jadi Anda akan mendengar
orang-orang mengatakan

58
00:02:38,660 --> 00:02:42,140
terminologi yang bermacam-macam--
cryptocurrency, blockhain,

59
00:02:42,140 --> 00:02:43,000
consensus.

60
00:02:43,000 --> 00:02:47,060
Dan definisi kata-kata ini masih
melayang-layang dan berevolusi

61
00:02:47,060 --> 00:02:47,870
saat ini.

62
00:02:47,870 --> 00:02:51,590
Sebagian alasannya adalah karena bitcoin,
cryptocurrency pertama,

63
00:02:51,590 --> 00:02:54,200
tidak datang dari akademia,
sejauh yang kita ketahui.

64
00:02:54,200 --> 00:02:57,590
Dia datang dari komunitas
entustiatik di internet.

65
00:02:57,590 --> 00:03:01,070
Jadi itu tidak memiliki basis
dan ketelitian yang sama

66
00:03:01,070 --> 00:03:03,590
dengan apa yang kita harapkan
dari bidang akademis

67
00:03:03,590 --> 00:03:04,340
yang kita pelajari.

68
00:03:04,340 --> 00:03:05,840
Itu OK-OK saja.

69
00:03:05,840 --> 00:03:08,360
Kita akan melihatnya
sembari kita membahasnya.

70
00:03:08,360 --> 00:03:11,750
Dan akademia benar-benar
merangkul topik ini.

71
00:03:11,750 --> 00:03:13,730
Jadi jika di antara ada adalah
mahasiswa magister/doktor yang

72
00:03:13,730 --> 00:03:16,220
sedang mencari area yang tepat
untuk riset,

73
00:03:16,220 --> 00:03:19,148
Saya rasa dasarnya,
banyaknya paper akademis

74
00:03:19,148 --> 00:03:21,440
yang dipublikasikan terkait cryptocurrency
dan teknologi blockchain

75
00:03:21,440 --> 00:03:24,630
yang dihargai di jurnal akademis
berlipat ganda setiap tahunnya.

76
00:03:24,630 --> 00:03:27,610
Jadi ada kesempatan
besar di sini.

77
00:03:27,610 --> 00:03:31,390
Jadi cryptocurrency bukanlah
mata uang biasa.

78
00:03:31,390 --> 00:03:33,880
Dia bukan 1 dolar atau
1 pound atau 1 euro,

79
00:03:33,880 --> 00:03:35,473
seperti yang kita pikirkan
sebagai sebuah mata uang.

80
00:03:35,473 --> 00:03:36,640
Dia adalah sesuatu yang berbeda.

81
00:03:36,640 --> 00:03:40,600
Bitcoin diciptakan tidak
dari apapun.

82
00:03:40,600 --> 00:03:44,290
Dan apakah artinya untuk
menciptakan sebuah cryptocurrency?

83
00:03:44,290 --> 00:03:46,240
Siapa yang bilang Anda dapat
membuat cryptocurrency?

84
00:03:46,240 --> 00:03:47,860
Apa yang berada di
belakang cryptocurrency?

85
00:03:47,860 --> 00:03:49,840
Mengapa dia bernilai?

86
00:03:49,840 --> 00:03:53,663
Yah, pertama-tama, sebelum
kita menjawab pertanyaan berikut,

87
00:03:53,663 --> 00:03:55,330
Saya ingin menegaskan
kembali bahwa

88
00:03:55,330 --> 00:03:58,250
kuliah ini bukanlah tentang, OK?

89
00:03:58,250 --> 00:04:00,520
Kami tidak akan membantu Anda untuk ICO (Initial Coin Offering:
menawarkan koin-koin pertama cryptocurrency buatan sendiri)

90
00:04:00,520 --> 00:04:04,240
Jika Anda tertarik untuk
ICO, pergilah.

91
00:04:04,240 --> 00:04:07,210
Itu bukan hal yang dibahas
pada kelas ini.

92
00:04:07,210 --> 00:04:09,910
Kami tidak akan memberikan
saran-saran trading.

93
00:04:09,910 --> 00:04:13,600
Kami punya nol opini tentang
apakah Anda harus membeli bitcoin

94
00:04:13,600 --> 00:04:16,394
sekarang atau menjual
atau apapun, atau zen cash,

95
00:04:16,394 --> 00:04:17,769
atau apapun itu.

96
00:04:17,769 --> 00:04:19,029
Jadi tidak ada tentang itu.

97
00:04:19,029 --> 00:04:20,050
Jangan bertanya kepada kami.

98
00:04:20,050 --> 00:04:21,203
Kami tidak tertarik.

99
00:04:21,203 --> 00:04:22,620
Dan kelas ini juga
tidak membahas tentang

100
00:04:22,620 --> 00:04:24,670
blockchain privat
(permissioned blockchain)

101
00:04:24,670 --> 00:04:27,310
Anda mungkin tidak mengerti
maksud terminologi ini sekarang,

102
00:04:27,310 --> 00:04:29,770
dan itu OK-OK saja,
tetapi saya hanya

103
00:04:29,770 --> 00:04:32,410
ingin menegaskan bahwa yang
akan kita bicarakan di sini

104
00:04:32,410 --> 00:04:33,940
adalah cryptocurrency.

105
00:04:33,940 --> 00:04:36,640
Mereka adalah sistem
terbuka di mana ada

106
00:04:36,640 --> 00:04:39,920
token yang memiliki nilai tertentu.

107
00:04:39,920 --> 00:04:43,030
Jadi itu yang tidak akan kita
lakukan di kelas ini.

108
00:04:43,030 --> 00:04:44,780
Jadi kembali ke--

109
00:04:44,780 --> 00:04:46,810
dan izinkan saya
berhenti sebentar.

110
00:04:46,810 --> 00:04:50,405
Saya ingin bertanya kepada Anda
apakah ada pertanyaan sejauh ini

111
00:04:50,405 --> 00:04:51,280
tentang segala hal yang saya katakan.

112
00:04:54,930 --> 00:04:55,887
Ya.

113
00:04:55,887 --> 00:04:57,720
AUDIENS: Apakah mereka harus selalu
memiliki nilai?

114
00:04:57,720 --> 00:04:58,530
NEHA NARULA: Tidak, tidak sama sekali.

115
00:04:58,530 --> 00:04:59,910
Dan marilah kita mulai
membahasnya ke arah sana.

116
00:04:59,910 --> 00:05:02,243
Jadi pertanyaannya adalah apakan
token harus memiliki nilai?

117
00:05:02,243 --> 00:05:04,830
Jadi saya rasa, sebenarnya,
untuk memahami

118
00:05:04,830 --> 00:05:07,680
apa itu cryptocurrency, apa itu token,
apa artinya mereka,

119
00:05:07,680 --> 00:05:10,410
kita harus bicara soal uang.

120
00:05:10,410 --> 00:05:14,970
Dan kita harus bicara tentang
apa itu uang dan apa maknanya.

121
00:05:14,970 --> 00:05:17,730
Jadi ini akan menjadi
sangat disederhanakan

122
00:05:17,730 --> 00:05:21,480
dan saya rasa tidak akan memuaskan
bagi ekonom moneter.

123
00:05:21,480 --> 00:05:24,420
Tapi uang dikembangkan-- ada
beberapa teori berbeda

124
00:05:24,420 --> 00:05:26,670
tentang bagaiaman uang dikembangkan.

125
00:05:26,670 --> 00:05:29,640
Ada hal ini yang dinamakan keinginan
yang kebetulan (coincident of wants).

126
00:05:29,640 --> 00:05:33,440
Jadi misalkan saya punya domba
dan Tadge (rekan ybs) punya gandum.

127
00:05:33,440 --> 00:05:35,490
Saya lapar dan ingin
membuat roti.

128
00:05:35,490 --> 00:05:38,460
Tadge ingin sekali
membuat baju hangat.

129
00:05:38,460 --> 00:05:41,170
Jadi kami dapat melakukan
barter, kami dapat bertukar.

130
00:05:41,170 --> 00:05:44,060
Saya punya suatu barang
yang berguna bagi Tadge.

131
00:05:44,060 --> 00:05:46,380
Tadge punya barang lain yang
berguna untuk saya.

132
00:05:46,380 --> 00:05:49,020
Kami bisa bertemu dan
membuat pertukaran.

133
00:05:49,020 --> 00:05:50,130
Jadi itu fantastis.

134
00:05:50,130 --> 00:05:51,540
Barter sangat penting.

135
00:05:51,540 --> 00:05:53,890
Barter sudah ada
sejak lama.

136
00:05:53,890 --> 00:05:59,673
Tapi bagaimana jika Tadge tidak punya
gandum, Tadge punya sayur,

137
00:05:59,673 --> 00:06:00,840
dan saya tidak mau sayur.

138
00:06:00,840 --> 00:06:01,440
Saya mau gandum.

139
00:06:01,440 --> 00:06:04,200
Tapi Tadge tetap ingin
kain wol dari domba.

140
00:06:04,200 --> 00:06:05,640
Bagaimana kami melakukan pertukaran ini?

141
00:06:05,640 --> 00:06:08,010
Kami tidak memiliki
coincidence of wants.

142
00:06:08,010 --> 00:06:11,050
Kami menginginkan barang yang
tidak tepat sama satu sama lain.

143
00:06:11,050 --> 00:06:16,050
Jadi beberapa teori mengatakan bahwa
uang tercipta dari masalah ini.

144
00:06:16,050 --> 00:06:21,540
Dan uang dapat direpresentasikan
dalam banyak sekali hal.

145
00:06:21,540 --> 00:06:25,830
Uang, saya rasa muncul pertama
kali sekitar tahun 5000 SM,

146
00:06:25,830 --> 00:06:28,680
Jadi itu sangat,
sangat, sangat tua.

147
00:06:28,680 --> 00:06:30,420
Hal-hal yang direpresentasikan
oleh uang biasanya

148
00:06:30,420 --> 00:06:32,250
memiliki properti tertentu.

149
00:06:32,250 --> 00:06:33,930
Mereka relatif langka.

150
00:06:33,930 --> 00:06:37,800
Dan tidak mudah
untuk dibuat kembali.

151
00:06:37,800 --> 00:06:42,330
Orang-orang, dalam beberapa kasus, menggunakan
barang-barang seperti kerang atau mutiara untuk uang.

152
00:06:42,330 --> 00:06:45,180
Koin-koin pertama-- ini adalah
koin yang sangat menarik

153
00:06:45,180 --> 00:06:46,320
yang pernah dikembangkan.

154
00:06:46,320 --> 00:06:48,720
Logam berharga dahulu
sering digunakan untuk uang.

155
00:06:48,720 --> 00:06:50,700
Dan akhirnya
kita kurang lebih berevolusi

156
00:06:50,700 --> 00:06:52,920
menuju apa yang kita kenal
sebagai uang saat ini,

157
00:06:52,920 --> 00:06:56,790
yaitu uang kertas, mata uang.

158
00:06:56,790 --> 00:06:59,340
Teori lain tentang
bagaimana uang muncul

159
00:06:59,340 --> 00:07:03,840
adalah gagasan tentang kuintansi,
hutang dan piutang.

160
00:07:03,840 --> 00:07:08,400
Jadi mungkin saya punya seekor domba,
dan saya mencukur semua domba saya

161
00:07:08,400 --> 00:07:09,990
dan mengumpulkan banyak wol.

162
00:07:09,990 --> 00:07:12,810
Yang bisa saya lakukan adalah saya bisa
menyimpan wol tersebut di suatu tempat.

163
00:07:12,810 --> 00:07:14,850
Dan saya bisa mendapatkan
kuintansi dari seseorang

164
00:07:14,850 --> 00:07:19,440
dari menyimpan wol tersebut,
dan kuitansi tersebut memiliki nilai.

165
00:07:19,440 --> 00:07:23,460
Kuitansi tersebut memberikan orang yang
memilikinya, hak terhadap barang yang

166
00:07:23,460 --> 00:07:24,580
sedang disimpan.

167
00:07:24,580 --> 00:07:27,150
Dan teori tentang uang
lainnya adalah

168
00:07:27,150 --> 00:07:28,950
bahwa uang berevolusi
dari kuitansi tadi,

169
00:07:28,950 --> 00:07:30,602
menukarkan kuitansi-kuitansi ini
satu dengan lainnya.

170
00:07:30,602 --> 00:07:32,310
Alih-alih mengambil semua
wol yang ada pada Anda,

171
00:07:32,310 --> 00:07:34,860
Anda menyimpannya di
suatu tempat penyimpanan,

172
00:07:34,860 --> 00:07:37,050
dan kuitansi-kuitansi berfungsi
sebagai instrumen untuk pembawanya.

173
00:07:37,050 --> 00:07:42,030
Siapapun yang memiliki kuitansi itu
memiliki akses ke wol di dalam penyimpanan.

174
00:07:42,030 --> 00:07:44,340
Jadi sekarang Anda mulai bisa
melihat dua ide yang berbeda

175
00:07:44,340 --> 00:07:46,560
tentang apa bagaimana uang
berkembang dari sini.

176
00:07:46,560 --> 00:07:50,160
Yang pertama, yah, itu adalah
sebuah manik atau koin,

177
00:07:50,160 --> 00:07:52,050
atau sesuatu yang dapat
saya genggam, sesuatu

178
00:07:52,050 --> 00:07:55,980
yang bersifat fisik di mana kita
putuskan untuk memberikan nilai ke

179
00:07:55,980 --> 00:07:57,180
dalam dan terhadap dirinya sendiri.

180
00:07:57,180 --> 00:08:01,380
Lalu ide lainnya adalah saya akan
menggunakan institusi yang terpercaya.

181
00:08:01,380 --> 00:08:04,110
Saya akan menyimpan sesuatu
di dalam institusi itu,

182
00:08:04,110 --> 00:08:08,010
dan mereka akan memastikan validitas
simpanan tersebut,

183
00:08:08,010 --> 00:08:10,440
dan mengatur siapa yang
memiliki akses terhadap simpanan itu.

184
00:08:13,720 --> 00:08:17,050
Jadi ini tidak benar-benar
menjawab pertanyaan

185
00:08:17,050 --> 00:08:21,550
yang diajukan di awal, yaitu
mengapa token-token memiliki nilai.

186
00:08:21,550 --> 00:08:25,467
Tapi satu hal yang ingin
saya tunjukkan adalah--

187
00:08:25,467 --> 00:08:27,550
yah, pertanyaan yang ingin
saya tanyakan kepada kalian, sebenarnya,

188
00:08:27,550 --> 00:08:29,350
adalah mengapa benda-benda ini
memiliki nilai?

189
00:08:29,350 --> 00:08:30,475
Apakah ada yang memiliki pendapat?

190
00:08:33,679 --> 00:08:34,302
Ya.

191
00:08:34,302 --> 00:08:36,260
AUDIENS: Karena semua orang setuju
benda tersebut memiliki nilai.

192
00:08:36,260 --> 00:08:38,343
NEHA NARULA: Karena semua orang setuju
benda tersebut memiliki nilai.

193
00:08:38,343 --> 00:08:40,770
Adakah pendapat lain mengapa
benda-benda tersebut memiliki nilai?

194
00:08:40,770 --> 00:08:41,270
Ya.

195
00:08:41,270 --> 00:08:43,145
AUDIENS: Benda-benda tersebut juga
disokong oleh institusi

196
00:08:43,145 --> 00:08:44,147
seperti pemerintah.

197
00:08:44,147 --> 00:08:45,980
NEHA NARULA: Benda tersebut
disokong oleh institusi.

198
00:08:45,980 --> 00:08:47,355
Ceritakan lebih banyak
mengenai hal tersebut.

199
00:08:47,355 --> 00:08:48,360
Apa maksudnya?

200
00:08:48,360 --> 00:08:49,777
AUDIENS: Jadi pemerintah
semacam

201
00:08:49,777 --> 00:08:52,873
menjanjikan Anda untuk
menghargai nilainya

202
00:08:52,873 --> 00:08:53,540
NEHA NARULA: OK.

203
00:08:53,540 --> 00:08:56,168
Pemerintah menjanjikan
Anda untuk menghargai nilai itu

204
00:08:56,168 --> 00:08:58,460
Apakah ada lagi yang ingin
menambahkan atau punya alasan lain?

205
00:08:58,460 --> 00:08:59,600
Ya.

206
00:08:59,600 --> 00:09:00,350
Dan sebutkan nama anda

207
00:09:00,350 --> 00:09:01,760
Maaf, yah.

208
00:09:01,760 --> 00:09:03,230
AUDIENCE: Jared Thompson.

209
00:09:03,230 --> 00:09:05,690
Dalam contoh untuk kasus
mata uang dolar, pemerintah

210
00:09:05,690 --> 00:09:08,118
menyetujui untuk menjadikan itu
alat pembayaran untuk pajak

211
00:09:08,118 --> 00:09:09,410
NEHA NARULA: Pembayaran pajak.

212
00:09:09,410 --> 00:09:09,910
OK.

213
00:09:09,910 --> 00:09:12,678
Jadi hal-hal tersebut yang
menghubungkan dengan pemerintah.

214
00:09:12,678 --> 00:09:14,845
AUDIENS: Bahkan jika hal tersebut
tidak memiliki nilai sama sekali,

215
00:09:14,845 --> 00:09:16,490
dalam konteks itu ada nilainya.

216
00:09:16,490 --> 00:09:19,820
Itu adalah hal terakhir
yang mempertahankan nilainya.

217
00:09:19,820 --> 00:09:21,380
NEHA NARULA: OK, bagus.

218
00:09:21,380 --> 00:09:22,850
Ada yang lain?

219
00:09:22,850 --> 00:09:23,420
Iya.

220
00:09:23,420 --> 00:09:24,380
AUDIENS: Saya Paul.

221
00:09:24,380 --> 00:09:28,080
Saya pikir ketiga hal yang berada
di depan selembar uang dolar,

222
00:09:28,080 --> 00:09:29,870
memiliki nilai yang melekat
karena mereka

223
00:09:29,870 --> 00:09:31,610
mungkin lebih langka.

224
00:09:31,610 --> 00:09:33,900
NEHA NARULA: Mereka bernilai
karena mereka memang langka.

225
00:09:33,900 --> 00:09:34,400
OK.

226
00:09:34,400 --> 00:09:35,180
Menarik.

227
00:09:35,180 --> 00:09:37,310
Baiklah.

228
00:09:37,310 --> 00:09:39,975
Jadi itu semua merupakan
ide yang sangat menarik.

229
00:09:39,975 --> 00:09:41,850
Saya rasa itu adalah
bermacam jenis properti

230
00:09:41,850 --> 00:09:45,153
yang membuat
benda-benda bernilai.

231
00:09:45,153 --> 00:09:47,820
Ada juga benda yang langkap
tapi tidak bernilai,

232
00:09:47,820 --> 00:09:49,830
betul?

233
00:09:49,830 --> 00:09:53,800
Saya tahu beberapa benda yang
mungkin sangat langka.

234
00:09:53,800 --> 00:09:55,800
Di seluruh semesta ini hanya
ada 1 atau 2,

235
00:09:55,800 --> 00:09:58,410
dan kalian tidak akan tertarik
untuk memilikinya.

236
00:09:58,410 --> 00:10:00,750
Kalian tidak akan memberikan
nilai ke dalam benda itu.

237
00:10:00,750 --> 00:10:03,720
Tentunya, sangat penting
bahwa kalian bisa membayar pajak

238
00:10:03,720 --> 00:10:06,870
dengan benda ini, karena membayar
pajak adalah sebuah kewajiban

239
00:10:06,870 --> 00:10:08,942
untuk dilakukan di setiap negara.

240
00:10:08,942 --> 00:10:11,400
Ada hal-hal yang memiliki
nilai yang belum tentu Anda

241
00:10:11,400 --> 00:10:12,310
gunakan untuk pajak.

242
00:10:12,310 --> 00:10:14,280
Jadi itu sedikit membingungkan.

243
00:10:14,280 --> 00:10:16,980
Dan kemudian ada
gagasan bahwa itu didukung,

244
00:10:16,980 --> 00:10:20,100
itu didukung oleh sesuatu.

245
00:10:20,100 --> 00:10:25,482
Dan dulunya dolar
didukung oleh sesuatu.

246
00:10:25,482 --> 00:10:26,940
Dan sebenarnya, jika
kamu melihat uang 1 dolar,

247
00:10:26,940 --> 00:10:28,357
Saya pikir itu masih
tertulis di sana, benar?

248
00:10:28,357 --> 00:10:31,020
Itu didukung penuh oleh keyakinan
dan kepercayaan dari pemerintah

249
00:10:31,020 --> 00:10:31,742
Amerika Serikat.

250
00:10:31,742 --> 00:10:33,450
TADGE DRYJA: Mereka
tidak mengatakan itu lagi.

251
00:10:33,450 --> 00:10:34,200
NEHA NARULA: Mereka tidak
mengatakan itu lagi?

252
00:10:34,200 --> 00:10:35,117
Mereka pernah mengatakan itu.

253
00:10:35,117 --> 00:10:37,718
Tetapi itulah mengapa orang banyak
berbicara tentang uang.

254
00:10:37,718 --> 00:10:40,260
Didukung penuh oleh keyakinan
dan kredibilitas Pemerintah

255
00:10:40,260 --> 00:10:41,895
Amerika Serikat

256
00:10:41,895 --> 00:10:43,020
Apa maksud sebenarnya?

257
00:10:43,020 --> 00:10:45,420
Saya rasa semuanya itu
kembali ke fakta bahwa

258
00:10:45,420 --> 00:10:46,920
hal-hal ini berharga
karena kita

259
00:10:46,920 --> 00:10:47,940
pikir mereka memang berharga.

260
00:10:47,940 --> 00:10:49,710
Kita semua sudah memutuskan
bahwa mereka berharga

261
00:10:49,710 --> 00:10:53,430
Dan Anda tahu bahwa jika Anda memiliki
selembar $1.00 dan Anda ingin membeli

262
00:10:53,430 --> 00:10:56,370
sesuatu dari seseorang,
mereka akan mengambilnya,

263
00:10:56,370 --> 00:10:58,077
sehingga anda dapat melakukan pertukaran tersebut.

264
00:10:58,077 --> 00:10:59,910
Dan alasan mengapa
mereka akan menerimanya

265
00:10:59,910 --> 00:11:01,920
adalah karena mereka mengetahui
bahwa orang lain--

266
00:11:01,920 --> 00:11:03,450
akan menerimanya.

267
00:11:03,450 --> 00:11:06,660
Benda-benda ini memiliki nilai karena
kita berpikir bahwa benda tersebut memiliki nilai.

268
00:11:06,660 --> 00:11:12,150
Ini adalah sebuah cerita
kolektif yang kita semua ceritakan.

269
00:11:12,150 --> 00:11:14,880
Jadi saya berpikir begitu Anda
melihat uang dengan cara seperti itu,

270
00:11:14,880 --> 00:11:18,360
kemudian ketika anda mulai melihat
token-token, yang pada dasarnya adalah--

271
00:11:18,360 --> 00:11:20,970
representasi dijital
dari benda-benda ini, sesuatu

272
00:11:20,970 --> 00:11:24,300
yang langka dan
sedikit istimewa, kemudian

273
00:11:24,300 --> 00:11:27,580
kalau Anda bertanya kenapa
token ini memiliki nilai,

274
00:11:27,580 --> 00:11:30,760
itu karena kita pikir itu ada nilainya.

275
00:11:30,760 --> 00:11:34,040
Jadi sebenarnya apa yang membuat
sebuah token dari sananya berharga?

276
00:11:34,040 --> 00:11:36,272
Sebuah fakta bahwa kita
pikir itu berharga.

277
00:11:36,272 --> 00:11:38,230
Serta banyak hal lain
yang bisa masuk ke dalamnya.

278
00:11:38,230 --> 00:11:43,660
Mungkin kita pikir itu berharga
karena itu sangat langka.

279
00:11:43,660 --> 00:11:47,260
Atau mungkin kita pikir
itu berharga karena seseorang

280
00:11:47,260 --> 00:11:49,240
menjanjikan bahwa Anda
bisa menggunakannya untuk membayar

281
00:11:49,240 --> 00:11:51,130
untuk ruang penyimpanan, seperti dengan Dropbox.

282
00:11:51,130 --> 00:11:53,890
Atau mungkin kita pikir itu berharga
untuk alasan yang sangat

283
00:11:53,890 --> 00:11:55,300
berbeda, karena
kita menyukai namanya,

284
00:11:55,300 --> 00:11:57,383
atau kita menyukai orang yang
menjalankan jaringannya.

285
00:11:57,383 --> 00:11:59,200
Tapi pada akhirnya
token adalah benda berharga.

286
00:11:59,200 --> 00:12:00,880
Representasi-representasi
dijital ini

287
00:12:00,880 --> 00:12:03,500
menjadi berharga karena kita
menganggap mereka berharga

288
00:12:03,500 --> 00:12:04,420
Ya.

289
00:12:04,420 --> 00:12:05,820
AUDIENS: Juga karena mereka
memiliki jumlah terbatas.

290
00:12:05,820 --> 00:12:06,790
NEHA NARULA: Nama.

291
00:12:06,790 --> 00:12:07,760
AUDIENCE: [TIDAK TERDENGAR].

292
00:12:07,760 --> 00:12:09,630
Karena mereka memiliki
jumlah yang terbatas.

293
00:12:09,630 --> 00:12:11,038
NEHA NARULA: Yah,
jadi argumen saya

294
00:12:11,038 --> 00:12:12,580
adalah fakta bahwa
mereka terbatas

295
00:12:12,580 --> 00:12:14,590
adalah sesuatu yang
masuk ke dalam persepsi kita

296
00:12:14,590 --> 00:12:15,340
yang membuatnya berharga.

297
00:12:18,100 --> 00:12:18,610
Bagus.

298
00:12:18,610 --> 00:12:19,120
OK.

299
00:12:19,120 --> 00:12:22,630
Jadi kita sudah belajar
sedikit tentang uang,

300
00:12:22,630 --> 00:12:24,820
berbicara sedikit
tentang uang, saya

301
00:12:24,820 --> 00:12:28,665
ingin membahas bagaimana sistem pembayaran
bekerja karena pada akhirnya, kita

302
00:12:28,665 --> 00:12:30,040
akan membahas ke
mata uang kripto (cryptocurrency)

303
00:12:30,040 --> 00:12:34,090
Dan mata uang kripto
adalah uang tunai elektronik.

304
00:12:34,090 --> 00:12:38,420
Jadi beginilah cara pembayaran
dijital bekerja

305
00:12:38,420 --> 00:12:38,920
sekarang.

306
00:12:38,920 --> 00:12:42,070
Anda memiliki institusi
yang disebut bank.

307
00:12:42,070 --> 00:12:45,340
Anda memiliki Alice dan Anda
memiliki Bob, dan Alice dan Bob

308
00:12:45,340 --> 00:12:47,800
memiliki rekening di bank ini.

309
00:12:47,800 --> 00:12:51,840
Dan bank terus melacak siapa
memiliki apa.

310
00:12:51,840 --> 00:12:53,228
Dan ini adalah rekaman-rekaman.

311
00:12:53,228 --> 00:12:54,520
Ini mungkin menjadi rekaman dijital.

312
00:12:54,520 --> 00:12:57,190
Mereka mungkin berupa
catatan kertas, apapun

313
00:12:57,190 --> 00:12:59,440
yang digunakan bank
untuk melacak siapa

314
00:12:59,440 --> 00:13:00,778
siapa memiliki apa di akun mereka.

315
00:13:00,778 --> 00:13:03,070
Dan cara yang telah saya buatkan
untuk contoh ini sekarang,

316
00:13:03,070 --> 00:13:04,990
Alice dan Bob keduanya
memiliki rekening bank.

317
00:13:04,990 --> 00:13:07,810
Alice memiliki $10,00 di bank
dan Bob tidak punya uang

318
00:13:07,810 --> 00:13:09,850
di bank.

319
00:13:09,850 --> 00:13:12,340
Jadi katakanlah bahwa
Alice ingin membayar Bob.

320
00:13:12,340 --> 00:13:15,250
Katakanlah jika Alice dan
Bob sudah bertemu.

321
00:13:15,250 --> 00:13:17,560
Mungkin mereka berada di
kedai kopi yang sama.

322
00:13:17,560 --> 00:13:20,260
Dan Alice ingin membeli
sebuah roti lapis dari Bob.

323
00:13:20,260 --> 00:13:23,680
Dan Bob mengatakan, OK, Anda
perlu membayar kepada saya $1,00.

324
00:13:23,680 --> 00:13:26,690
Jika Anda memberi saya $1,00, maka
saya akan memberi Anda sebuah roti lapis.

325
00:13:26,690 --> 00:13:28,460
Jadi bagaimana Alice bisa melakukan ini?

326
00:13:28,460 --> 00:13:31,130
Bagaimana dia bisa menyerahkan
$1,00 kepada Bob?

327
00:13:31,130 --> 00:13:34,220
Yah, jika dia memiliki selembar
uang kertas dolar, dia bisa melakukannya.

328
00:13:34,220 --> 00:13:37,970
Tapi katakanlah bahwa dia
tidak memiliki selembar dolar.

329
00:13:37,970 --> 00:13:43,100
Jadi Alice bisa meminta bank untuk
melakukan penyerahan ini untuknya--atau

330
00:13:43,100 --> 00:13:44,450
$5,00.

331
00:13:44,450 --> 00:13:46,220
Jadi Alice mengirim
sebuah pesan untuk bank

332
00:13:46,220 --> 00:13:48,783
serta mengautentikasi dengan bank
untuk menunjukan kepada bank

333
00:13:48,783 --> 00:13:50,450
bahwa dia, sebenarnya,
Alice, tapi saya tidak

334
00:13:50,450 --> 00:13:52,650
akan masuk ke dalam detail
mengenai bagaimana cara kerjanya.

335
00:13:52,650 --> 00:13:57,230
Lalu bank akan mengonfirmasi hal tersebut,
dan melakukan transfer dalam

336
00:13:57,230 --> 00:14:02,510
buku besar, mengatakan bahwa sekarang Alice mempunyai
$5,00 dan Bob juga punya $5,00.

337
00:14:02,510 --> 00:14:04,995
Alice mengatakan kepada Bob,
hei, saya melakukan ini.

338
00:14:04,995 --> 00:14:05,870
Saya bicara dengan bank.

339
00:14:05,870 --> 00:14:06,410
Coba cek.

340
00:14:06,410 --> 00:14:08,960
Anda bisa verifikasi sendiri.

341
00:14:08,960 --> 00:14:12,140
Bob cek ke bank dan
melihat, ya, faktanya,

342
00:14:12,140 --> 00:14:14,090
banknya mengatakan bahwa
dia memiliki $5.00 sekarang,

343
00:14:14,090 --> 00:14:16,250
padahal sebelumnya dia memiliki nol.

344
00:14:16,250 --> 00:14:19,280
Kemudian Bob memberikan Alice
roti lapisnya karena dia percaya

345
00:14:19,280 --> 00:14:20,980
bahwa dia sekarang memiliki $5,00.

346
00:14:20,980 --> 00:14:24,580
Dan banknya semacam
menyimpan properti

347
00:14:24,580 --> 00:14:27,880
bahwa uangnya tidak serta merta
diciptakan, bahwa saldo nya

348
00:14:27,880 --> 00:14:29,680
selalu diurus.

349
00:14:29,680 --> 00:14:32,260
Maka di skenario ini
bank menjadi sangat penting.

350
00:14:32,260 --> 00:14:33,830
Peran bank sangat krusial.

351
00:14:33,830 --> 00:14:35,500
Beginilah cara kerja
pembayaran dijital.

352
00:14:35,500 --> 00:14:39,003
Kartu kredit, Venmo,
bank, semua jenis

353
00:14:39,003 --> 00:14:41,170
yang berdasarkan ide yang sama,
bahwa ada beberapa institusi

354
00:14:41,170 --> 00:14:44,230
yang terpercaya yang mengatur
pembayaran itu untuk kita

355
00:14:44,230 --> 00:14:47,110
dan melacak
segalanya.

356
00:14:47,110 --> 00:14:51,700
Sekarang apa kelebihan dan
kekurangan dari skenario ini?

357
00:14:51,700 --> 00:14:54,560
Adakah yang ingin
memberikan pendapat?

358
00:14:54,560 --> 00:14:55,440
Ya.

359
00:14:55,440 --> 00:14:56,980
AUDIENS: Bank
bisa diretas

360
00:14:56,980 --> 00:14:59,608
dan orang-orang dapat memindahkan
uang antar rekening.

361
00:14:59,608 --> 00:15:00,400
NEHA NARULA: Benar.

362
00:15:00,400 --> 00:15:02,290
Jadi kita menaruh banyak
kepercayaan di bank ini.

363
00:15:02,290 --> 00:15:04,360
Dan mungkin haruskah
kita mempercayai bank?

364
00:15:04,360 --> 00:15:06,490
Bank terkadang gagal.

365
00:15:06,490 --> 00:15:07,780
Bank telah diretas.

366
00:15:07,780 --> 00:15:10,198
Bank memiliki manusia
yang menjalankannya

367
00:15:10,198 --> 00:15:11,740
yang sesekali
mungkin ingin merubah

368
00:15:11,740 --> 00:15:14,440
saldo itu untuk menguntungkan mereka.

369
00:15:14,440 --> 00:15:15,550
Ini semua telah terjadi.

370
00:15:15,550 --> 00:15:17,910
Ada yang lain?

371
00:15:17,910 --> 00:15:18,450
Ya.

372
00:15:18,450 --> 00:15:19,390
Dan sebutkan namamu.

373
00:15:19,390 --> 00:15:21,330
AUDIENS: Brittany.

374
00:15:21,330 --> 00:15:24,160
Saat mendesak, terkadang
Anda mungkin mengalami penundaan

375
00:15:24,160 --> 00:15:26,730
atau mungkin butuh waktu
dengan prosesnya.

376
00:15:26,730 --> 00:15:27,480
NEHA NARULA: Ya.

377
00:15:27,480 --> 00:15:30,490
Alice harus berbicara dengan bank,
dan itu agak mengganggu.

378
00:15:30,490 --> 00:15:33,150
Jadi begitulah.

379
00:15:33,150 --> 00:15:33,880
Ada yang lain?

380
00:15:33,880 --> 00:15:34,447
Ya.

381
00:15:34,447 --> 00:15:36,030
AUDIENS: Dan jika
semua orang sebenarnya bisa

382
00:15:36,030 --> 00:15:38,238
menarik pada saat yang sama,
maka bank sebenarnya bisa

383
00:15:38,238 --> 00:15:40,590
memasukan uang ke dalam sistem.

384
00:15:40,590 --> 00:15:41,430
NEHA NARULA: Yah OK.

385
00:15:41,430 --> 00:15:43,590
Jadi ini menjadi sedikit
lebih maju disini.

386
00:15:43,590 --> 00:15:47,790
Bagaimana jika semua orang mengambil
saldo mereka pada saat yang sama?

387
00:15:47,790 --> 00:15:51,030
Yah, kita perlu untuk memastikan
bahwa bank sebenarnya

388
00:15:51,030 --> 00:15:53,262
memiliki uang tersebut, boleh dikatakan.

389
00:15:53,262 --> 00:15:55,720
Kita tidak akan membicarakan
tentang masalah itu sekarang.

390
00:15:55,720 --> 00:15:57,900
Tetapi masalah yang sangat bagus.

391
00:15:57,900 --> 00:15:59,730
Jadi untuk berbicara
tentang beberapa keuntungan

392
00:15:59,730 --> 00:16:03,600
dan kerugian dari situasi ini,
salah satu keuntungan besar, saya rasa,

393
00:16:03,600 --> 00:16:06,210
adalah, bahwa bahkan jika
Alice dan Bob tidak

394
00:16:06,210 --> 00:16:09,480
berada di lokasi yang sama secara fisik,
Alice tetap bisa membayar Bob

395
00:16:09,480 --> 00:16:10,688
jika mereka bisa bicara dengan bank.

396
00:16:10,688 --> 00:16:12,397
Jadi itu lumayan keren,
dan itu merupakan sesuatu

397
00:16:12,397 --> 00:16:15,000
yang tidak bisa kau lakukan dengan uang kertas
atau koin atau batangan

398
00:16:15,000 --> 00:16:16,180
emas.

399
00:16:16,180 --> 00:16:18,480
Jadi dengan adanya
institusi terpercaya ini

400
00:16:18,480 --> 00:16:20,670
yang bisa Anda kontak
secara elektronik

401
00:16:20,670 --> 00:16:22,378
Berarti Alice dan
Bob bisa berada di belahan

402
00:16:22,378 --> 00:16:24,503
dunia yang berbeda antara satu
dengan yang lain dan mereka tetap bisa

403
00:16:24,503 --> 00:16:25,200
membayar satu sama lain.

404
00:16:25,200 --> 00:16:27,870
Jadi, itu sangat menarik,
dan hal itu benar-benar sebuah properti

405
00:16:27,870 --> 00:16:29,940
yang ingin kita miliki.

406
00:16:29,940 --> 00:16:33,330
Mengenai kerugiannya, saya rasa
kita sudah menyebutkan beberapa dari mereka,

407
00:16:33,330 --> 00:16:37,020
di mana kita benar-benar
memposisikan bank ini

408
00:16:37,020 --> 00:16:38,760
di tengah-tengah setiap hal
yang ada di sini.

409
00:16:38,760 --> 00:16:42,600
Dan ada juga beberapa hal yang dapat
menyebabkan masalah bagi kita.

410
00:16:42,600 --> 00:16:46,142
Jadi, bank harus dalam kondisi daring
dalam setiap transaksi.

411
00:16:46,142 --> 00:16:47,850
Jika bank tersebut luring, lalu
bagaimana caranya Bob

412
00:16:47,850 --> 00:16:50,250
mengetahui apakah dia sudah
dibayar atau belum?

413
00:16:50,250 --> 00:16:52,710
Bank dapat mengalami kegagalan
pada satu waktu,

414
00:16:52,710 --> 00:16:54,060
di mana kondisi tersebut
berhubungan dengan hal tadi.

415
00:16:54,060 --> 00:16:56,610
Bank bisa saja
memutuskan bahwa mereka

416
00:16:56,610 --> 00:16:59,010
tidak ingin melakukan ini lagi
dan dapat memblokir transaksi.

417
00:16:59,010 --> 00:17:00,180
Dan kemudian privasi.

418
00:17:00,180 --> 00:17:03,000
Bank memiliki pengetahuan
terhadap orang-orang

419
00:17:03,000 --> 00:17:03,970
dan pembayaran mereka.

420
00:17:03,970 --> 00:17:05,849
Dan ini adalah informasi
yang sangat sensitif.

421
00:17:05,849 --> 00:17:08,618
Pembayaran cukup penting.

422
00:17:08,618 --> 00:17:10,410
Dan kita akan
berbicara tentang privasi.

423
00:17:10,410 --> 00:17:13,119
cukup banyak di kelas ini, selama
paruh kedua kelas ini.

424
00:17:13,119 --> 00:17:16,050
Jadi sekedar contoh, beberapa
dari contoh visual tentang hal tadi.

425
00:17:16,050 --> 00:17:17,880
Bank bisa begitu
saja pergi,

426
00:17:17,880 --> 00:17:20,099
dan lalu apa yang terjadi
kepada buku besar itu?

427
00:17:20,099 --> 00:17:21,240
Siapa yang tahu, benar?

428
00:17:21,240 --> 00:17:23,579
Maksud saya, secara harfiah, itu
bisa hilang begitu saja.

429
00:17:23,579 --> 00:17:25,079
Mungkin berwujud kertas
dan terbakar,

430
00:17:25,079 --> 00:17:29,598
atau mungkin itu sekumpulan bit di komputer
dan tidak direplikasi.

431
00:17:29,598 --> 00:17:31,140
Bank bisa memutuskan
bahwa mereka tidak menyukai

432
00:17:31,140 --> 00:17:33,090
seperti Alice untuk alasan
tertentu, dan mereka

433
00:17:33,090 --> 00:17:35,880
merasa tidak ingin memproses
transaksi Alice.

434
00:17:35,880 --> 00:17:39,940
Ini terjadi sepanjang
waktu di dunia nyata.

435
00:17:39,940 --> 00:17:44,830
Jadi sudah ada desain
untuk uang elektronik

436
00:17:44,830 --> 00:17:46,320
yang bekerja
sedikit berbeda.

437
00:17:46,320 --> 00:17:47,737
Dan kita akan
meningkatkan

438
00:17:47,737 --> 00:17:53,245
desain yang datang
tepat sebelum bitcoin,

439
00:17:53,245 --> 00:17:54,870
dan kita akan melakukannya
itu secara berulang.

440
00:17:54,870 --> 00:17:57,810
Jadi mari kita bicara tentang uang elektronik
dan cara kerja uang elektronik.

441
00:17:57,810 --> 00:18:01,980
Jadi cara uang elektronik
bekerja adalah Alice

442
00:18:01,980 --> 00:18:03,450
memberitahu bank--
alih-alih mengatakan,

443
00:18:03,450 --> 00:18:05,040
hei, bank, lakukan
transfer ini untuk saya,

444
00:18:05,040 --> 00:18:08,370
Alice berkata, hei, saya
menginginkan representasi digital

445
00:18:08,370 --> 00:18:09,540
dari sebuah koin.

446
00:18:09,540 --> 00:18:12,607
Bisakah Anda memberikan saya
sesuatu yang digital

447
00:18:12,607 --> 00:18:14,940
jadi saya tidak harus berada di
tempat fisik yang sama dengan Anda,

448
00:18:14,940 --> 00:18:19,920
dan bisa saya gunakan sedimikian rupa
supaya bisa saya buktikan ke orang

449
00:18:19,920 --> 00:18:22,950
lain kalau saya mempunyai benda ini dan
belum saya gunakan sebanyak dua kali,

450
00:18:22,950 --> 00:18:25,380
karena itu adalah permasalahan
dengan representasi digital

451
00:18:25,380 --> 00:18:26,220
dari koin.

452
00:18:26,220 --> 00:18:29,370
Permasalahan fundamentalnya
adalah bit bisa digandakan.

453
00:18:29,370 --> 00:18:33,450
Jadi sistem apapun yang kamu gunakan
untuk mendesain uang elektronik Anda,

454
00:18:33,450 --> 00:18:35,820
Anda harus memastikan bahwa
orang tidak bisa tinggal

455
00:18:35,820 --> 00:18:41,825
menggandakan koin dan memberikan koin
yang sama ke beberapa orang.

456
00:18:41,825 --> 00:18:43,200
Pada contoh
sebelumnya, bank

457
00:18:43,200 --> 00:18:44,450
yang memastikan hal ini terjadi.

458
00:18:44,450 --> 00:18:46,650
Bank itu
menjaga saldo

459
00:18:46,650 --> 00:18:51,500
dengan mengurangi saldo akun Alice
dan menambahkan saldo akun Bob.

460
00:18:51,500 --> 00:18:54,000
Namun, jika kita ingin memikirkan
mengenai sesuatu yang tidak mengikutsertakan

461
00:18:54,000 --> 00:18:56,100
banknya, dan kita mulai
mengarah ke sana,

462
00:18:56,100 --> 00:18:59,520
maka kita perlu untuk memikirkan mengenai
bagaimana memastikan bahwa sebuah koin

463
00:18:59,520 --> 00:19:02,210
digunakan dua kali, atau double spend.

464
00:19:02,210 --> 00:19:03,800
Jadi Alice meminta koin dari bank.

465
00:19:03,800 --> 00:19:07,040
Dan mungkin dia sudah memiliki
akun di bank tersebut sebelumnya.

466
00:19:07,040 --> 00:19:10,400
Atau mungkin dia memberikan teller
bank uang secara fisik

467
00:19:10,400 --> 00:19:13,310
untuk mendapatkan
salah satu koin itu.

468
00:19:13,310 --> 00:19:17,030
Jadi banknya menghasilkan
sebuah angka yang unik--

469
00:19:17,030 --> 00:19:19,430
yaitu SN yang berarti
Serial Number

470
00:19:19,430 --> 00:19:22,880
dan memutuskan bahwa itu merupakan
representasi dijital

471
00:19:22,880 --> 00:19:24,620
dari sebuah koin.

472
00:19:24,620 --> 00:19:28,430
Bank kemudian memberikan
koin itu kepada Alice dengan cara

473
00:19:28,430 --> 00:19:31,175
sedemikian sehingga jelas bahwa
bank yang melakukannya.

474
00:19:31,175 --> 00:19:33,050
Biasanya ini dilakukan
menggunakan teknik yang disebut

475
00:19:33,050 --> 00:19:34,490
tanda tangan digital.

476
00:19:34,490 --> 00:19:37,550
Kita akan membahasnya
saat kelas berlangsung,

477
00:19:37,550 --> 00:19:40,070
tapi tidak sekarang.

478
00:19:40,070 --> 00:19:44,270
Setelah Alice memiliki koin ini,
dia dapat memberikannya kepada Bob.

479
00:19:44,270 --> 00:19:46,633
Dan Bob dapat
melihat koin ini,

480
00:19:46,633 --> 00:19:48,800
dan semoga ada cukup
banyak hal yang terjadi dengan koin ini

481
00:19:48,800 --> 00:19:52,280
sehingga Bob dapat yakin
bahwa ini adalah koin sungguhan.

482
00:19:52,280 --> 00:19:54,360
Alice tidak membuat itu
entah dari mana.

483
00:19:54,360 --> 00:19:58,670
Dia sebenarnya punya dana,
dalam artian tertentu, untuk diberikan kepada Bob,

484
00:19:58,670 --> 00:20:00,530
dan itu belum
digunakan dua kali.

485
00:20:03,610 --> 00:20:05,270
Dan begitu Bob
yakin akan hal itu,

486
00:20:05,270 --> 00:20:06,883
dia bisa memberi Alice sandwich.

487
00:20:06,883 --> 00:20:09,050
Sekarang dalam uang elektronik tradisional,
cara melakukannya

488
00:20:09,050 --> 00:20:11,450
adalah Bob benar-benar pergi
kembali ke bank

489
00:20:11,450 --> 00:20:13,580
dan berkata, inilah koinnya.

490
00:20:13,580 --> 00:20:15,850
Alice baru saja memberiku koin ini.

491
00:20:15,850 --> 00:20:17,870
Apakah ini koin yang OK?

492
00:20:17,870 --> 00:20:21,170
Tapi faktanya adalah
bahwa bank, dalam hal ini,

493
00:20:21,170 --> 00:20:23,210
telah memiliki nomor seri
dan tahu itu

494
00:20:23,210 --> 00:20:25,430
berikan nomor seri yang unik
itu kepada Alice,

495
00:20:25,430 --> 00:20:28,040
dan kemudian Bob muncul
dengan koin yang

496
00:20:28,040 --> 00:20:30,050
merupakan nomor seri tersebut.

497
00:20:30,050 --> 00:20:32,390
Dan apa yang bank lakukan
di sini, dalam contoh ini,

498
00:20:32,390 --> 00:20:36,532
adalah cara bank tersebut
memeriksa untuk memastikan

499
00:20:36,532 --> 00:20:38,990
bahwa koin ini adalah benar seperti
yang terlihat di nomor serinya,

500
00:20:38,990 --> 00:20:42,110
dan itu dapat memastikan bahwa koin
belum pernah dipakai sebelumnya.

501
00:20:42,110 --> 00:20:46,100
Jadi bank bisa menghubungkan
koin antara Alice dan Bob,

502
00:20:46,100 --> 00:20:47,570
yang cukup disayangkan.

503
00:20:47,570 --> 00:20:51,410
Itu masih harus dilakukan
secara daring,

504
00:20:51,410 --> 00:20:53,780
tidak melakukan pembayaran sebenarnya
antara Alice dan Bob,

505
00:20:53,780 --> 00:20:56,270
tetapi agar Bob
memiliki kepercayaan

506
00:20:56,270 --> 00:20:58,850
bahwa koin ini asli.

507
00:20:58,850 --> 00:21:03,678
Dan nanti Bob bisa bilang, saya
ingin $1.00 untuk koin ini

508
00:21:03,678 --> 00:21:05,720
yang baru saya berikan ke Anda,
atau kurang lebih itu.

509
00:21:05,720 --> 00:21:07,940
Atau Bob bisa mempunyai
sebuah akun dengan bank

510
00:21:07,940 --> 00:21:09,320
dan bisa menyimpan
saldo disana.

511
00:21:11,940 --> 00:21:17,720
Jadi hanya untuk melewati beberapa
pro dan kontra di sini,

512
00:21:17,720 --> 00:21:21,020
OK, jadi kita sudah melakukan
sesuatu dimana bank tidak

513
00:21:21,020 --> 00:21:23,600
berada di tengah, namun bank
sebenarnya masih berada di tengah.

514
00:21:23,600 --> 00:21:28,850
Kita sudah menjadi lebih dekat
selangkah, tapi kita belum sampai ke sana.

515
00:21:28,850 --> 00:21:33,080
Alice secara teknis bisa memberikan
Bob suatu benda elektronik yang

516
00:21:33,080 --> 00:21:35,530
mempresentasikan sebuah nilai,
namun Bob masih butuh

517
00:21:35,530 --> 00:21:37,280
untuk berbicara dengan bank
untuk memastikan benda itu asli

518
00:21:37,280 --> 00:21:38,660
dan belum digunakan dua kali.

519
00:21:38,660 --> 00:21:41,330
Kita juga masih mempunyai masalah
ketika bank adalah pihak yang

520
00:21:41,330 --> 00:21:42,740
mencetak benda ini.

521
00:21:42,740 --> 00:21:44,600
Bank bisa memutuskan untuk
tidak memberikan kepada Alice

522
00:21:44,600 --> 00:21:46,490
sebuah koin jika mereka mau.

523
00:21:46,490 --> 00:21:48,080
Kita juga masih memiliki
permasalahan privasi

524
00:21:48,080 --> 00:21:51,500
karena nomor rahasia,
nomor serial yang kita

525
00:21:51,500 --> 00:21:54,410
ciptakan untuk koin, bisa
dilacak dari pembayaran-pembayaran ini.

526
00:21:57,660 --> 00:22:00,530
Jadi ada sebuah
gagasan mengenai sesuatu

527
00:22:00,530 --> 00:22:01,870
yang disebut Chaumian e-cash.

528
00:22:01,870 --> 00:22:04,070
Jadi David Chaumian
adalah seorang kriptografer,

529
00:22:04,070 --> 00:22:06,590
dan dia mengembangkan
sistem ini yang

530
00:22:06,590 --> 00:22:12,170
memiliki sedikit properti yang lebih bagus
dibandingkan bentuk uang elektronik sebelumnya

531
00:22:12,170 --> 00:22:15,290
Jadi, idenya disini yang merupakan
sesuatu yang penting adalah,

532
00:22:15,290 --> 00:22:18,770
daripada bank yang memilih
nomor rahasia,

533
00:22:18,770 --> 00:22:20,990
Alice yang memilih nomor rahasia.

534
00:22:20,990 --> 00:22:23,780
Dan kita memiliki banyak cara untuk
menghasilkan angka secara acak

535
00:22:23,780 --> 00:22:26,070
yang kita dapat cukup yakin mereka
bersifat unik.

536
00:22:26,070 --> 00:22:29,700
Jadi, kita menyuruh setiap orang
menghasilkan angka acak yang mereka inginkan

537
00:22:29,700 --> 00:22:33,140
Jadi dalam uang elektronik Chaumian ini,
Alice memilih angka rahasia

538
00:22:33,140 --> 00:22:34,760
yang merepresentasikan sebuah koin.

539
00:22:34,760 --> 00:22:37,880
Kemudian Alice menutupi
pesannya.

540
00:22:37,880 --> 00:22:42,020
Jadi Alice menambahkan beberapa angka acak
ke angka rahasia sedemikian rupa

541
00:22:42,020 --> 00:22:45,230
sehingga bank tidak mengetahui
angka apa yang sebenarnya dia pilih.

542
00:22:45,230 --> 00:22:48,140
Kemudian kita akan mendalami lebih detil
mengenai maksud hal itu sebenarnya

543
00:22:48,140 --> 00:22:50,150
Itu semua sudah berada dalam
paper yang sudah dibagikan

544
00:22:50,150 --> 00:22:51,710
untuk dibaca di kelas ini,
jadi pastikan

545
00:22:51,710 --> 00:22:54,450
kalian membacanya.

546
00:22:54,450 --> 00:22:58,640
Jadi ketika bank memverifikasi bahwa
angka rahasia itu adalah sebuah

547
00:22:58,640 --> 00:23:00,260
angka rahasia yang benar dan
itu merupakan sebuah koin,

548
00:23:00,260 --> 00:23:03,530
dan Alice memberikan bank
1 dolar atau semacamnya,

549
00:23:03,530 --> 00:23:06,500
maka bank melakukan hal yang
sama pada angka rahasia yang tertutup

550
00:23:06,500 --> 00:23:08,180
Dan Alice sebenarnya memiliki
kemampuan

551
00:23:08,180 --> 00:23:11,330
untuk menghapus keacakan itu,
atau penutupan itu, kemudian

552
00:23:11,330 --> 00:23:16,760
dan berakhir dengan sebuah tanda tangan
yang sah pada sebuah nomor rahasia.

553
00:23:16,760 --> 00:23:19,040
Jadi Alice melakukan hal yang sama
dengan hal yang dia lakukan sebelumnya.

554
00:23:19,040 --> 00:23:22,400
Dia memberi Bob sebuah representasi
dari koin elektronik itu.

555
00:23:22,400 --> 00:23:25,820
Dan ketika Bob menukarkan itu,
perhatikan bahwa bank tidak pernah

556
00:23:25,820 --> 00:23:28,340
melihat berapa jumlahnya,
Jadi ketika Bob menukarkan itu,

557
00:23:28,340 --> 00:23:31,490
bank tidak memiliki cara untuk menghubungkan
pembayaran antara Alice

558
00:23:31,490 --> 00:23:33,250
dan Bob.

559
00:23:33,250 --> 00:23:36,220
Jadi hanya untuk membahas bagaimana
ini bekerja secara visual,

560
00:23:36,220 --> 00:23:39,700
Alice akan berbicara dengan
bank, dan Alice

561
00:23:39,700 --> 00:23:43,660
akan menggunakan faktor penutup
pada nomor rahasia.

562
00:23:43,660 --> 00:23:45,430
Dan ketika Alice
berbicara dengan bank,

563
00:23:45,430 --> 00:23:47,763
bank tidak benar-benar melihat
apa nomor rahasia itu.

564
00:23:47,763 --> 00:23:49,000
Mereka tidak bisa memecahkan kode itu.

565
00:23:49,000 --> 00:23:52,810
Sekali lagi, Alice memberikan $1.00 atau
semacamnya untuk mendapatkan

566
00:23:52,810 --> 00:23:54,640
koin ini dari bank.

567
00:23:54,640 --> 00:23:57,040
Dan bank menandatangani ini.

568
00:23:57,040 --> 00:24:00,940
Alice dapat menghapus
faktor penutup nanti.

569
00:24:00,940 --> 00:24:02,560
Dan inilah koin tersebut.

570
00:24:02,560 --> 00:24:05,110
Koin ini adalah tanda tangan
bank yang sah

571
00:24:05,110 --> 00:24:08,440
pada nomor rahasia itu, dan
juga nomor itu sendiri,

572
00:24:08,440 --> 00:24:11,500
di mana Alice bisa
kemudian mengirimkan kepada Bob.

573
00:24:11,500 --> 00:24:14,740
Bob bisa memeriksa dan memastikan
bahwa ini adalah tanda tangan yang sah

574
00:24:14,740 --> 00:24:16,690
dari bank.

575
00:24:16,690 --> 00:24:22,360
Dan jika itu benar, maka
Bob bisa memberi Alice sebuah sandwich.

576
00:24:22,360 --> 00:24:26,650
Untuk menukarkan ini, Bob
memberikan koin ini ke bank.

577
00:24:26,650 --> 00:24:33,190
Bank berkata, OK, saya tidak pernah
melihat nomor rahasia sebelumnya,

578
00:24:33,190 --> 00:24:35,000
dan Anda memiliki tanda tangan saya di atasnya.

579
00:24:35,000 --> 00:24:37,292
Jadi saya akan berasumsi bahwa
saya telah melalui proses ini

580
00:24:37,292 --> 00:24:39,700
dengan seseorang dan
menandatangani sesuatu.

581
00:24:39,700 --> 00:24:42,370
Dan sekarang saya akan mencatat
nomor rahasia itu.

582
00:24:42,370 --> 00:24:43,870
Setelah itu terjadi,
Bob bisa yakin

583
00:24:43,870 --> 00:24:46,060
bahwa koin ini belum
dihabiskan sebelumnya.

584
00:24:46,060 --> 00:24:48,620
Bank menyimpan daftar
dari semua nomor rahasia

585
00:24:48,620 --> 00:24:53,050
yang pernah dia lihat, dan memastikan
bahwa jika melihatnya lagi,

586
00:24:53,050 --> 00:24:56,260
dia bisa mengatakan tidak, ini
tidak benar.

587
00:24:56,260 --> 00:24:59,260
Saya seharusnya tidak pernah melihat nomor
rahasia lebih dari sekali.

588
00:24:59,260 --> 00:25:00,190
Sekarang, OK.

589
00:25:00,190 --> 00:25:04,900
Tapi tahu bagaimana dengan Alice
bisa memberikan satu versi itu

590
00:25:04,900 --> 00:25:05,470
kepada Bob.

591
00:25:05,470 --> 00:25:08,230
Alice juga bisa memberikan
versi itu untuk Charlie.

592
00:25:08,230 --> 00:25:10,870
Dan bagaimana Charlie
dan Bob seharusnya

593
00:25:10,870 --> 00:25:15,010
mengetahui koin siapa yang benar?

594
00:25:15,010 --> 00:25:17,260
Karena ingat, kita ingin
mencoba mengeluarkan peran bank

595
00:25:17,260 --> 00:25:19,210
dengan cara kita melakukan hal ini.

596
00:25:19,210 --> 00:25:21,250
Dan begitu juga di uang elektronik
Chaumian, cara

597
00:25:21,250 --> 00:25:22,990
kerjanya adalah
bank sebenarnya

598
00:25:22,990 --> 00:25:26,150
menyimpan lebih banyak informasi.

599
00:25:26,150 --> 00:25:29,920
Dan informasi
yang disimpan oleh bank

600
00:25:29,920 --> 00:25:33,370
tidak akan membiarkan bank menghubungkan
transaksi ini bersama-sama

601
00:25:33,370 --> 00:25:37,570
kecuali Alice kebetulan
memberikan ini kepada dua orang.

602
00:25:37,570 --> 00:25:41,260
Jadi jika Alice memberikan koin
yang sama kepada dua orang berbeda,

603
00:25:41,260 --> 00:25:43,330
bank akan
mampu mendeteksinya

604
00:25:43,330 --> 00:25:46,060
dan bank akan
mengetahui bahwa itu adalah Alice.

605
00:25:46,060 --> 00:25:50,200
Jadi ini semacam sebuah
motivasi bagi Alice

606
00:25:50,200 --> 00:25:51,740
untuk tidak melakukan itu.

607
00:25:51,740 --> 00:25:55,180
Jadi idenya disini adalah
cara kita menyiasati

608
00:25:55,180 --> 00:25:59,860
fakta bahwa kita tidak tahu apakah
koin sudah sebelumnya

609
00:25:59,860 --> 00:26:05,140
atau tidak adalah dengan kita memberikan hukuman
jika koin tersebut digunakan dua kali lipat.

610
00:26:05,140 --> 00:26:08,050
Jadi Bob tidak tahu pasti
koin yang diterimanya ini

611
00:26:08,050 --> 00:26:11,590
belum digunakan, tetapi
dia tahu bahwa jika ya,

612
00:26:11,590 --> 00:26:13,480
seseorang akan tahu
itu adalah Alice,

613
00:26:13,480 --> 00:26:17,480
dan mereka akan menghukumnya.

614
00:26:17,480 --> 00:26:19,460
Jadi ini adalah skema
yang cukup pintar.

615
00:26:19,460 --> 00:26:24,820
Dan ini sebenarnya membuat kita
mengatasi banyak masalah.

616
00:26:24,820 --> 00:26:26,260
Kita memiliki pembayaran digital.

617
00:26:26,260 --> 00:26:30,340
Kita dapat melakukan transfer
tanpa bank di tengahnya.

618
00:26:30,340 --> 00:26:33,250
Kita sekarang memiliki privasi
karena bank tidak bisa

619
00:26:33,250 --> 00:26:36,160
menghubungkan transaksi yang satu dengan lainnya.

620
00:26:36,160 --> 00:26:39,010
Dan kita punya cara ini untuk
melakukan deteksi penggunaan ganda.

621
00:26:39,010 --> 00:26:41,050
Kita punya cara untuk
memotivasi orang

622
00:26:41,050 --> 00:26:43,780
tidak menggunakan koin mereka berulang,
berarti Anda mungkin

623
00:26:43,780 --> 00:26:46,120
tidak perlu memeriksa apakah
koin tersebut sudah digunakan

624
00:26:46,120 --> 00:26:49,420
sebelumnya atau belum,
ketika Anda menerimanya.

625
00:26:49,420 --> 00:26:53,990
Tentu, ini masih mengalami
kendala yang cukup besar

626
00:26:53,990 --> 00:26:56,950
yaitu bank masih bisa
memutuskan bahwa mereka

627
00:26:56,950 --> 00:26:58,242
tidak mau melakukan hal ini dengan kamu.

628
00:26:58,242 --> 00:26:59,950
Mereka bisa memutuskan
kalau mereka tidak mau

629
00:26:59,950 --> 00:27:01,090
memainkan permainan ini dengan Anda.

630
00:27:01,090 --> 00:27:03,755
Mereka tidak mau mengeluarkan koin.

631
00:27:03,755 --> 00:27:05,380
Mungkin mereka hanya
tidak suka dengan Anda.

632
00:27:05,380 --> 00:27:07,870
Mungkin mereka tidak mau mengambil
koin Anda dan menukarnya.

633
00:27:07,870 --> 00:27:12,310
Jadi skema ini, Chaumian e-cash,
menyelesaikan beberapa masalah

634
00:27:12,310 --> 00:27:15,820
tentang bagaimana
kita memiliki uang elektronik

635
00:27:15,820 --> 00:27:20,110
dengan fitur yang baik,
tapi itu masih belum

636
00:27:20,110 --> 00:27:22,240
mencakup semuanya.

637
00:27:22,240 --> 00:27:25,080
Jadi pertanyaan
sebenarnya untuk kelas ini

638
00:27:25,080 --> 00:27:28,350
sebenarnya, adalah bagaimana kita
menggunakan uang elektronik,

639
00:27:28,350 --> 00:27:29,970
dalam situasi
peer-to-peer, dimana

640
00:27:29,970 --> 00:27:31,680
tidak ada institusi yang terlibat.

641
00:27:31,680 --> 00:27:35,768
Tidak ada entitas yang dapat
mengatakan tidak.

642
00:27:35,768 --> 00:27:38,060
Tadge Dryja: Jadi e-cash, dalam
matematika itu sangat menarik

643
00:27:38,060 --> 00:27:42,050
Ia akan terus mengandalkan bank dan
karena itu ia tidak pernah

644
00:27:42,050 --> 00:27:43,190
benar-benar populer.

645
00:27:43,190 --> 00:27:47,240
Jadi saya ingin membicarakan
mengenai sesuatu yang lebih bersifat abstrak 

646
00:27:47,240 --> 00:27:49,400
dan memiliki tingkat primitif rendah.

647
00:27:49,400 --> 00:27:55,490
Saya tidak akan membahas mengenai
uang tunai atau token atau transfer

648
00:27:55,490 --> 00:27:57,530
atau apapun dalam kuliah ini

649
00:27:57,530 --> 00:27:59,960
Tapi saya akan membahas mengenai
hal primitif secara dasar

650
00:27:59,960 --> 00:28:02,990
yang Anda butuhkan dan sudah
disebutkan sebelumnya,

651
00:28:02,990 --> 00:28:04,880
fungsi hash dan tandatangan.

652
00:28:04,880 --> 00:28:07,790
Tandatangan, tentu saja kita
sudah membicarakan sedikit,

653
00:28:07,790 --> 00:28:10,070
apa yang Anda butuhkan untuk
dapat menandai sebuah pesan

654
00:28:10,070 --> 00:28:11,510
agar dapat mengirimkan token ke mana pun.

655
00:28:11,510 --> 00:28:14,900
Tapi pertama saya akan membicarakan
mengenai fungsi hash, yang pada dasarnya

656
00:28:14,900 --> 00:28:18,980
merupakan sebuah hal yang paling
mendasar yang kita gunakan pada sistem ini.

657
00:28:18,980 --> 00:28:21,345
Dan saya pikir jika kalian sudah
menggunakan komputer,

658
00:28:21,345 --> 00:28:22,720
atau kalian sudah sedikit melakukan
pemrograman,

659
00:28:22,720 --> 00:28:24,590
kemungkinan kalian akan
merasa familiar

660
00:28:24,590 --> 00:28:26,540
dengan fungsi hash.

661
00:28:26,540 --> 00:28:29,460
Mereka simpel, namun
sebenarnya mereka sangat kuat.

662
00:28:29,460 --> 00:28:31,160
Fungsi hash ini pada dasarnya sebagai
berikut: Anda

663
00:28:31,160 --> 00:28:32,990
memiliki beberapa data,
sekumpulan bytes,

664
00:28:32,990 --> 00:28:34,333
sekumpulan angka 1 dan 0.

665
00:28:34,333 --> 00:28:35,750
Anda menjalankannya melalui
sebuah fungsi hash

666
00:28:35,750 --> 00:28:38,930
dan Anda mendapatkan sebuah keluaran yang
juga sekumpulan angka 1 dan 0.

667
00:28:38,930 --> 00:28:42,120
Umumnya, data
masukan bisa dalam berbagai ukuran.

668
00:28:42,120 --> 00:28:43,460
Anda bisa menghitung hash sesuatu--

669
00:28:43,460 --> 00:28:45,290
dimasukkan ke dalam megabyte,
dimasukkan ke dalam gigabyte,

670
00:28:45,290 --> 00:28:47,900
atau dimasukkan ke dalam satu byte,
dan umumnya keluaran

671
00:28:47,900 --> 00:28:49,500
berukuran tetap.

672
00:28:49,500 --> 00:28:52,730
Jadi dalam kasus
bitcoin, kita menggunakan Sha-256.

673
00:28:52,730 --> 00:28:58,280
Ukuran keluaran adalah 32 byte
panjangnya, atau 256 bit panjangnya.

674
00:28:58,280 --> 00:29:03,050
Dan ini digunakan oleh banyak
hal dalam komputer.

675
00:29:03,050 --> 00:29:05,300
Saya kira alasan mereka menyebutnya
sebuah hash adalah karena itu

676
00:29:05,300 --> 00:29:07,580
seperti ketika anda mengambil
kentang dan memotongnya

677
00:29:07,580 --> 00:29:11,630
menjadi kotak kecil dan
memanggangnya untuk sarapan,

678
00:29:11,630 --> 00:29:14,180
itu adalah semacam idenya,
bahwa kita mengambil data ini.

679
00:29:14,180 --> 00:29:17,780
Dan data yang masuk akan
dipotong-potong dan dihancurkan

680
00:29:17,780 --> 00:29:21,260
dan kemudian keluar
menjadi sebuah keluaran.

681
00:29:21,260 --> 00:29:24,290
Jadi ini bukan sebuah definisi
yang cukup berbeda.

682
00:29:24,290 --> 00:29:27,320
Tetapi saya akan mengatakan bahwa Anda
dapat semacam melakukan segalanya

683
00:29:27,320 --> 00:29:28,660
dengan fungsi hash.

684
00:29:28,660 --> 00:29:30,410
Ada beberapa hal yang menyenangkan
yang anda tidak dapat lakukan,

685
00:29:30,410 --> 00:29:33,110
tetapi Anda dapat membuat
mata uang dijital hanya menggunakan

686
00:29:33,110 --> 00:29:34,940
satu fungsi hash.

687
00:29:34,940 --> 00:29:38,720
Dan saya pikir orang-orang punya, semacam
untuk alasan eksperimental.

688
00:29:38,720 --> 00:29:43,460
Anda membatasi hal-hal menyenangkan yang bisa Anda
lakukan, tetapi anda bisa melakukan tanda tangan.

689
00:29:43,460 --> 00:29:45,070
Anda bisa melakukan enkripsi.

690
00:29:45,070 --> 00:29:47,460
Anda bisa melakukan segala macam
hal-hal seperti itu.

691
00:29:47,460 --> 00:29:47,960
OK.

692
00:29:47,960 --> 00:29:50,960
Jadi ini bukan
definisi yang cukup,

693
00:29:50,960 --> 00:29:55,310
bahwa ada ukuran apapun
masukan, ukuran keluaran tetap,

694
00:29:55,310 --> 00:29:57,580
dan hasilnya adalah
tampak acak.

695
00:29:57,580 --> 00:29:58,940
Itu semacam plin-plan.

696
00:29:58,940 --> 00:30:02,540
Tapi apa maksud yang dilakukannya
tampak acak?

697
00:30:02,540 --> 00:30:03,890
Ini sebenarnya tidak acak.

698
00:30:03,890 --> 00:30:06,328
Jika Anda memasukkan
masukan yang sama, semuanya

699
00:30:06,328 --> 00:30:07,370
akan mendapatkan hasil yang sama.

700
00:30:07,370 --> 00:30:10,010
Jadi jika Anda berkata, oke,
apa hashnya,

701
00:30:10,010 --> 00:30:11,280
Anda akan mendapatkan beberapa hasil.

702
00:30:11,280 --> 00:30:13,640
Adan jika orang lain berkata,
OK, apa hashnya,

703
00:30:13,640 --> 00:30:15,810
Anda akan mendapatkan hal yang sama.

704
00:30:15,810 --> 00:30:19,820
Namun, hasilnya,
sementara itu deterministik,

705
00:30:19,820 --> 00:30:23,270
entropinya cukup
tinggi dalam arti

706
00:30:23,270 --> 00:30:26,840
keluar harus memiliki jumlah
bit satu hampir sama dengan bit nol.

707
00:30:26,840 --> 00:30:28,400
Jika Anda menghitung
hash dari sesuatu, itu

708
00:30:28,400 --> 00:30:30,233
hanya akan terlihat seperti
angka acak besar.

709
00:30:30,233 --> 00:30:32,690
Dan hash dari sesuatu yang lain akan terlihat
seperti angka acak yang

710
00:30:32,690 --> 00:30:34,643
tidak terkait.

711
00:30:34,643 --> 00:30:35,810
Keluarannya terlihat seperti kebisingan.

712
00:30:35,810 --> 00:30:37,760
Jadi jika Anda pernah
melihat fungsi hash,

713
00:30:37,760 --> 00:30:39,810
Anda bisa menjalankannya di komputer Anda.

714
00:30:39,810 --> 00:30:41,280
Anda mengatakan echo.

715
00:30:41,280 --> 00:30:44,180
Hallo, jumlah pipa
sha-256, dan Anda hanya akan

716
00:30:44,180 --> 00:30:46,580
mendapatkan sesuatu yang
gila, dan acak.

717
00:30:46,580 --> 00:30:50,680
Sepertinya tidak ada
urutan apa pun ke keluarannya.

718
00:30:50,680 --> 00:30:52,368
Sedikit lebih terdefinisi dengan baik.

719
00:30:52,368 --> 00:30:54,160
Kita biasanya berbicara tentang
efek longsoran salju,

720
00:30:54,160 --> 00:30:57,250
dalam arti mengubah
satu bit pada masukan

721
00:30:57,250 --> 00:31:00,250
akan mengubah sekitar setengah
dari keseluruhan keluarannya.

722
00:31:00,250 --> 00:31:04,440
Jadi meskipun anda mempunyai
masukan yang sangat mirip,

723
00:31:04,440 --> 00:31:07,090
mereka akan memberikan keluaran
yang sama sekali berbeda

724
00:31:07,090 --> 00:31:08,980
yah, sama sekali
berbeda, karena sekitar setengah

725
00:31:08,980 --> 00:31:09,910
dari keluaran berubah.

726
00:31:09,910 --> 00:31:11,770
Jika setiap bit
berubah, maka itu hanya

727
00:31:11,770 --> 00:31:15,910
kebalikan dari apa yang Anda miliki,
sehingga mudah dikorelasikan.

728
00:31:15,910 --> 00:31:18,040
Tapi efek longsoran
salju adalah semacam bagaimana

729
00:31:18,040 --> 00:31:20,950
fungsi hash dibangun,
dimana umumnya itu

730
00:31:20,950 --> 00:31:22,137
terdiri dari beberapa ronde.

731
00:31:22,137 --> 00:31:24,220
Maka Anda berkata, OK, saya
akan menukar hal-hal ini

732
00:31:24,220 --> 00:31:27,340
dan melipatgandakan hal-hal ini dan
menggeser bagian-bagian ini

733
00:31:27,340 --> 00:31:30,280
jika ada perubahan
di awal

734
00:31:30,280 --> 00:31:32,230
akan menyebabkan semacam
efek bola salju, juga,

735
00:31:32,230 --> 00:31:35,940
sehingga semua bit keluaran
sudah terpengaruh olehnya.

736
00:31:35,940 --> 00:31:36,440
OK.

737
00:31:36,440 --> 00:31:38,602
Dan sedikit lebih
terdefinisi dengan baik.

738
00:31:38,602 --> 00:31:40,310
Umumnya, fungsi hash
didefinisikan

739
00:31:40,310 --> 00:31:42,080
dengan apa yang seharusnya tidak mereka lakukan.

740
00:31:42,080 --> 00:31:44,420
Jadi ada tiga hal utama
yang seharusnya mereka miliki-- 

741
00:31:44,420 --> 00:31:47,390
resistensi pragambar (collision resistance),
resistensi pragambar sekunder (second collision resistance),

742
00:31:47,390 --> 00:31:50,900
yang akan saya lewati,
dan resistensi benturan.

743
00:31:50,900 --> 00:31:54,020
Dan kita bisa menentukan
hal-hal apakah ini.

744
00:31:54,020 --> 00:31:59,600
Jadi sebuah pragambar adalah hal
yang datang sebelum keluaran.

745
00:31:59,600 --> 00:32:00,890
Jadi itu semacam istilah matematika .

746
00:32:00,890 --> 00:32:06,410
Tapi idenya adalah OK, jika Anda tahu
y, Anda tidak dapat menemukan x di mana

747
00:32:06,410 --> 00:32:08,870
nilai hash dari
x sama dengan y.

748
00:32:08,870 --> 00:32:13,640
Jadi jika saya memberi Anda hasil keluaran hash,
dan hanya itu yang saya berikan kepada Anda,

749
00:32:13,640 --> 00:32:16,610
Anda seharusnya tidak dapat
menemukan masukan yang

750
00:32:16,610 --> 00:32:18,017
mengarah ke keluaran itu.

751
00:32:18,017 --> 00:32:19,850
Jadi jika saya hanya mengatakan, hei,
inilah hasil hash.

752
00:32:19,850 --> 00:32:25,250
Ini 35021FF-- apa pun,
sebuah string panjang,

753
00:32:25,250 --> 00:32:26,750
Anda tidak akan dapat
mengetahui apa yang

754
00:32:26,750 --> 00:32:30,650
saya gunakan untuk mendapatkannya.

755
00:32:30,650 --> 00:32:32,810
Tentu saja, pada akhirnya
Anda akan dapat menemukannya.

756
00:32:32,810 --> 00:32:37,100
Untuk setiap y yang diberikan,
mungkin ada beberapa x.

757
00:32:37,100 --> 00:32:38,990
Bahkan, mungkin ada
banyak x yang

758
00:32:38,990 --> 00:32:40,460
akan mengarah ke y itu.

759
00:32:40,460 --> 00:32:43,290
Karena y
panjangnya tetap dan ada

760
00:32:43,290 --> 00:32:47,900
dua pangkat 256 kemungkinan
nilai y, tetapi jumlah

761
00:32:47,900 --> 00:32:50,210
x tidak terbatas
karena x tidak

762
00:32:50,210 --> 00:32:51,200
terikat oleh panjang.

763
00:32:51,200 --> 00:32:56,000
Anda dapat memiliki sejumlah megabyte x,
gigabyte atau terabyte.

764
00:32:56,000 --> 00:32:58,700
Jadi karena ada semacam variasi
dari nilai x yang  tidak terhingga,

765
00:32:58,700 --> 00:33:03,290
dan y yang tetap, meskipun sangat
besar, selama

766
00:33:03,290 --> 00:33:05,300
pemetaannya acak,
akan ada

767
00:33:05,300 --> 00:33:08,300
banyak sekali nilai x yang berbeda
yang mengarah ke nilai y ini.

768
00:33:08,300 --> 00:33:11,030
Dan Anda harus
bisa menemukannya.

769
00:33:11,030 --> 00:33:12,647
Itu sangat tidak praktis.

770
00:33:12,647 --> 00:33:14,480
Itu seperti, yah, Anda
mungkin dapat menemukannya,

771
00:33:14,480 --> 00:33:17,680
tetapi Anda akan membutuhkan
dua pangkat 256 percobaan

772
00:33:17,680 --> 00:33:20,560
untuk menemukan nilai y nya.

773
00:33:20,560 --> 00:33:23,140
dan itu sekitar
10 pangkat 78, yang merupakan

774
00:33:23,140 --> 00:33:25,930
sebuah angka yang cukup besar
dan bisa dianggap sebagai

775
00:33:25,930 --> 00:33:27,240
bilangan tak terhingga.

776
00:33:27,240 --> 00:33:30,468
Baiklah, maksud saya, tidak
terlalu, tetapi cukup besar

777
00:33:30,468 --> 00:33:32,260
di mana Anda tidak akan bisa
menghitungnya sebelum

778
00:33:32,260 --> 00:33:34,920
matahari berhenti terbakar, dan
alam semesta mati

779
00:33:34,920 --> 00:33:37,520
dan hal-hal seperti itu

780
00:33:37,520 --> 00:33:38,770
Jadi itu ketahanan pragambar.

781
00:33:38,770 --> 00:33:41,170
Anda tidak bisa berjalan mundur.

782
00:33:41,170 --> 00:33:43,970
Diberikan hash, Anda tidak bisa
menemukan apa yang menghasilkan hash tersebut.

783
00:33:43,970 --> 00:33:44,470
Baiklah.

784
00:33:44,470 --> 00:33:48,770
Ada pertanyaan mengenai
ketahanan pragambar?

785
00:33:48,770 --> 00:33:50,780
Masuk akal?

786
00:33:50,780 --> 00:33:55,713
Ini sedikit menarik
dalam hal y yang diberikan

787
00:33:55,713 --> 00:33:57,630
sedikit rumit, dan
bahwa itu seperti, OK, baik,

788
00:33:57,630 --> 00:34:03,420
seseorang mungkin mengetahui x 
yang dapat digunakan untuk menghitung y.

789
00:34:03,420 --> 00:34:05,550
Atau mungkin itu
seluruhnya acak,

790
00:34:05,550 --> 00:34:08,820
dan tidak ada satupun yang benar-benar
tahu berapa nilai x nya.

791
00:34:08,820 --> 00:34:11,340
Jadi ada semacam
informasi yang hilang

792
00:34:11,340 --> 00:34:13,139
dalam konteks pragambar.

793
00:34:13,139 --> 00:34:13,770
OK.

794
00:34:13,770 --> 00:34:15,270
Ketahanan pragambar sekunder.

795
00:34:15,270 --> 00:34:19,650
Yang ini lebih rumit
dan dapat menjadi berantakan.

796
00:34:19,650 --> 00:34:22,290
Jadi saya akan mendefinisikannya, tetapi kita
tidak akan melihatnya terlalu jauh.

797
00:34:22,290 --> 00:34:25,739
Idenya adalah diberikan x dan
ya di mana hash dari x

798
00:34:25,739 --> 00:34:30,000
sama dengan y, Anda tidak dapat menemukan
x aksen di mana x aksen tidak

799
00:34:30,000 --> 00:34:31,080
sama dengan x.

800
00:34:31,080 --> 00:34:33,780
Dan hash dari x aksen
sama dengan y.

801
00:34:33,780 --> 00:34:35,429
Jadi kita akan kurang lebih
memberikan Anda sebuah pragambar.

802
00:34:35,429 --> 00:34:38,159
Kita mengatakan, hei, ada nilai
x ini dan ini adalah

803
00:34:38,159 --> 00:34:39,199
hasilnya y.

804
00:34:41,760 --> 00:34:47,250
Saya bertaruh Anda tidak dapat
menemukan x lain yang mengarah ke sana.

805
00:34:47,250 --> 00:34:49,929
Ini sebenarnya tidak telalu
terdefinisi dengan baik di literatur.

806
00:34:49,929 --> 00:34:52,650
Jadi itu sedikit
seperti, yah, siapa

807
00:34:52,650 --> 00:34:56,225
yang membuat x, dan siapa
yang memilih, dan apakah ada x aksen

808
00:34:56,225 --> 00:34:57,100
dan hal-hal seperti itu.

809
00:34:57,100 --> 00:34:59,830
Jadi itu sebenarnya
tidak terlalu berguna.

810
00:34:59,830 --> 00:35:02,580
Jadi kita bisa semacam
mengabaikannya,

811
00:35:02,580 --> 00:35:04,540
hanya menyebutnya saja.

812
00:35:04,540 --> 00:35:08,310
Kemudian hal lain yang sangat
penting adalah ketahanan

813
00:35:08,310 --> 00:35:13,050
pragambar, di mana idenya adalah
tidak ada seorangpun yang dapat menemukan pasangan

814
00:35:13,050 --> 00:35:16,170
x,z di mana x
tidak sama dengan z

815
00:35:16,170 --> 00:35:19,940
tetapi hash dari x
sama dengan hash dari z.

816
00:35:19,940 --> 00:35:22,160
Dan definisi yang satu ini lebih 
bersih dalam hal

817
00:35:22,160 --> 00:35:24,480
tidak ada kekurangan informasi di sana.

818
00:35:24,480 --> 00:35:26,130
Tidak ada rahasia atau apapun.

819
00:35:26,130 --> 00:35:29,060
Hanya saja, lihat, tidak ada
yang bisa menemukan ini.

820
00:35:29,060 --> 00:35:31,587
Dan ini sangat mudah untuk 
disangkal.

821
00:35:31,587 --> 00:35:33,920
Anda bisa sekedar mengatakan, hei, lihat,
ini sebuah x dan ini sebuah z.

822
00:35:33,920 --> 00:35:34,910
Coba lakukan hash terhadap mereka.

823
00:35:34,910 --> 00:35:37,643
Oh, sial, hash nya sama.

824
00:35:37,643 --> 00:35:39,560
Dan tidak terlalu penting bagaimana
Anda mendapatkannya

825
00:35:39,560 --> 00:35:40,880
atau siapa yang melakukan itu

826
00:35:40,880 --> 00:35:45,030
Jadi ini merupakan properti yang bagus,
mudah, dan jelas

827
00:35:45,030 --> 00:35:47,490
dan lagi, Anda dapat menemukannya
pada akhirnya.

828
00:35:47,490 --> 00:35:50,830
jadi jika keluaran Anda
ukurannya 256 bit,

829
00:35:50,830 --> 00:35:52,650
Anda akan dapat
menemukan dua masukan yang

830
00:35:52,650 --> 00:35:55,110
dipetakan ke keluaran yang sama.

831
00:35:55,110 --> 00:35:59,860
Bahkan, anda tidak 
perlu mencoba 256 kali.

832
00:35:59,860 --> 00:36:01,740
Saya tidak akan
membahas detailnya,

833
00:36:01,740 --> 00:36:05,970
tetapi sebenarnya anda hanya
perlu mencoba 128 kali.

834
00:36:05,970 --> 00:36:07,320
Maaf, dua pangkat 128.

835
00:36:07,320 --> 00:36:10,740
Jadi Anda perlu mengambil akar
kuadrat dari jumlah percobaan 

836
00:36:10,740 --> 00:36:14,880
untuk menemukan tabrakan (collision) ini
karena alasan intuitifnya

837
00:36:14,880 --> 00:36:17,790
adalah, yah, Anda cukup mencoba
berbagai kemungkinan dan mencatat

838
00:36:17,790 --> 00:36:19,680
semua hashnya.

839
00:36:19,680 --> 00:36:23,340
Dan ada yang disebut
serangan ulang tahun (birthday attack), yang,

840
00:36:23,340 --> 00:36:26,310
saat Anda terus mencobanya,
da lebih banyak kemungkinan.

841
00:36:26,310 --> 00:36:28,110
Hal berikutnya yang Anda
coba, Anda bisa bertabrakan

842
00:36:28,110 --> 00:36:30,248
dengan salah satu hal yang
pernah Anda coba sebelumnya.

843
00:36:30,248 --> 00:36:32,415
Jadi Anda sebenarnya hanya
perlu melakukan akar kuadrat.

844
00:36:32,415 --> 00:36:33,873
Dan itu disebut
serangan ulang tahun

845
00:36:33,873 --> 00:36:37,050
karena ada paradoks
ulang tahun, yang sebenarnya bukanlah

846
00:36:37,050 --> 00:36:40,290
sebuah paradoks, tetapi idenya
adalah di dalam ruangan ini,

847
00:36:40,290 --> 00:36:42,540
ada orang-orang
yang mempunyai ulang tahun yang sama.

848
00:36:42,540 --> 00:36:44,910
Itu hampir pasti,
yang tampaknya sedikit aneh

849
00:36:44,910 --> 00:36:47,760
karena hal yang intuitif adalah,
seperti, yah, terdapat 365 hari

850
00:36:47,760 --> 00:36:48,420
setahun.

851
00:36:48,420 --> 00:36:52,878
Mungkin anda pernah mendapatkan 160,
170 orang dalam ruangan,

852
00:36:52,878 --> 00:36:55,170
anda akan mempunyai dua
orang dengan ulang tahun yang sama.

853
00:36:55,170 --> 00:36:58,870
Tetapi sebenarnya, itu seperti
22 atau yang lainya--

854
00:36:58,870 --> 00:37:01,320
bagaimanapun, akan ada orang
yang kemungkinan

855
00:37:01,320 --> 00:37:02,550
memiliki ulang tahun yang sama.

856
00:37:02,550 --> 00:37:03,990
jadi itu seperti,
berlawanan dengan intuisi

857
00:37:03,990 --> 00:37:05,740
dan itu berlaku di dalam
kasus ini juga.

858
00:37:05,740 --> 00:37:08,190
Jadi untuk mencari tabrakannya,
Anda harus mencari akar kuadrat

859
00:37:08,190 --> 00:37:10,860
dari kemungkinan keluaran nya.

860
00:37:10,860 --> 00:37:14,070
Tetapi fungsi hash seharusnya
tidak memiliki collision.

861
00:37:14,070 --> 00:37:16,170
Jika Anda dapat menemukan sebuah
collision, jika satu collision saja

862
00:37:16,170 --> 00:37:18,180
ada untuk
fungsi hash ini, Anda

863
00:37:18,180 --> 00:37:20,753
dapat menganggap
fungsi hash rusak.

864
00:37:20,753 --> 00:37:22,920
Ini sedikit berbeda
dari resistensi pragambar

865
00:37:22,920 --> 00:37:25,800
karena sulit untuk
secara definitif membuktikan

866
00:37:25,800 --> 00:37:27,180
bahwa anda sudah merusak pragambar.

867
00:37:27,180 --> 00:37:29,190
Itu adalah
proses interaktif di mana

868
00:37:29,190 --> 00:37:31,722
Anda berkata, hai, ini sebuah y,
dan kemudian seseorang datang

869
00:37:31,722 --> 00:37:33,180
dengan x, dan
Anda seperti, oh, oke,

870
00:37:33,180 --> 00:37:36,120
anda membuktikan kepada saya bahwa
anda dapat menemukan pragambar.

871
00:37:36,120 --> 00:37:38,130
Tapi sulit untuk memberitahu
ke seluruh dunia

872
00:37:38,130 --> 00:37:40,230
karena itu semacam
interaktif,

873
00:37:40,230 --> 00:37:43,290
sedangkan tabrakan sangat
jelas dan non-interaktif.

874
00:37:43,290 --> 00:37:45,990
Anda hanya bisa mengatakan, hei,
ini x dan ini z.

875
00:37:45,990 --> 00:37:47,320
Siapa pun dapat memverifikasi ini.

876
00:37:47,320 --> 00:37:49,450
Tidak terlalu penting
bagaimana Anda mendapatkannya.

877
00:37:49,450 --> 00:37:49,950
Oke.

878
00:37:49,950 --> 00:37:55,360
Jadi beberapa hal praktis, bagaimana
fungsi-fungsi ini bekerja.

879
00:37:55,360 --> 00:37:57,850
Secara praktis,
resistensi tabrakan

880
00:37:57,850 --> 00:37:59,830
adalah properti yang lebih sulit.

881
00:37:59,830 --> 00:38:03,130
Jadi ada banyak fungsi
di mana resistensi tabrakan

882
00:38:03,130 --> 00:38:06,670
telah dipatahkan di mana
resistensi pragambar belum

883
00:38:06,670 --> 00:38:07,510
dipecahkan.

884
00:38:07,510 --> 00:38:10,270
Jadi contohnya adalah SHA-1 and MD5.

885
00:38:10,270 --> 00:38:15,250
MD5 adalah suatu hal yang cukup tua
yang ditulis oleh Ron Rivest di--

886
00:38:15,250 --> 00:38:17,350
yah, saya rasa itu bukan
di State Center

887
00:38:17,350 --> 00:38:18,880
karena itu ada di sekitar tahun 80an.

888
00:38:18,880 --> 00:38:21,100
Tetapi ini adalah Message Digest 5.

889
00:38:21,100 --> 00:38:23,500
Saya rasa ada beberapa
di antaranya sebelumnya.

890
00:38:23,500 --> 00:38:25,780
Dan ini cukup rusak.

891
00:38:25,780 --> 00:38:26,680
Anda sebaiknya tidak menggunakannya.

892
00:38:26,680 --> 00:38:30,790
Resistensi tabrakannya yang
sangat rusak.

893
00:38:30,790 --> 00:38:34,710
Anda dapat menemukan tabrakan di bawah
satu detik pada komputer moderen.

894
00:38:34,710 --> 00:38:39,910
SHA-1 muncul setelahnya, pada
akhir 90an, saya rasa,

895
00:38:39,910 --> 00:38:41,290
dan NSA yang membuatnya.

896
00:38:41,290 --> 00:38:43,220
Dan sudah ada beberapa
tabrakan ditemukan.

897
00:38:43,220 --> 00:38:45,220
Saya pikir di situ hanya ada
satu tabrakan yang

898
00:38:45,220 --> 00:38:48,250
telah ditemukan, dasarnya,
oleh sebuah tim di Google

899
00:38:48,250 --> 00:38:51,730
dan beberapa universitas Italia
tahun lalu.

900
00:38:51,730 --> 00:38:55,390
dan mereka menghabiskan banyak
waktu komputer untuk menemukan tabrakan ini.

901
00:38:55,390 --> 00:38:56,530
Tetapi mereka menemukanya.

902
00:38:56,530 --> 00:38:58,210
Dan sekali Anda menemukanya,
itu seperti, oh, ya,

903
00:38:58,210 --> 00:39:00,100
kita benar-benar tidak bisa
menggunakan ini lagi.

904
00:39:00,100 --> 00:39:03,100
Tetapi di kedua kasus ini,
SHA-1 dan MD5,

905
00:39:03,100 --> 00:39:05,620
tidak ada serangan pragambar
yang bisa dilakukan.

906
00:39:05,620 --> 00:39:07,812
Jadi diberikan keluaran hash
untuk salah satu dari ini,

907
00:39:07,812 --> 00:39:09,520
Anda tidak dapat menemukan apa
inputnya, atau Anda

908
00:39:09,520 --> 00:39:11,260
tidak dapat menemukan input yang berbeda.

909
00:39:11,260 --> 00:39:14,410
Jadi secara umum, jauh lebih
mudah membuat fungsi

910
00:39:14,410 --> 00:39:16,240
kuat terhadap pragambar.

911
00:39:16,240 --> 00:39:20,800
Tabrakan agak lebih 
sulit untuk ditangani.

912
00:39:20,800 --> 00:39:24,260
Juga, secara praktis, bagaimana
fungsi hash ini bekerja?

913
00:39:24,260 --> 00:39:26,690
Ini seperti
ilmu hitam.

914
00:39:26,690 --> 00:39:31,450
Tidak ada bukti bahwa
fungsi hash bahkan bisa ada.

915
00:39:31,450 --> 00:39:35,050
Jadi jika anda bisa membuktikan
ada satu fungsi satu arah,

916
00:39:35,050 --> 00:39:37,150
Anda mendapatkan Fields Medal, benar?

917
00:39:37,150 --> 00:39:38,890
Ini seperti hadiah
satu juta dolar.

918
00:39:38,890 --> 00:39:40,390
Jadi jika Anda dapat membuktikan
bahwa terdapat

919
00:39:40,390 --> 00:39:42,310
sebuah hal seperti fungsi
hash, Anda akan menjadi

920
00:39:42,310 --> 00:39:44,410
matematikawan yang sangat terkenal.

921
00:39:44,410 --> 00:39:47,250
Kami tidak tahu bahwa hal ini
mungkin secara matematis.

922
00:39:47,250 --> 00:39:49,520
Atau mungkin alam semesta
tidak bekerja seperti ini.

923
00:39:49,520 --> 00:39:50,980
Meskipun, terlihatnya seperti itu.

924
00:39:50,980 --> 00:39:53,110
Di sana terlihat seperti
terdapat sesuatu yang

925
00:39:53,110 --> 00:39:55,780
bekerja seperti fungsi hash, yang
bekerja seperti fungsi satu arah

926
00:39:55,780 --> 00:39:57,300
tetapi kita tidak punya bukti mengenai itu.

927
00:39:57,300 --> 00:40:02,517
Bahkan bagian yang paling mendasar
yang semua bergantung padanya,

928
00:40:02,517 --> 00:40:03,850
kita bahkan tidak tahu apakah itu ada.

929
00:40:03,850 --> 00:40:06,670
Dan lalu hal semacam
yang berhubungan erat,

930
00:40:06,670 --> 00:40:08,530
jika Anda di dalam
hal komputer sains,

931
00:40:08,530 --> 00:40:11,670
seperti p dan mp--

932
00:40:11,670 --> 00:40:15,400
bagaimanapun, jadi kami tidak tahu
bahwa ini benar-benar bekerja.

933
00:40:15,400 --> 00:40:18,190
Dan juga, dalam praktisnya,
fungsi hash

934
00:40:18,190 --> 00:40:21,610
bukan matematika yang bagus, hal keren
seperti kurva epileptik

935
00:40:21,610 --> 00:40:24,370
dan RSA, angka prima
dan hal seperti itu.

936
00:40:24,370 --> 00:40:27,700
Mereka benar-benar, jika Anda melihat ke
kodenya, itu seperti,

937
00:40:27,700 --> 00:40:29,260
Baiklah, Saya akan mengambil
bytes itu

938
00:40:29,260 --> 00:40:30,397
dan saya akan menukar mereka.

939
00:40:30,397 --> 00:40:32,230
Dan kemudian saya akan
menambahkan dua angka ini,

940
00:40:32,230 --> 00:40:34,900
kemudian saya akan
menukar bit disini,

941
00:40:34,900 --> 00:40:36,880
kemudian saya akan
x melalui benda ini.

942
00:40:36,880 --> 00:40:39,100
Kemudian saya akan
melakukan itu 50 kali.

943
00:40:39,100 --> 00:40:39,820
Dan mengapa 50?

944
00:40:39,820 --> 00:40:42,290
Ya, Sepertinya
50 adalah angka yang bagus.

945
00:40:42,290 --> 00:40:43,810
Ini tidak terlalu lambat.

946
00:40:43,810 --> 00:40:44,650
Tidak, benar.

947
00:40:44,650 --> 00:40:50,180
Ini seperti ilmu hitam,
Sha-256 menggunakan 64 putaran.

948
00:40:50,180 --> 00:40:52,120
Angka genap yang bagus.

949
00:40:52,120 --> 00:40:55,222
Fungsi-fungsi berbeda seperti
Blake 2B menggunakan 20 putaran.

950
00:40:55,222 --> 00:40:56,930
Tetapi kemudian terdapat juga
sebuah versi yang menggunakan

951
00:40:56,930 --> 00:40:58,510
12 putaran, yang lebih cepat.

952
00:40:58,510 --> 00:41:02,710
Dan orang-orang berpikir, baik, tampaknya
masih cukup aman.

953
00:41:02,710 --> 00:41:04,370
Tetapi jika Anda ingin
benar-benar aman,

954
00:41:04,370 --> 00:41:05,440
gunakan varian 20 putaran.

955
00:41:05,440 --> 00:41:07,148
Jika Anda ingin
cukup aman saja,

956
00:41:07,148 --> 00:41:08,300
gunakan varian 12 putaran.

957
00:41:08,300 --> 00:41:11,830
Jadi tidak ada bukti.

958
00:41:11,830 --> 00:41:15,460
Ada heuristik dan hal-hal
seperti itu, dan saran praktik yang baik.

959
00:41:15,460 --> 00:41:20,440
Tapi kriptografi semacam ini
adalah sedikit sihir hitam.

960
00:41:20,440 --> 00:41:24,580
Dan itu tidak didasarkan pada
teori bilangan yang keren,

961
00:41:24,580 --> 00:41:27,130
ataupun, cara yang sama
dengan kriptografi kurva

962
00:41:27,130 --> 00:41:29,800
eliptik atau hal-hal terkait RSA.

963
00:41:29,800 --> 00:41:31,330
Jadi jika Anda memecahkan
RSA, Anda dapat berkata,

964
00:41:31,330 --> 00:41:34,960
hei, saya sekarang dapat memfaktorkan 
bilangan komposit ini

965
00:41:34,960 --> 00:41:37,300
dengan sangat cepat, itu,
dengan sendirinya,

966
00:41:37,300 --> 00:41:39,040
sebuah penemuan matematika yang keren.

967
00:41:39,040 --> 00:41:43,000
Pecahnya SHA-1,
sebenarnya tidak terkait dengan

968
00:41:43,000 --> 00:41:44,530
wawasan matematika yang keren.

969
00:41:44,530 --> 00:41:47,020
Itu seperti, ya, kita
menemukan cara yang cukup spesifik ini,

970
00:41:47,020 --> 00:41:50,080
agak aneh kita
dapat memecahkan SHA-1

971
00:41:50,080 --> 00:41:52,830
setelah beberapa
tahun menggunakan komputer.

972
00:41:52,830 --> 00:41:56,900
Jadi itu keren, dan beberapa
orang sangat menyukainya.

973
00:41:56,900 --> 00:41:59,960
Tapi itu sesuatu yang khusus untuk
benar-benar membangun fungsi hash.

974
00:41:59,960 --> 00:42:02,630
Saya akan merekomendasikan untuk tidak membangun
fungsi hash Anda sendiri.

975
00:42:02,630 --> 00:42:03,170
Ya.

976
00:42:03,170 --> 00:42:04,670
AUDIENS: Saya Wayne,
dan pertanyaan saya

977
00:42:04,670 --> 00:42:08,020
adalah, apakah pemecahan sebuah fungsi hash
benar-benar hanya menebak dan memeriksa,

978
00:42:08,020 --> 00:42:10,118
atau adakah
metode lain untuk itu?

979
00:42:10,118 --> 00:42:10,910
TADGE DRYJA: Tidak.

980
00:42:10,910 --> 00:42:16,490
Jika Anda mengatakan, hei, saya
menemukan tabrakan

981
00:42:16,490 --> 00:42:19,700
dengan melakukan dua pangkat
128 percobaan.

982
00:42:19,700 --> 00:42:21,980
Satu, tidak ada yang melakukan dua
hingga 128 percobaan.

983
00:42:21,980 --> 00:42:25,162
Itu masih dilihat sebagai
lebih canggih dari teknologi saat ini.

984
00:42:25,162 --> 00:42:27,620
Tetapi jika itu cara Anda memecah
fungsinya, itu tidak benar-benar

985
00:42:27,620 --> 00:42:29,995
dianggap memecah karena
itu semacam definisinya,

986
00:42:29,995 --> 00:42:33,260
adalah yah, baiklah, kita tahu
ini panjangnya 256 bit.

987
00:42:33,260 --> 00:42:36,950
Jadi untuk menemukan gambar awal, jika Anda
lakukan dua sampai percobaan ke 256,

988
00:42:36,950 --> 00:42:37,700
Anda akan menemukannya.

989
00:42:37,700 --> 00:42:39,170
Jadi itu tidak
diperhitungkan sebagai pemecahan.

990
00:42:39,170 --> 00:42:43,310
Sebuah pemecahan diperhitungkan sebagai, hei,
saya menemukan sebuah gambar awal dalam dua

991
00:42:43,310 --> 00:42:45,560
pangkat percobaan ke 240.

992
00:42:45,560 --> 00:42:49,040
Atau saya mempunyai bukti
yang akan membuat Anda

993
00:42:49,040 --> 00:42:51,950
mampu menemukan sebuah gambar awal dalam
dua pangkat 240 percobaan,

994
00:42:51,950 --> 00:42:53,150
dan ini adalah bagaimana Anda melakukannya.

995
00:42:53,150 --> 00:42:55,070
Dan itu diperhitungkan sebagai pemecahan.

996
00:42:55,070 --> 00:42:56,210
Hal itu masih tidak praktis.

997
00:42:56,210 --> 00:42:58,580
Dua pangkat 240 tetap
mustahil dengan teknologi

998
00:42:58,580 --> 00:43:00,020
saat ini.

999
00:43:00,020 --> 00:43:01,985
Tetapi jika Anda menulis paper
dan orang lain membacanya,

1000
00:43:01,985 --> 00:43:04,610
seperti, oh, yah, itu akan berkerja,
Anda tidak akan sanggup melakukan itu.

1001
00:43:04,610 --> 00:43:07,190
Tetapi itu tetap
dianggap rusak.

1002
00:43:07,190 --> 00:43:13,480
Dan jadi sesuatu seperti
MD5, besar keluaran MD5

1003
00:43:13,480 --> 00:43:15,810
adalah 16 bytes atau 128 bits.

1004
00:43:15,810 --> 00:43:19,790
Jadi tabrakan, bahkan
jika itu pernah kuat,

1005
00:43:19,790 --> 00:43:22,370
itu akan tetap jadi
terlalu pendek saat ini

1006
00:43:22,370 --> 00:43:26,390
di mana tabrakan akan dapat
ditemukan dalam dua pangkat 64

1007
00:43:26,390 --> 00:43:29,540
iterasi, yang mana dapat dilakukan
oleh komputer hari ini.

1008
00:43:29,540 --> 00:43:33,230
Jika Anda menjalankan beberapa hal di
AWS, Anda dapat mengerjakan dua pangkat 64

1009
00:43:33,230 --> 00:43:35,840
dalam beberapa hari.

1010
00:43:35,840 --> 00:43:37,700
Tetapi itu adalah
definisi berbeda

1011
00:43:37,700 --> 00:43:40,690
dari memecahkan fungsinya.

1012
00:43:40,690 --> 00:43:41,900
Menyenangkan.

1013
00:43:41,900 --> 00:43:44,120
Ethan Hellman,
seseorang di BU dan kita

1014
00:43:44,120 --> 00:43:49,070
bekerja bersamanya, dia-- dan kita semua memecahkan 
IOTA menulis sendiri fungsi

1015
00:43:49,070 --> 00:43:51,050
hash, yang mana seperti
beberapa mata uang kripto.

1016
00:43:51,050 --> 00:43:52,980
Dan kita menemukan tabrakan didalamnya.

1017
00:43:52,980 --> 00:43:55,180
Dan itu menyenangkan.

1018
00:43:55,180 --> 00:43:57,072
Tapi yah, itu aneh.

1019
00:43:57,072 --> 00:43:58,280
itu tidak seperti teori angka.

1020
00:43:58,280 --> 00:44:00,650
Itu seperti, oh, baik,
Saya menulis kode Python ini

1021
00:44:00,650 --> 00:44:03,740
dan kita punya skrip yang berjalan,
dan kita coba hal ini

1022
00:44:03,740 --> 00:44:05,153
dan kita mendapat sebuah tabrakan.

1023
00:44:05,153 --> 00:44:06,070
Jadi itu cukup menyenangkan.

1024
00:44:06,070 --> 00:44:07,400
Jadi, kegunaan.

1025
00:44:07,400 --> 00:44:10,070
Untuk apa Anda gunakan
hashes ini?

1026
00:44:10,070 --> 00:44:12,230
Banyak hal keren yang dapat Anda
lakukan dengan ini.

1027
00:44:12,230 --> 00:44:14,870
gunakan mereka seperti semacam
nama atau referensi,

1028
00:44:14,870 --> 00:44:19,850
dimana daripada memberi nama pada
sebuah file, Anda dapat

1029
00:44:19,850 --> 00:44:21,620
mengambil hash dari sebuah file.

1030
00:44:21,620 --> 00:44:27,770
And that is a good, compact
representation so you can point

1031
00:44:27,770 --> 00:44:29,450
to what you're talking about .

1032
00:44:29,450 --> 00:44:32,660
So the hash of a file is
a unique representation.

1033
00:44:32,660 --> 00:44:35,360
And if you change
any bit in that file,

1034
00:44:35,360 --> 00:44:36,770
the hash will change.

1035
00:44:36,770 --> 00:44:41,180
And so you know that, OK, here's
this way to point to a file.

1036
00:44:41,180 --> 00:44:43,520
You can also use it as sort
of a reference or pointer

1037
00:44:43,520 --> 00:44:46,320
in different algorithms.

1038
00:44:46,320 --> 00:44:50,420
So you can say, anything
you're using pointers for,

1039
00:44:50,420 --> 00:44:53,760
linked lists or maps and
stuff like that, you can say,

1040
00:44:53,760 --> 00:44:56,900
well, I'm going to use
a hash as a pointer

1041
00:44:56,900 --> 00:45:00,540
and then be able to sort
through it that way.

1042
00:45:00,540 --> 00:45:05,690
So anytime you think of pointers
and graph theory and stuff

1043
00:45:05,690 --> 00:45:08,330
like that in computer
science, think, well,

1044
00:45:08,330 --> 00:45:11,170
could I use a hash function
here instead of just

1045
00:45:11,170 --> 00:45:12,740
like regular memory pointer?

1046
00:45:12,740 --> 00:45:14,390
And in many cases, you can.

1047
00:45:14,390 --> 00:45:15,710
In some cases, you can't.

1048
00:45:15,710 --> 00:45:17,920
So you can't have cycles.

1049
00:45:17,920 --> 00:45:20,270
So the idea is you
can't find preimages,

1050
00:45:20,270 --> 00:45:22,340
you won't be able to find a--

1051
00:45:22,340 --> 00:45:26,930
whereas you could make a cycle
of pointers in a computer,

1052
00:45:26,930 --> 00:45:28,595
where A points to
B, B points to C,

1053
00:45:28,595 --> 00:45:31,460
C points back to
A. You shouldn't

1054
00:45:31,460 --> 00:45:34,010
be able to produce that
with hash functions

1055
00:45:34,010 --> 00:45:37,130
because having that cycle
means, OK, well, somehow you

1056
00:45:37,130 --> 00:45:38,330
found this preimage.

1057
00:45:41,230 --> 00:45:43,350
But in many cases,
you can do this.

1058
00:45:43,350 --> 00:45:46,290
And another way to look at it
is the hash is a commitment.

1059
00:45:46,290 --> 00:45:48,960
You can say, well, I'm not
going to tell you what x is,

1060
00:45:48,960 --> 00:45:53,400
but I'll tell you what y is,
and I can reveal x later.

1061
00:45:53,400 --> 00:45:55,590
And then, since
everyone remembers y,

1062
00:45:55,590 --> 00:45:59,042
they can be sure that yeah,
he's revealing the right thing.

1063
00:45:59,042 --> 00:46:00,750
There are no collisions
in this function,

1064
00:46:00,750 --> 00:46:02,310
so we can be sure,
if we're presented

1065
00:46:02,310 --> 00:46:06,680
with x, that this was the x
that was committed to yesterday.

1066
00:46:06,680 --> 00:46:11,280
So I'll give a little example
of that, of commit and reveal.

1067
00:46:11,280 --> 00:46:13,640
So you can commit to some
kind of secret or something

1068
00:46:13,640 --> 00:46:15,910
you want to reveal later
and reveal the preimage.

1069
00:46:15,910 --> 00:46:18,260
So here's my commitment.

1070
00:46:18,260 --> 00:46:21,950
This is an actual hash, Sha-256.

1071
00:46:21,950 --> 00:46:23,780
I just made it on my computer.

1072
00:46:23,780 --> 00:46:25,220
And there is a string.

1073
00:46:25,220 --> 00:46:28,550
There's an Ascii string
that maps into this,

1074
00:46:28,550 --> 00:46:31,490
and it is a prediction
about the weather,

1075
00:46:31,490 --> 00:46:32,510
but that's all I'll say.

1076
00:46:32,510 --> 00:46:35,330
And given that information
and given this hash,

1077
00:46:35,330 --> 00:46:38,060
you probably can't
find my prediction.

1078
00:46:38,060 --> 00:46:40,610
You can try to try all these
different Ascii strings

1079
00:46:40,610 --> 00:46:44,930
about the weather today,
but I'll reveal it.

1080
00:46:44,930 --> 00:46:47,550
So I think it won't
snow Wednesday.

1081
00:46:47,550 --> 00:46:49,370
But I think it
actually-- anyway,

1082
00:46:49,370 --> 00:46:50,630
and then I put this number in.

1083
00:46:50,630 --> 00:46:53,900
And so if you put this in
your computer in Linux--

1084
00:46:53,900 --> 00:46:56,450
I think in Mac it's a
slightly different command.

1085
00:46:56,450 --> 00:46:59,993
It's like Sha-2 or something.

1086
00:46:59,993 --> 00:47:01,910
But in Linux, this will
work, and you can say,

1087
00:47:01,910 --> 00:47:03,860
I think it won't snow Wednesday.

1088
00:47:03,860 --> 00:47:06,860
And then I put some
random numbers here

1089
00:47:06,860 --> 00:47:10,100
because if I had committed
to just the phrase,

1090
00:47:10,100 --> 00:47:12,380
I think it won't
snow Wednesday, you

1091
00:47:12,380 --> 00:47:14,330
might have been
able to guess that.

1092
00:47:14,330 --> 00:47:16,580
You could say, well, he said
it was about the weather.

1093
00:47:16,580 --> 00:47:19,760
I'm going to take
all sorts of millions

1094
00:47:19,760 --> 00:47:21,770
of different strings
related to days

1095
00:47:21,770 --> 00:47:23,725
and weather and
common English words,

1096
00:47:23,725 --> 00:47:25,100
and I'm going to
try hashing them

1097
00:47:25,100 --> 00:47:26,720
and see if I find a collision.

1098
00:47:26,720 --> 00:47:28,340
And you might be able to.

1099
00:47:28,340 --> 00:47:30,920
But I added this four
bytes of randomness

1100
00:47:30,920 --> 00:47:33,390
at the end to make
that difficult.

1101
00:47:33,390 --> 00:47:35,600
It doesn't really
contribute to my commitment.

1102
00:47:35,600 --> 00:47:38,480
And you know this doesn't
really mean anything.

1103
00:47:38,480 --> 00:47:43,610
But it makes it harder to
guess what my input was

1104
00:47:43,610 --> 00:47:45,410
because I've already
revealed that it's not

1105
00:47:45,410 --> 00:47:46,910
a fully random input.

1106
00:47:46,910 --> 00:47:48,920
So you might be able
to guess things.

1107
00:47:48,920 --> 00:47:50,810
So I could say, hey,
I'm going to make

1108
00:47:50,810 --> 00:47:55,160
a prediction about the
weather, commit to it,

1109
00:47:55,160 --> 00:47:57,260
and then reveal my
prediction tomorrow.

1110
00:47:57,260 --> 00:47:59,990
And we'll see if I was right.

1111
00:47:59,990 --> 00:48:03,747
This can be useful
in the case where--

1112
00:48:03,747 --> 00:48:05,330
not the weather, but
in other things--

1113
00:48:05,330 --> 00:48:10,130
if knowing my prediction could
influence the actual events,

1114
00:48:10,130 --> 00:48:13,422
this would be a nice way to
commit to what my prediction is

1115
00:48:13,422 --> 00:48:15,380
without everyone knowing
what the prediction is

1116
00:48:15,380 --> 00:48:17,260
and then revealing
it the next day.

1117
00:48:17,260 --> 00:48:17,760
Yes.

1118
00:48:17,760 --> 00:48:19,927
AUDIENCE: What are the use
cases for double hashing,

1119
00:48:19,927 --> 00:48:22,000
like where you would
hash that hash?

1120
00:48:22,000 --> 00:48:24,840
TADGE DRYJA: Hashing this again?

1121
00:48:24,840 --> 00:48:29,210
Well, so in bitcoin they
hash everything twice.

1122
00:48:33,330 --> 00:48:36,180
Generally, you don't need to.

1123
00:48:36,180 --> 00:48:39,870
There's no explanation for
why they do that in bitcoin.

1124
00:48:39,870 --> 00:48:40,950
You could.

1125
00:48:40,950 --> 00:48:42,780
But there are things
you can construct

1126
00:48:42,780 --> 00:48:45,908
where you can, say,
append some extra data

1127
00:48:45,908 --> 00:48:46,950
and then hash this again.

1128
00:48:46,950 --> 00:48:51,180
So you can say, here's my
prediction for next week.

1129
00:48:51,180 --> 00:48:54,180
And this is the hash,
and then hash it again.

1130
00:48:54,180 --> 00:48:56,850
So you can make
chains of commitments

1131
00:48:56,850 --> 00:49:00,150
and then reveal
iterations of it.

1132
00:49:00,150 --> 00:49:01,530
Actually, I had
some slides where

1133
00:49:01,530 --> 00:49:05,280
you can sort of hash
something again and again,

1134
00:49:05,280 --> 00:49:09,190
and start revealing
it incrementally.

1135
00:49:09,190 --> 00:49:10,390
That might be useful.

1136
00:49:10,390 --> 00:49:12,350
I actually have stuff
like that in software.

1137
00:49:12,350 --> 00:49:16,200
I've written where you
want to reveal secrets.

1138
00:49:16,200 --> 00:49:18,520
But let's say I want
to reveal secrets,

1139
00:49:18,520 --> 00:49:21,310
but I don't want everyone to
have to store all of them.

1140
00:49:21,310 --> 00:49:26,080
So I can make a chain of
hashes, commit to the last one,

1141
00:49:26,080 --> 00:49:28,870
and then as I reveal
successive preimages,

1142
00:49:28,870 --> 00:49:30,370
you don't have to
store all of them.

1143
00:49:30,370 --> 00:49:34,210
You can just store
the latest preimage,

1144
00:49:34,210 --> 00:49:37,150
and you can reconstruct
all the hashes from that.

1145
00:49:37,150 --> 00:49:38,850
Yes.

1146
00:49:38,850 --> 00:49:40,308
AUDIENCE: But is
it computationally

1147
00:49:40,308 --> 00:49:42,730
difficult to run double hashes?

1148
00:49:42,730 --> 00:49:44,110
TADGE DRYJA: So to evaluate--

1149
00:49:44,110 --> 00:49:46,720
if you want to try this,
it's imperceptible.

1150
00:49:46,720 --> 00:49:50,798
To perform one
Sha-256 hash is, I

1151
00:49:50,798 --> 00:49:52,840
don't know, a billionth
of a second or something.

1152
00:49:52,840 --> 00:49:57,850
You can generally do,
like, 100 megabytes

1153
00:49:57,850 --> 00:50:01,455
to a gigabyte of hash
output on a regular CPU.

1154
00:50:01,455 --> 00:50:02,830
NEHA NARULA: I
think she's asking

1155
00:50:02,830 --> 00:50:05,830
does it make it harder to find
a preimage if you hash twice,

1156
00:50:05,830 --> 00:50:06,838
and the answer's no.

1157
00:50:06,838 --> 00:50:08,380
TADGE DRYJA: The
answer's sort of no.

1158
00:50:08,380 --> 00:50:10,480
It might.

1159
00:50:10,480 --> 00:50:14,410
So I don't know, chained MD5,
can you still find collisions?

1160
00:50:14,410 --> 00:50:15,640
I'm not sure.

1161
00:50:15,640 --> 00:50:19,540
But generally the thinking is,
if the hash function is broken,

1162
00:50:19,540 --> 00:50:22,160
and you can either find
collisions or preimages, yeah,

1163
00:50:22,160 --> 00:50:25,450
maybe it gets a little
harder by iterating it.

1164
00:50:25,450 --> 00:50:27,040
But you should
just stop using it

1165
00:50:27,040 --> 00:50:29,640
and use something that's secure.

1166
00:50:29,640 --> 00:50:32,937
But yeah, it seems
that finding preimages

1167
00:50:32,937 --> 00:50:35,020
would be harder since it's
essentially adding more

1168
00:50:35,020 --> 00:50:38,290
rounds by hashing it twice.

1169
00:50:38,290 --> 00:50:41,290
And then there are some attacks,
so it's fairly out there.

1170
00:50:41,290 --> 00:50:43,870
But it's called length
extension attacks

1171
00:50:43,870 --> 00:50:46,150
due to how hash functions
are constructed,

1172
00:50:46,150 --> 00:50:48,280
where if you do say, OK,
I'm going to take the hash

1173
00:50:48,280 --> 00:50:50,410
and then take the
hash of that, you

1174
00:50:50,410 --> 00:50:54,970
do prevent certain types of
attacks that are fairly niche.

1175
00:50:54,970 --> 00:50:57,150
But a length
extinction attack in

1176
00:50:57,150 --> 00:51:00,640
a Merkle-Damgard construction
will be prevented by this.

1177
00:51:00,640 --> 00:51:01,838
So generally, no.

1178
00:51:01,838 --> 00:51:03,380
Generally, you don't
need to do this.

1179
00:51:03,380 --> 00:51:05,170
But there are different
constructions where you're

1180
00:51:05,170 --> 00:51:06,610
going to hash a bunch of times.

1181
00:51:06,610 --> 00:51:09,250
I don't have the slides
here but, like a Merkle tree

1182
00:51:09,250 --> 00:51:11,745
is a binary tree of
hashes where you're

1183
00:51:11,745 --> 00:51:13,120
taking the hashes
of these things

1184
00:51:13,120 --> 00:51:14,680
and then hashing
it again and again,

1185
00:51:14,680 --> 00:51:16,540
and that's a really
useful data structure.

1186
00:51:16,540 --> 00:51:20,950
And a blockchain is
essentially a chain of hashes.

1187
00:51:20,950 --> 00:51:24,460
And that's what we'll
talk about next week.

1188
00:51:24,460 --> 00:51:24,980
But yeah.

1189
00:51:24,980 --> 00:51:25,480
OK.

1190
00:51:25,480 --> 00:51:27,040
So I'm going to go
a little faster.

1191
00:51:27,040 --> 00:51:28,810
So that's an interesting
use case where

1192
00:51:28,810 --> 00:51:30,160
you can commit and reveal.

1193
00:51:30,160 --> 00:51:34,950
And yeah, adding randomness so
you can't guess the preimage.

1194
00:51:34,950 --> 00:51:38,880
This is called a hash-based
message authentication

1195
00:51:38,880 --> 00:51:43,380
code where part of it is
secret and part of it is not.

1196
00:51:43,380 --> 00:51:47,640
And this is getting towards a
signature, where I've committed

1197
00:51:47,640 --> 00:51:49,350
to something, and
then I reveal it,

1198
00:51:49,350 --> 00:51:51,270
and everyone knows,
yeah, that must be what

1199
00:51:51,270 --> 00:51:53,220
he committed to the day before.

1200
00:51:53,220 --> 00:51:57,760
It's not quite a signature, but
it's getting to that direction.

1201
00:51:57,760 --> 00:52:01,440
And so next I'm going to
talk about signatures.

1202
00:52:01,440 --> 00:52:03,510
What is a signature?

1203
00:52:03,510 --> 00:52:07,410
It's useful, and it's a
message signed by someone.

1204
00:52:07,410 --> 00:52:09,370
And so I'll define
what a signature

1205
00:52:09,370 --> 00:52:12,753
is through the
functions that it uses.

1206
00:52:12,753 --> 00:52:14,170
There's three
functions will allow

1207
00:52:14,170 --> 00:52:16,480
you to create a
signature scheme,

1208
00:52:16,480 --> 00:52:20,050
generate keys, sign, and verify.

1209
00:52:20,050 --> 00:52:22,060
And these different things.

1210
00:52:22,060 --> 00:52:26,230
Generate keys, you make a
secret key and a public key.

1211
00:52:26,230 --> 00:52:28,720
And so the idea is there's
some public key which is

1212
00:52:28,720 --> 00:52:33,160
your identity , and there's
some secret key which you only

1213
00:52:33,160 --> 00:52:33,700
control.

1214
00:52:33,700 --> 00:52:36,670
And you use that to
prove your identity

1215
00:52:36,670 --> 00:52:40,480
and prove that these
messages are signed by you.

1216
00:52:40,480 --> 00:52:43,210
So yeah, you
generate a key pair.

1217
00:52:43,210 --> 00:52:46,960
The holder of the secret
key can sign a message.

1218
00:52:46,960 --> 00:52:49,930
And then anyone
possessing a public key

1219
00:52:49,930 --> 00:52:53,230
can verify a message
signature pair.

1220
00:52:53,230 --> 00:52:57,500
So I'll go into detail
on these three functions.

1221
00:52:57,500 --> 00:52:58,930
And this applies generally.

1222
00:52:58,930 --> 00:53:03,160
So I'm going to talk about a
hash-based signature in detail,

1223
00:53:03,160 --> 00:53:05,980
but there are many
different signature schemes.

1224
00:53:05,980 --> 00:53:11,860
DSA, ElGamal, RSA signatures,
elliptic curve signatures.

1225
00:53:11,860 --> 00:53:16,120
There's tons of different
cool math systems that

1226
00:53:16,120 --> 00:53:19,450
allow these kinds of functions.

1227
00:53:19,450 --> 00:53:20,950
And I'll talk
about in some ways,

1228
00:53:20,950 --> 00:53:23,445
this is one of
the simplest ones.

1229
00:53:23,445 --> 00:53:25,070
So yeah, there's
these three functions.

1230
00:53:25,070 --> 00:53:26,690
The first one is generate keys.

1231
00:53:26,690 --> 00:53:29,860
And it returns a private
key public key pair.

1232
00:53:29,860 --> 00:53:32,500
And it generally doesn't
take any arguments,

1233
00:53:32,500 --> 00:53:34,030
but it takes in randomness.

1234
00:53:34,030 --> 00:53:35,020
You need to flip coins.

1235
00:53:35,020 --> 00:53:38,200
You need to find random
one and zero bits.

1236
00:53:38,200 --> 00:53:40,300
And it has to be long
enough that no one else can

1237
00:53:40,300 --> 00:53:42,040
guess what your private key is.

1238
00:53:44,737 --> 00:53:46,320
So you have a private
key, public key.

1239
00:53:46,320 --> 00:53:47,220
Public key is public.

1240
00:53:47,220 --> 00:53:48,080
You tell everyone.

1241
00:53:48,080 --> 00:53:50,868
Private key is more secret key.

1242
00:53:50,868 --> 00:53:53,160
Actually, I think in the
code, I always say secret key.

1243
00:53:53,160 --> 00:53:55,290
It's usually better to say
secret key because at least it

1244
00:53:55,290 --> 00:53:56,707
starts with a
letter that's not p.

1245
00:53:59,200 --> 00:53:59,700
OK.

1246
00:53:59,700 --> 00:54:01,440
And then the signing
function, where

1247
00:54:01,440 --> 00:54:03,360
you take your secret
key and your message,

1248
00:54:03,360 --> 00:54:08,160
and it signs a message
and returns a signature.

1249
00:54:08,160 --> 00:54:10,890
All these things are just
strings of ones and zeros.

1250
00:54:10,890 --> 00:54:12,720
It's just a bunch of bytes.

1251
00:54:12,720 --> 00:54:15,780
Public key, a private key,
a signature, a message.

1252
00:54:15,780 --> 00:54:17,950
These are all just bytes.

1253
00:54:17,950 --> 00:54:20,780
And then the verify function,
which is the most complex.

1254
00:54:20,780 --> 00:54:24,550
A verify function takes a
public key that you've seen,

1255
00:54:24,550 --> 00:54:26,920
a message, and a signature.

1256
00:54:26,920 --> 00:54:31,000
And it returns a Boolean
whether this was valid or not.

1257
00:54:31,000 --> 00:54:32,455
So it returns a single bit.

1258
00:54:32,455 --> 00:54:34,330
If it's zero, it says,
yeah, these two things

1259
00:54:34,330 --> 00:54:36,820
don't match up.

1260
00:54:36,820 --> 00:54:39,300
Maybe the message just
changed, or maybe the signature

1261
00:54:39,300 --> 00:54:41,550
has changed, or maybe it's
from a different public key

1262
00:54:41,550 --> 00:54:42,100
or something.

1263
00:54:42,100 --> 00:54:44,830
But if all three of
these are correct,

1264
00:54:44,830 --> 00:54:47,780
and the signing function
was the private key--

1265
00:54:47,780 --> 00:54:50,050
the secret key associated
with this public key--

1266
00:54:50,050 --> 00:54:52,860
was signed to this message
and produce this signature,

1267
00:54:52,860 --> 00:54:55,810
then it will return true.

1268
00:54:55,810 --> 00:54:58,120
And so you get into
the math properties

1269
00:54:58,120 --> 00:55:01,090
of what does it mean
to forge a signature,

1270
00:55:01,090 --> 00:55:04,480
and can they be forgeable
computationally?

1271
00:55:04,480 --> 00:55:07,330
Eventually a lot of these
things, since it's bits,

1272
00:55:07,330 --> 00:55:09,190
you could eventually
guess the forgery.

1273
00:55:09,190 --> 00:55:12,780
But maybe that takes two to
the 256 attempts or something.

1274
00:55:12,780 --> 00:55:13,280
OK.

1275
00:55:13,280 --> 00:55:17,108
So any questions about the
basic structure of what

1276
00:55:17,108 --> 00:55:18,400
constitutes a signature scheme?

1277
00:55:21,430 --> 00:55:22,780
Mostly make sense?

1278
00:55:22,780 --> 00:55:25,480
And you can see
how this is useful.

1279
00:55:25,480 --> 00:55:27,730
You can publish a public
key and say, hey, I'm Tadge.

1280
00:55:27,730 --> 00:55:28,840
This is my public key.

1281
00:55:28,840 --> 00:55:33,630
And in fact, on my business
card, I have a RSA public key.

1282
00:55:33,630 --> 00:55:36,477
And so if people get my business
card and then I sign a message

1283
00:55:36,477 --> 00:55:38,560
and email it to them, they
could be sure that, oh,

1284
00:55:38,560 --> 00:55:40,660
this is probably the same guy.

1285
00:55:40,660 --> 00:55:42,440
Nobody ever cares.

1286
00:55:42,440 --> 00:55:49,810
But it's useful for the
stuff we were talking about

1287
00:55:49,810 --> 00:55:53,740
before with Chaumian cash, where
Alice needs to authenticate

1288
00:55:53,740 --> 00:55:56,290
to the bank, and one way to
do it is to sign a message

1289
00:55:56,290 --> 00:55:59,590
and say, hey, I'm
Alice, give me a coin.

1290
00:55:59,590 --> 00:56:03,070
And then Alice can sign a
message to Bob and so on.

1291
00:56:03,070 --> 00:56:05,620
So this is really useful as a
basic building block for all

1292
00:56:05,620 --> 00:56:08,090
these kinds of messages.

1293
00:56:08,090 --> 00:56:11,710
So I'll talk in
the last 14 minutes

1294
00:56:11,710 --> 00:56:13,600
about signatures from hashes.

1295
00:56:13,600 --> 00:56:14,440
This is doable.

1296
00:56:14,440 --> 00:56:18,550
Using just hash functions, you
can construct a signatures key.

1297
00:56:18,550 --> 00:56:21,760
And in fact, that's
the first problem set.

1298
00:56:21,760 --> 00:56:25,390
And you implement a signature
system using only hashes.

1299
00:56:25,390 --> 00:56:27,700
And the hash function is
already defined for you.

1300
00:56:27,700 --> 00:56:28,990
It's in the standard library.

1301
00:56:28,990 --> 00:56:32,000
It's just Sha-256, the
same thing bitcoin uses.

1302
00:56:32,000 --> 00:56:33,850
And this is called
Lamport signatures.

1303
00:56:33,850 --> 00:56:37,090
Leslie Lamport wrote
about this late '70s.

1304
00:56:37,090 --> 00:56:39,850
I forget exactly when
the paper came out.

1305
00:56:39,850 --> 00:56:43,420
But this was one of the
earliest cryptographic signature

1306
00:56:43,420 --> 00:56:45,260
schemes.

1307
00:56:45,260 --> 00:56:47,150
And it's kind of cool.

1308
00:56:47,150 --> 00:56:51,280
And another fun thing is
it's quantum resistant.

1309
00:56:51,280 --> 00:56:53,410
So if you know about
quantum computers,

1310
00:56:53,410 --> 00:56:55,960
quantum computers kind
of ruin all the fun

1311
00:56:55,960 --> 00:56:57,880
in terms of cryptography.

1312
00:56:57,880 --> 00:57:00,335
All the cool things we can do
with cryptography-- not all,

1313
00:57:00,335 --> 00:57:01,960
but most of them get
ruined by quantum.

1314
00:57:01,960 --> 00:57:04,960
Computers but hash
functions are quite

1315
00:57:04,960 --> 00:57:07,720
resistant to quantum
computers because they're not

1316
00:57:07,720 --> 00:57:08,715
based on any fun math.

1317
00:57:08,715 --> 00:57:10,090
They're based on
this black magic

1318
00:57:10,090 --> 00:57:14,740
of just XORing and
shifting numbers around.

1319
00:57:14,740 --> 00:57:18,495
That's a huge
oversimplification.

1320
00:57:18,495 --> 00:57:19,870
But yeah, so those
hash functions

1321
00:57:19,870 --> 00:57:21,590
are generally seen to
be quantum-resistance.

1322
00:57:21,590 --> 00:57:23,230
So if you have a
signature scheme that

1323
00:57:23,230 --> 00:57:25,120
only uses hash
functions, well, it still

1324
00:57:25,120 --> 00:57:27,238
works, even if someone
invents a quantum computer

1325
00:57:27,238 --> 00:57:28,780
and can break all
these other things,

1326
00:57:28,780 --> 00:57:31,690
like RSA and elliptic curves.

1327
00:57:31,690 --> 00:57:33,250
So there's actually
renewed interest

1328
00:57:33,250 --> 00:57:36,200
in these kinds of
systems recently.

1329
00:57:36,200 --> 00:57:36,700
OK.

1330
00:57:36,700 --> 00:57:41,570
So how do you make a signature
scene with just hash functions?

1331
00:57:41,570 --> 00:57:43,960
So how do you generate
a key, in this case?

1332
00:57:43,960 --> 00:57:47,740
So a public key and a private
key you want to generate.

1333
00:57:47,740 --> 00:57:49,390
So first we generate
our private key.

1334
00:57:49,390 --> 00:57:55,910
Now these squares
are 32 bytes each,

1335
00:57:55,910 --> 00:57:59,130
and you generate 256
of them on this row,

1336
00:57:59,130 --> 00:58:00,990
256 of them on that row.

1337
00:58:00,990 --> 00:58:08,220
So you're generating 256 times
two, or 512 32-byte blocks.

1338
00:58:08,220 --> 00:58:11,550
And these blocks are each
256 bits or 32 bytes.

1339
00:58:11,550 --> 00:58:13,890
So in total, that's what, 8K?

1340
00:58:13,890 --> 00:58:15,480
Eight kilobytes, I think.

1341
00:58:15,480 --> 00:58:16,400
Pretty big.

1342
00:58:16,400 --> 00:58:18,810
But anyway, you're saying,
OK, here's my private key.

1343
00:58:18,810 --> 00:58:20,310
It's all completely random.

1344
00:58:20,310 --> 00:58:24,060
I just take slash dev
slash urandom or whatever,

1345
00:58:24,060 --> 00:58:29,610
just flip coins 8,000 times,
or however many this is total,

1346
00:58:29,610 --> 00:58:31,320
and generate all
these different blocks

1347
00:58:31,320 --> 00:58:34,460
and store them on my hard
drive and keep it secret.

1348
00:58:34,460 --> 00:58:37,150
Then I want to generate
the public key.

1349
00:58:37,150 --> 00:58:39,810
So for each of these
32-byte blocks,

1350
00:58:39,810 --> 00:58:42,290
I take the hash of it,
which will also be 32 bytes.

1351
00:58:45,570 --> 00:58:52,020
So there's now 512 hashes, 256
on this row, 256 on this row.

1352
00:58:52,020 --> 00:58:55,740
The green will be my public key.

1353
00:58:55,740 --> 00:58:58,410
And the gray one
is my secret key.

1354
00:58:58,410 --> 00:58:59,910
So they all look the same.

1355
00:58:59,910 --> 00:59:03,000
They all look like just a
bunch of random ones and zeros.

1356
00:59:03,000 --> 00:59:06,300
The gray ones actually are a
bunch of random ones and zeros.

1357
00:59:06,300 --> 00:59:08,700
The green ones are
actually hashes, though,

1358
00:59:08,700 --> 00:59:10,260
of all the gray ones.

1359
00:59:10,260 --> 00:59:12,830
And I publish the green ones.

1360
00:59:12,830 --> 00:59:15,270
Just to serialize it,
I just put in a row.

1361
00:59:15,270 --> 00:59:18,210
I say, OK, here's this first
32-bit, second, third, fourth,

1362
00:59:18,210 --> 00:59:22,660
and then go to this row or
whatever scheme you want.

1363
00:59:22,660 --> 00:59:24,190
So how is this useful?

1364
00:59:24,190 --> 00:59:27,670
Now everyone knows
a bunch of hashes,

1365
00:59:27,670 --> 00:59:31,480
and I know a bunch
of the preimages.

1366
00:59:31,480 --> 00:59:34,120
So now it's sort of this
commit reveal thing, where

1367
00:59:34,120 --> 00:59:38,590
if I reveal to you this,
you can verify that, oh,

1368
00:59:38,590 --> 00:59:43,450
yeah, that mapped to
this one later on.

1369
00:59:43,450 --> 00:59:46,910
Any questions so far
about this process?

1370
00:59:46,910 --> 00:59:49,550
Seems sort of useless but
fairly straightforward.

1371
00:59:49,550 --> 00:59:50,100
OK.

1372
00:59:50,100 --> 00:59:51,390
Then I want to sign.

1373
00:59:51,390 --> 00:59:54,830
So first, to sign a
message, I'm going

1374
00:59:54,830 --> 00:59:57,220
to take the hash of
the message to sign.

1375
00:59:57,220 --> 00:59:58,940
And this is often done.

1376
00:59:58,940 --> 00:59:59,870
It's done in bitcoin.

1377
00:59:59,870 --> 01:00:02,870
It's done in most signature
schemes, where I want

1378
01:00:02,870 --> 01:00:05,780
a fixed length number to sign.

1379
01:00:05,780 --> 01:00:07,410
It's annoying to
have to say, well,

1380
01:00:07,410 --> 01:00:09,380
what if I want to sign
a megabyte long file,

1381
01:00:09,380 --> 01:00:13,145
or what if I want to sign
of 10-byte long string?

1382
01:00:13,145 --> 01:00:14,270
You want to standardize it.

1383
01:00:14,270 --> 01:00:18,950
So whatever I'm signing,
it's always 256 bits long.

1384
01:00:18,950 --> 01:00:22,100
So if I want to just sign
the message hi, first

1385
01:00:22,100 --> 01:00:25,460
I take the hash of the message
hi, which in Sha-256, this

1386
01:00:25,460 --> 01:00:29,180
is the hash of hi.

1387
01:00:29,180 --> 01:00:32,630
And so I look at this
as 256 bits, and I say,

1388
01:00:32,630 --> 01:00:35,510
OK, I'm going to pick the
private key blocks to reveal

1389
01:00:35,510 --> 01:00:37,740
based on the bits here.

1390
01:00:37,740 --> 01:00:44,550
So the first bit here is
a one, because it's an 8.

1391
01:00:44,550 --> 01:00:46,380
And so I'll reveal.

1392
01:00:46,380 --> 01:00:49,170
And I indicated
before that there's

1393
01:00:49,170 --> 01:00:52,080
this zero row and this one row.

1394
01:00:52,080 --> 01:00:54,990
And now what that means
is, well, the first bit

1395
01:00:54,990 --> 01:00:57,520
of my message to sign is a one.

1396
01:00:57,520 --> 01:01:00,750
So I'm going to reveal
this gray square.

1397
01:01:00,750 --> 01:01:03,970
And the next bit, the
next four bits, actually,

1398
01:01:03,970 --> 01:01:05,720
since it's an eight,
are going to be zero.

1399
01:01:05,720 --> 01:01:07,760
So I'll reveal
this and then I'll

1400
01:01:07,760 --> 01:01:11,030
reveal this, this, and this.

1401
01:01:11,030 --> 01:01:12,090
And I just made it up.

1402
01:01:12,090 --> 01:01:13,100
But yeah.

1403
01:01:13,100 --> 01:01:18,650
So for example, if I'm signing,
and it starts with 01101110,

1404
01:01:18,650 --> 01:01:21,200
I reveal this preimage, this
preimage, this preimage,

1405
01:01:21,200 --> 01:01:23,060
this preimage, these
three, this one.

1406
01:01:23,060 --> 01:01:27,710
And so I reveal preimages
based on the bit representation

1407
01:01:27,710 --> 01:01:32,230
of the message I'm
trying to sign, and then

1408
01:01:32,230 --> 01:01:34,060
give everyone these.

1409
01:01:34,060 --> 01:01:38,030
So my signature will
just be this sequence.

1410
01:01:38,030 --> 01:01:40,125
I can go in row order here.

1411
01:01:40,125 --> 01:01:41,500
Yeah, it's probably
a lot easier.

1412
01:01:41,500 --> 01:01:42,340
So I go in sequence.

1413
01:01:42,340 --> 01:01:44,997
I say, OK, here's the first
32 bytes of my signature.

1414
01:01:44,997 --> 01:01:47,080
Here's the next, here's
the next, here's the next.

1415
01:01:47,080 --> 01:01:51,970
And so my signature ends
up being 256 blocks long,

1416
01:01:51,970 --> 01:01:54,580
each of which are 256 bits.

1417
01:01:54,580 --> 01:01:56,850
So it's like 8K.

1418
01:01:56,850 --> 01:01:59,520
The keys are 16K and
this is 8K or something.

1419
01:01:59,520 --> 01:02:02,580
Fairly big but totally
doable on a computer today.

1420
01:02:02,580 --> 01:02:05,300
Eight kilobytes is no big deal.

1421
01:02:05,300 --> 01:02:05,800
OK.

1422
01:02:05,800 --> 01:02:10,500
Now to verify,
take the signature,

1423
01:02:10,500 --> 01:02:13,140
hash each block
of the signature,

1424
01:02:13,140 --> 01:02:16,290
and see that it maps into
that part of the public key.

1425
01:02:16,290 --> 01:02:18,327
So the people who are
verifying the signature,

1426
01:02:18,327 --> 01:02:19,410
they have your public key.

1427
01:02:19,410 --> 01:02:21,450
They have all the green squares.

1428
01:02:21,450 --> 01:02:23,730
And now they have been
given a signature, which

1429
01:02:23,730 --> 01:02:25,470
is these gray squares,
and they say, OK,

1430
01:02:25,470 --> 01:02:26,595
well, let me hash this one.

1431
01:02:26,595 --> 01:02:29,338
Oh, it maps to that,
so it maps to a zero.

1432
01:02:29,338 --> 01:02:31,130
Oh, this maps to a one,
this maps to a one,

1433
01:02:31,130 --> 01:02:32,430
this maps to a zero.

1434
01:02:32,430 --> 01:02:34,020
And they can go
through and say yeah,

1435
01:02:34,020 --> 01:02:38,513
this is a signature
on that message.

1436
01:02:38,513 --> 01:02:39,930
In the case of
Lamport signatures,

1437
01:02:39,930 --> 01:02:43,290
you can actually determine
what the message is just

1438
01:02:43,290 --> 01:02:46,932
from the signature
in the public key.

1439
01:02:46,932 --> 01:02:48,390
If you're given
this and you're not

1440
01:02:48,390 --> 01:02:51,690
told whether it's a one or
a zero, well, just compare.

1441
01:02:51,690 --> 01:02:54,420
Hash it and compare to
these two green ones.

1442
01:02:54,420 --> 01:02:57,270
You'll be able to see.

1443
01:02:57,270 --> 01:03:01,840
And that's a useful
signature because no one

1444
01:03:01,840 --> 01:03:04,870
can forge that
because no one knows

1445
01:03:04,870 --> 01:03:06,760
these preimages except
for the person who

1446
01:03:06,760 --> 01:03:09,120
holds the secret key.

1447
01:03:09,120 --> 01:03:12,180
So given your public key,
I can't forge a signature

1448
01:03:12,180 --> 01:03:13,560
from you.

1449
01:03:13,560 --> 01:03:17,130
Once the signature is issued,
I also can't forge a signature.

1450
01:03:17,130 --> 01:03:21,510
The only bit sequence I know
is the one that you revealed.

1451
01:03:21,510 --> 01:03:24,270
And so I know part
of your private key.

1452
01:03:24,270 --> 01:03:25,650
I know half of it.

1453
01:03:25,650 --> 01:03:31,170
But that half only lets me sign
the message you just signed.

1454
01:03:31,170 --> 01:03:34,110
So I can't really do
anything extra with this.

1455
01:03:34,110 --> 01:03:36,660
So this is a usable
signature scheme.

1456
01:03:39,480 --> 01:03:40,830
I think I just showed it.

1457
01:03:40,830 --> 01:03:44,146
But any downsides that you
can think of with this?

1458
01:03:44,146 --> 01:03:45,505
AUDIENCE: You can only sign one.

1459
01:03:45,505 --> 01:03:46,080
TADGE DRYJA: Yeah,
you can only sign one.

1460
01:03:46,080 --> 01:03:47,111
Is that what you were--

1461
01:03:47,111 --> 01:03:49,028
AUDIENCE: You could also
send the same message

1462
01:03:49,028 --> 01:03:51,540
on to someone else with
different signatures.

1463
01:03:51,540 --> 01:03:54,350
TADGE DRYJA: Yeah, but
signatures are sort of public.

1464
01:03:54,350 --> 01:03:56,670
So yes, you're
saying that you can

1465
01:03:56,670 --> 01:04:00,690
sign a message once and give
it to a bunch of people.

1466
01:04:00,690 --> 01:04:02,880
And that's sort of a
feature, not a bug, I guess.

1467
01:04:02,880 --> 01:04:05,760
There are different signature
schemes where you want,

1468
01:04:05,760 --> 01:04:09,785
I only want this signature
to be valid to this person.

1469
01:04:09,785 --> 01:04:11,160
There's different
ways to do that

1470
01:04:11,160 --> 01:04:12,952
with Diffie-Hellman
key exchange and stuff.

1471
01:04:12,952 --> 01:04:15,770
But the signature scheme
we've talked about here

1472
01:04:15,770 --> 01:04:18,270
with these three functions, the
public key is really public,

1473
01:04:18,270 --> 01:04:19,740
and anyone can verify.

1474
01:04:19,740 --> 01:04:21,810
And that's something we want.

1475
01:04:21,810 --> 01:04:24,360
If you don't want that,
there's other ways to do it.

1476
01:04:24,360 --> 01:04:29,190
But yeah, the big one is,
wait, you can only sign once.

1477
01:04:29,190 --> 01:04:32,070
Once you generate a key
pair, your private key,

1478
01:04:32,070 --> 01:04:34,680
your public key, and you tell
everyone these green squares,

1479
01:04:34,680 --> 01:04:40,050
if you're try to sign again,
you will reveal more pieces

1480
01:04:40,050 --> 01:04:42,060
of your private key.

1481
01:04:42,060 --> 01:04:43,850
So if I sign two
different messages,

1482
01:04:43,850 --> 01:04:45,960
sometimes it's the same bit.

1483
01:04:45,960 --> 01:04:47,340
Sometimes it's different bits.

1484
01:04:47,340 --> 01:04:51,220
And now I start revealing
more pieces of my private key.

1485
01:04:51,220 --> 01:04:53,430
And now people can start
to forge signatures

1486
01:04:53,430 --> 01:04:58,500
because I can say, OK,
well, the first bit,

1487
01:04:58,500 --> 01:05:00,660
I can sign anything
on the first bit.

1488
01:05:00,660 --> 01:05:04,980
I'm still constrained
here and here and here.

1489
01:05:04,980 --> 01:05:11,470
But in several locations, I
can sign whichever bit I want.

1490
01:05:11,470 --> 01:05:15,750
And so the basic thing is,
if there's one signature,

1491
01:05:15,750 --> 01:05:16,920
I can't forge anything.

1492
01:05:16,920 --> 01:05:20,400
If you give me two signatures,
since it's generally random,

1493
01:05:20,400 --> 01:05:22,860
on average, half of the
bits of the signature

1494
01:05:22,860 --> 01:05:23,700
will be constrained.

1495
01:05:23,700 --> 01:05:27,240
So in this case, if it's 256
bits long and you sign twice,

1496
01:05:27,240 --> 01:05:32,670
I probably still can't forge
anything because 128 bits,

1497
01:05:32,670 --> 01:05:34,510
I have the freedom
to pick either.

1498
01:05:34,510 --> 01:05:39,810
And the other 128 bits, I'm
stuck with the one or the zero

1499
01:05:39,810 --> 01:05:41,160
and I don't get to choose.

1500
01:05:41,160 --> 01:05:45,060
So that means most
messages I want to sign,

1501
01:05:45,060 --> 01:05:50,100
I won't be able to because if I
tried two to the 128 attempts,

1502
01:05:50,100 --> 01:05:52,480
I'll be able to find
a forged signature.

1503
01:05:52,480 --> 01:05:53,550
But that's a lot.

1504
01:05:53,550 --> 01:05:55,830
And so maybe you can sign twice.

1505
01:05:55,830 --> 01:05:57,450
But again, it's probabilistic.

1506
01:05:57,450 --> 01:06:00,390
You might get unlucky
and reveal quite a bit

1507
01:06:00,390 --> 01:06:05,010
more than 128 bits,
where you get both.

1508
01:06:05,010 --> 01:06:08,790
But on average-- and then once
you have three signatures, OK,

1509
01:06:08,790 --> 01:06:14,320
now I've probably revealed
3/4 of the locations

1510
01:06:14,320 --> 01:06:16,540
you're going to have both
the one and zero row.

1511
01:06:16,540 --> 01:06:18,250
And you can start--
and this starts

1512
01:06:18,250 --> 01:06:23,140
to be practical
because in this case,

1513
01:06:23,140 --> 01:06:27,280
you'd need a 2 two the 64
attempts to forge a signature.

1514
01:06:27,280 --> 01:06:31,250
And that's doable on
today's computers.
