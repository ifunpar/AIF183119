1
00:00:00,090 --> 00:00:02,500
Konten berikut diberikan
di bawah lisensi

2
00:00:02,500 --> 00:00:04,019
Creative Commons.

3
00:00:04,019 --> 00:00:06,360
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,360 --> 00:00:10,730
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,730 --> 00:00:13,330
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:13,330 --> 00:00:17,236
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:17,236 --> 00:00:17,861
di ocw.mit.edu.

8
00:00:21,222 --> 00:00:23,180
SRINIVAS DEVADAS: Baiklah,
mari kita mulai.

9
00:00:23,180 --> 00:00:24,740
Selamat pagi semuanya.

10
00:00:24,740 --> 00:00:28,210
Saya melihat banyak wajah letih.

11
00:00:28,210 --> 00:00:29,030
Saya tidak letih.

12
00:00:29,030 --> 00:00:29,930
Mengapa kalian letih?

13
00:00:29,930 --> 00:00:30,894
[TERTAWA]

14
00:00:31,860 --> 00:00:33,130
Saya hanya mengajar paruh waktu.

15
00:00:33,130 --> 00:00:36,240
Kalian semua mengambil
kelas penuh waktu.

16
00:00:36,240 --> 00:00:41,640
Jadi kuliah hari ini adalah
tentang fungsi hash.

17
00:00:41,640 --> 00:00:45,680
Dan Anda mungkin tahu banyak
tentang fungsi hash,

18
00:00:45,680 --> 00:00:47,860
dan mungkin memang demikian.

19
00:00:47,860 --> 00:00:50,840
Tapi yang akan kita lakukan hari
ini adalah membicarakan tentang

20
00:00:50,840 --> 00:00:54,990
aplikasi fungsi hash yang
sangat berbeda,

21
00:00:54,990 --> 00:00:57,700
dan properti-properti baru
di mana kita

22
00:00:57,700 --> 00:01:00,190
akan membutuhkan
fungsi hash yang

23
00:01:00,190 --> 00:01:01,900
akan saya elaborasi lebih lanjut.

24
00:01:01,900 --> 00:01:04,459
Dan kita akan melihat
bermacam-macam aplikasi 

25
00:01:04,459 --> 00:01:06,700
untuk melindungi
password,

26
00:01:06,700 --> 00:01:10,220
memeriksa integritas
file-file, lelang,

27
00:01:10,220 --> 00:01:11,316
dan lain-lain.

28
00:01:11,316 --> 00:01:12,940
Jadi ini akan merupakan
kuliah yang sedikit berbeda.

29
00:01:12,940 --> 00:01:15,692
Hari ini dan Kamis
saya akan

30
00:01:15,692 --> 00:01:18,320
membahas kriptografi
dan aplikasinya,

31
00:01:18,320 --> 00:01:20,380
tidak terlalu banyak algoritme.

32
00:01:20,380 --> 00:01:22,960
Tetapi kita akan melakukan sedikit
analisis yang berkaitan

33
00:01:22,960 --> 00:01:25,390
dengan apakah properti-
propertinya dipenuhi

34
00:01:25,390 --> 00:01:28,010
dalam kasus ini oleh
fungsi hash atau tidak.

35
00:01:28,010 --> 00:01:29,910
Karena itu mari kita mulai melihatnya.

36
00:01:29,910 --> 00:01:33,240
Anda semua tahu
fungsi hash itu apa.

37
00:01:33,240 --> 00:01:37,380
Tidak ada perubahan berarti
pada definisinya.

38
00:01:37,380 --> 00:01:39,370
Tetapi jenis fungsi hash
yang akan kita

39
00:01:39,370 --> 00:01:41,960
lihat hari ini sedikit
berbeda

40
00:01:41,960 --> 00:01:45,590
dari fungsi hash sederhana,
seperti mengambil sisa pembagian

41
00:01:45,590 --> 00:01:49,950
dengan bilangan prima
yang sudah kita lihat sebelumnya.

42
00:01:49,950 --> 00:01:51,680
Dan istilah "collisions"
(tabrakan) akan

43
00:01:51,680 --> 00:01:53,980
muncul lagi,
kecuali bahwa kita

44
00:01:53,980 --> 00:01:56,600
akan meningkatkan
pertaruhannya nya sedikit.

45
00:01:56,600 --> 00:02:04,100
Jadi sebuah fungsi hash
memetakan

46
00:02:04,100 --> 00:02:08,539
string acak-- Saya perbaiki dulu.

47
00:02:11,940 --> 00:02:15,645
Jadi Anda tidak membuat pernyataan
tentang panjang string.

48
00:02:18,440 --> 00:02:23,490
Anda akan akan memecahnya, bahkan jika
Anda memiliki string dengan panjang 512,

49
00:02:23,490 --> 00:02:28,830
atau mungkin panjangnya 27, Anda
ingin mendapatkan sebuah bilangan darinya.

50
00:02:28,830 --> 00:02:31,540
Dalam rentang
spesifik yang

51
00:02:31,540 --> 00:02:34,190
merupakan sebuah kumpulan
bit-bit yang terasosiasi

52
00:02:34,190 --> 00:02:35,346
dengan fungsi hash kita.

53
00:02:35,346 --> 00:02:36,970
Dan sebelumnya kita
memiliki slot-slot

54
00:02:36,970 --> 00:02:39,620
yang terasosiasi dengan keluaran
dari fungsi hash.

55
00:02:39,620 --> 00:02:42,100
Tetapi masukannya
bisa bermacam-macam.

56
00:02:42,100 --> 00:02:48,080
Dan data dalam
bentuk string ini

57
00:02:48,080 --> 00:02:50,310
akan dipetakan, seperti yang
saya katakan barusan,

58
00:02:50,310 --> 00:02:53,190
ke dalam keluaran yang panjangnya konstan.

59
00:02:56,282 --> 00:02:57,990
Dan kita akan berpikir
tentang panjang

60
00:02:57,990 --> 00:03:01,590
yang konstan ini sebagai
jumlah bit,

61
00:03:01,590 --> 00:03:04,530
sebagai pengganti dari slot-slot
pada tabel hash.

62
00:03:04,530 --> 00:03:08,170
Karena kita tidak akan
benar-benar menyimpan

63
00:03:08,170 --> 00:03:10,520
kamus atau tabel hash
di dalam aplikasi

64
00:03:10,520 --> 00:03:11,780
yang akan kita lihat hari ini.

65
00:03:11,780 --> 00:03:14,750
Ini sekedar pertanyaan
soal menghitung sebuah hash.

66
00:03:14,750 --> 00:03:18,120
Dan karena panjang
keluarannya

67
00:03:18,120 --> 00:03:23,880
akan berkisar antara orde
160-bit atau 256-bit,

68
00:03:23,880 --> 00:03:26,980
tidak mungkin Anda dapat
menyimpan dua array

69
00:03:26,980 --> 00:03:33,370
ke 160 elemen pada tabel hash,
atau bahkan dua array ke 64

70
00:03:33,370 --> 00:03:34,340
begitu.

71
00:03:34,340 --> 00:03:37,120
Jadi kita hanya akan
mengasumsikan

72
00:03:37,120 --> 00:03:41,880
bahwa kita menghitung
hash-hash ini

73
00:03:41,880 --> 00:03:45,960
dan menggunakannya untuk
aplikasi tertentu.

74
00:03:45,960 --> 00:03:48,800
Saya baru saja menulis keluarannya
dua kali sepertinya.

75
00:03:48,800 --> 00:03:52,720
Jadi petakan ke
keluaran dengan panjang konstan.

76
00:03:52,720 --> 00:03:58,990
Kita ingin melakukannya
dengan cara yang deterministik.

77
00:03:58,990 --> 00:04:04,430
Jadi setelah kita menghitung
hash dari sebuah

78
00:04:04,430 --> 00:04:07,960
string acak yang
diberikan ke kita, kita ingin

79
00:04:07,960 --> 00:04:10,150
bisa mengulang proses
tersebut untuk mendapatkan

80
00:04:10,150 --> 00:04:13,090
hash yang sama setiap kali.

81
00:04:13,090 --> 00:04:15,070
Kita ingin melakukannya
secara publik.

82
00:04:15,070 --> 00:04:16,170
Jadi semuanya ini publik.

83
00:04:16,170 --> 00:04:17,420
Tidak ada yang dirahasiakan.

84
00:04:17,420 --> 00:04:19,920
Ada fungsi hash berkunci
yang tidak akan

85
00:04:19,920 --> 00:04:22,210
kita lihat hari ini,
tetapi mungkin saat melewatinya

86
00:04:22,210 --> 00:04:24,500
Saya akan menyebutkannya di lain waktu.

87
00:04:24,500 --> 00:04:26,700
Kita tidak akan melihat fungsi hash
berkunci hari ini.

88
00:04:26,700 --> 00:04:30,920
Tidak ada rahasia dalam
deskripsi algoritme

89
00:04:30,920 --> 00:04:34,540
atau teknik yang akan
saya jelaskan hari ini.

90
00:04:34,540 --> 00:04:37,720
Dan kita ingin ini acak.

91
00:04:37,720 --> 00:04:39,870
Kita ingin ini terlihat acak.

92
00:04:39,870 --> 00:04:43,750
Keacakan sejati akan sulit
untuk dicapai,

93
00:04:43,750 --> 00:04:45,142
dengan batasan yang kita miliki.

94
00:04:45,142 --> 00:04:46,850
Tapi kita akan mencoba
dan mengaproksimasinya.

95
00:04:46,850 --> 00:04:48,880
dengan acak-semu (pseudo-randomness).

96
00:04:48,880 --> 00:04:51,040
Tetapi kita ingin
itu terlihat acak, karena kita

97
00:04:51,040 --> 00:04:55,210
tertarik-- sama seperti
dalam kasus kamus

98
00:04:55,210 --> 00:04:58,030
dan aplikasi reguler
dari fungsi hash-- kita

99
00:04:58,030 --> 00:05:00,870
tertarik dalam
meniminalisasi tabrakan.

100
00:05:00,870 --> 00:05:03,570
Dan sebenarnya kita akan
menaikkan per taruhannya sangat tinggi

101
00:05:03,570 --> 00:05:05,470
berkaitan dengan tabrakan.

102
00:05:05,470 --> 00:05:09,870
Kita ingin supaya mustahil
bagi Anda, atau bagi yang lain,

103
00:05:09,870 --> 00:05:12,210
untuk menemukan tabrakan.

104
00:05:12,210 --> 00:05:15,150
Dan itu akan menjadi properti
yang penting tentang collision

105
00:05:15,150 --> 00:05:20,520
resistance (anti-tabrakan) yang tentu
saja membutuhkan sifat acak.

106
00:05:20,520 --> 00:05:24,220
Dan itu adalah
ketiga hal yang kita inginkan:

107
00:05:24,220 --> 00:05:26,840
deterministik, publik,
dan acak.

108
00:05:26,840 --> 00:05:32,870
Jadi dari sudut pandang
deskripsi fungsi

109
00:05:32,870 --> 00:05:35,800
Anda punya 0, 1 bintang di sini,
yang mengimplikasikan bahwa itu

110
00:05:35,800 --> 00:05:37,770
adalah panjang kekuatan yang bisa bervariasi.

111
00:05:37,770 --> 00:05:41,830
Dan kita ingin 0, 1, d.

112
00:05:41,830 --> 00:05:43,955
Dan ini adalah
string dengan panjang d.

113
00:05:49,170 --> 00:05:51,250
Jadi ini berarti bahwa Anda
akan mendapatkan d-bits keluar

114
00:05:51,250 --> 00:05:52,650
dari fungsi hash Anda.

115
00:05:52,650 --> 00:05:56,630
Dan di sini panjangnya
lebih besar atau sama dengan 0.

116
00:06:00,360 --> 00:06:01,750
Begitu.

117
00:06:01,750 --> 00:06:05,000
Tidak ada yang baru di sini.

118
00:06:05,000 --> 00:06:08,880
Tapi ada beberapa hal yang akan
sedikit berbeda.

119
00:06:08,880 --> 00:06:11,630
Dan ada beberapa kerumitan
di sini yang akan kita bahas.

120
00:06:11,630 --> 00:06:18,600
Saya ingin menggaris bawahi dua hal,
satunya yang baru saja saya katakan.

121
00:06:18,600 --> 00:06:23,570
Tidak ada rahasia, tidak ada
kunci rahasia di sini di fungsi hash

122
00:06:23,570 --> 00:06:25,350
yang akan kita deskripsikan.

123
00:06:25,350 --> 00:06:27,250
Seluruh operasi sifatnya publik.

124
00:06:27,250 --> 00:06:33,330
Jadi seperti fungsi
hash Anda, yaitu k mod p

125
00:06:33,330 --> 00:06:38,220
dan p adalah bilangan prima dan
p publik dan diketahui semua pihak

126
00:06:38,220 --> 00:06:40,600
yang menggunakan kamus,
semuanya

127
00:06:40,600 --> 00:06:42,570
yang akan kita bicarakan
adalah publik.

128
00:06:42,570 --> 00:06:44,680
Sehingga siapapun dapat menghitung h.

129
00:06:51,942 --> 00:06:53,400
Dan kita akan mengasumsikan
bahwa ini

130
00:06:53,400 --> 00:06:57,310
adalah komputasi dengan waktu polinomial--
tidak terlalu mengejutkan-- tetapi saya

131
00:06:57,310 --> 00:07:01,700
fleksibel di sini.

132
00:07:01,700 --> 00:07:03,720
Saat Anda melihat kamus,
dan Anda

133
00:07:03,720 --> 00:07:07,140
berpikir tentang menggunakan kamus,
dan menggunakannya untuk mengimplementasikan

134
00:07:07,140 --> 00:07:10,540
algoritme yang efisien,
apa asumsi

135
00:07:10,540 --> 00:07:13,690
yang kita buat secara implisit--
atau mungkin secara eksplisit

136
00:07:13,690 --> 00:07:18,810
di kasus-kasus tertentu-- berkaitan
dengan menghitung hash?

137
00:07:18,810 --> 00:07:19,310
Siapapun?

138
00:07:22,210 --> 00:07:22,710
Ya?

139
00:07:22,710 --> 00:07:23,690
AUDIENS: Waktu yang konstan?

140
00:07:23,690 --> 00:07:25,023
SRINIVAS DEVADAS: Waktu konstan.

141
00:07:25,023 --> 00:07:33,680
Kita asumsikan-- jadi ini tidak
selalu orde 1, ya kan?

142
00:07:33,680 --> 00:07:34,840
Jadi itu penting.

143
00:07:34,840 --> 00:07:42,180
Kita akan-- Saya ingin
memastikan Anda semua menyaksikan.

144
00:07:42,180 --> 00:07:45,770

145
00:07:45,770 --> 00:07:47,990
kompleksitas hash nya.

146
00:07:47,990 --> 00:07:50,459
Dan seperti yang akan Anda lihat,
karena properti yang diinginkan,

147
00:07:50,459 --> 00:07:51,750
kita akan melakukan hal tersebut.

148
00:07:51,750 --> 00:07:54,010
Kita akan meminta banyak hal
berkaitan dengan

149
00:07:54,010 --> 00:07:55,610
fungsi-fungsi hash ini.

150
00:07:55,610 --> 00:07:58,350
Tidak siapapun dapat
menemukan tabrakan, ya kan?

151
00:07:58,350 --> 00:08:01,750
Dan jika Anda punya sesuatu
sesederhana k mod p,

152
00:08:01,750 --> 00:08:03,910
akan sangat mudah untuk
menemukan tabrakan.

153
00:08:03,910 --> 00:08:06,710
Maka fungsi hash
orde 1 ini

154
00:08:06,710 --> 00:08:08,380
yang Anda sudah
kenal tidak akan

155
00:08:08,380 --> 00:08:12,160
mendapatkan nilai berkaitan
dengan properti manapun

156
00:08:12,160 --> 00:08:14,500
dari yang akan kita bahas
sebentar lagi.

157
00:08:14,500 --> 00:08:16,962
Baik, jadi ingatlah bahwa ini
adalah komputasi dengan waktu polinomial

158
00:08:16,962 --> 00:08:19,170
Dan ada banyak contoh
dari fungsi hash ini

159
00:08:19,170 --> 00:08:21,820
Dan untuk kalian yang
tertarik ke bidang keamanan komputer

160
00:08:21,820 --> 00:08:24,890
dan kriptografi,
kalian mungkin sudah pernah dengar

161
00:08:24,890 --> 00:08:29,240
tentang MD4 dan MD5 misalnya.

162
00:08:29,240 --> 00:08:30,260
Ini adalah versi-versi.

163
00:08:30,260 --> 00:08:32,309
MD singkatan dari Message Digest.

164
00:08:32,309 --> 00:08:35,610
Ini merupakan fungsi yang
diciptakan oleh Profesor Rivest.

165
00:08:35,610 --> 00:08:42,970
Dan mereka memiliki d sama dengan
128 saat itu-- 1992,

166
00:08:42,970 --> 00:08:45,830
seingat saya-- ketika
mereka pertama kali diusulkan.

167
00:08:45,830 --> 00:08:50,830
Dan algoritma-algoritma ini telah
rusak sejak itu dalam arti

168
00:08:50,830 --> 00:08:53,490
telah diduga bahwa
mereka mempunyai properti tertentu

169
00:08:53,490 --> 00:08:59,060
mengenai ketahanan terhadap kesamaan (collision resistance) yang
membutuhkan waktu eksponensial

170
00:08:59,060 --> 00:09:01,660
bagi siapapun untuk menemukan collision.

171
00:09:01,660 --> 00:09:04,490
Dan membutuhkan waktu
masih eksponensial,

172
00:09:04,490 --> 00:09:11,040
tapi 2 pangkat 37 adalah
eksponensial pada tingkatan tertentu,

173
00:09:11,040 --> 00:09:13,700
tapi konstan pada tingkatan yang lain.

174
00:09:13,700 --> 00:09:17,720
Jadi Anda dapat melakukannya
dalam beberapa detik sekarang.

175
00:09:17,720 --> 00:09:20,610
Jadi sedikit sejarah.

176
00:09:20,610 --> 00:09:23,300
Saya tidak akan menghabiskan
banyak waktu mengenai hal ini.

177
00:09:23,300 --> 00:09:28,400
MD5 digunakan untuk menciptakan apa yang
disebut sebuah algoritma hash yang aman.

178
00:09:28,400 --> 00:09:31,770
Ini adalah 160-bit.

179
00:09:31,770 --> 00:09:36,330
Dan belum cukup 
rusak (tidak aman) saat ini.

180
00:09:36,330 --> 00:09:41,920
Tapi orang-orang menganggapnya
rusak, atau akan segera rusak.

181
00:09:41,920 --> 00:09:45,560
Sekarang, algoritme
yang direkomendasikan

182
00:09:45,560 --> 00:09:50,260
disebut SHA-3, secure hash
algorithm versi tiga.

183
00:09:50,260 --> 00:09:53,870
Dan ada sebuah kontes
yang berlangsung selama 18 bulan,

184
00:09:53,870 --> 00:09:56,770
atau mungkin bahkan lebih lama,
yang pada akhirnya dimenangkan

185
00:09:56,770 --> 00:09:59,580
oleh sesuatu yang sekarang menjadi SHA-3.

186
00:09:59,580 --> 00:10:03,200
Dan mereka mempunyai nama yang berbeda
untuknya yang tidak saya ingat.

187
00:10:03,200 --> 00:10:05,180
Tapi itu berubah menjadi SHA-3.

188
00:10:05,180 --> 00:10:08,220
Dan apa yang terjadi sepanjang 
jalan, saat kita berganti dari MD4,

189
00:10:08,220 --> 00:10:12,690
MD5, SHA-1 ke SHA-3, adalah
jumlah komputasi

190
00:10:12,690 --> 00:10:14,810
yang harus Anda lakukan meningkat.

191
00:10:14,810 --> 00:10:16,570
Dan kompleksitas dari
operasi yang Anda

192
00:10:16,570 --> 00:10:21,690
harus lakukan untuk menghitung
hash dari sebuah string acak

193
00:10:21,690 --> 00:10:24,460
meningkat sampai ke
suatu titik dimana-- Anda

194
00:10:24,460 --> 00:10:27,720
akan berpikir ini adalah
100 ronde komputasi.

195
00:10:27,720 --> 00:10:31,780
Dan tentunya 
komputasi orde d,

196
00:10:31,780 --> 00:10:34,200
di mana d adalah jumlah bit.

197
00:10:34,200 --> 00:10:35,940
Dan bahkan mungkin lebih.

198
00:10:35,940 --> 00:10:38,850
Jadi sudah pasti bukan orde 1.

199
00:10:38,850 --> 00:10:43,270
Jadi seperti yang saya katakan sedikit
tentang konteks

200
00:10:43,270 --> 00:10:45,355
terhadap hal-hal yang
ada di luar sana.

201
00:10:45,355 --> 00:10:46,980
Pada akhir perkuliahan
saya akan memberikan kalian

202
00:10:46,980 --> 00:10:49,570
gambaran tentang bagaimana
fungsi hash ini dibuat.

203
00:10:49,570 --> 00:10:51,380
Kita tidak akan
menghabiskan banyak waktu

204
00:10:51,380 --> 00:10:53,220
untuk membuat
fungsi hash ini.

205
00:10:53,220 --> 00:10:56,320
Ini sesungguhnya sebuah topik penelitian
tersendiri dan bukan 

206
00:10:56,320 --> 00:10:58,390
dalam cakupan 6.046.

207
00:10:58,390 --> 00:11:00,920
Apa yang ada dalam cakupan
6.046, dan apa

208
00:11:00,920 --> 00:11:02,510
yang saya rasa lebih
menarik, itulah

209
00:11:02,510 --> 00:11:05,690
hal yang akan kita berikan fokus
dengan usaha dan waktu kita,

210
00:11:05,690 --> 00:11:07,990
adalah properti dari
fungsi-fungsi hash ini.

211
00:11:07,990 --> 00:11:10,640
Dan mengapa properti ini
bermanfaat dalam berbagai

212
00:11:10,640 --> 00:11:12,270
aplikasi yang berbeda.

213
00:11:12,270 --> 00:11:15,100
Jadi apa yang kita inginkan?

214
00:11:15,100 --> 00:11:19,440
Kita ingin sebuah pembangkit nilai acak.

215
00:11:19,440 --> 00:11:23,790
Kita pada dasarnya ingin
membangun sesuatu

216
00:11:23,790 --> 00:11:27,960
yang terlihat seperti itu,
deterministik, publik, acak.

217
00:11:27,960 --> 00:11:31,390
Dan kita akan 
mengklaim bahwa hal yang kita inginkan

218
00:11:31,390 --> 00:11:33,135
adalah sebuah
pembangkit nilai acak yang memiliki semua

219
00:11:33,135 --> 00:11:35,892
properti mengagumkan
yang akan saya deskripsikan.

220
00:11:35,892 --> 00:11:37,850
Saya akan mendeskripsikan
pembangkit nilai acak tersebut kepada Anda,

221
00:11:37,850 --> 00:11:40,391
lalu saya akan memberitahu Anda
apa saja properti-propertinya.

222
00:11:40,391 --> 00:11:44,420
Dan sayangnya,
ini adalah dunia yang ideal

223
00:11:44,420 --> 00:11:47,890
dan kita tidak dapat membangun
hal ini di dunia nyata.

224
00:11:47,890 --> 00:11:49,919
Jadi kita akan
harus memperkirakannya.

225
00:11:49,919 --> 00:11:52,460
Dan di situlah di mana MD4,
MD5, dan SHA-1 berfungsi,

226
00:11:52,460 --> 00:11:55,200
OK?

227
00:11:55,200 --> 00:11:56,885
Jadi ini tidak dapat
dicapai secara praktis.

228
00:12:05,560 --> 00:12:09,300
Jadi apa pembangkit nilai ini?

229
00:12:09,300 --> 00:12:17,170
Pembangkit nilai ini menerima input
x, dimiliki oleh 0,1 bintang.

230
00:12:17,170 --> 00:12:20,740
Jadi hal tersebut bisa merupakan
sebuah string acak.

231
00:12:20,740 --> 00:12:26,100
Jika x tidak ada di buku--
jadi ada sebuah buku ini,

232
00:12:26,100 --> 00:12:26,840
oke?

233
00:12:26,840 --> 00:12:29,720
Dan ada sebuah buku ini
dengan kapasitas tak terhingga

234
00:12:29,720 --> 00:12:35,170
yang berisi semua komputasi
yang pernah dilakukan sebelumnya.

235
00:12:35,170 --> 00:12:36,770
Dan komputasi-komputasi itu selalu 
disimpan di buku tersebut.

236
00:12:36,770 --> 00:12:38,770
Dan itulah bagaimana kita akan
mendapatkan determinisme.

237
00:12:38,770 --> 00:12:42,100
Karena buku ini
sudah terisi dari awal.

238
00:12:42,100 --> 00:12:44,380
Semua catatan di dalam 
buku tersebut dipenuhi

239
00:12:44,380 --> 00:12:47,000
dengan menggunakan keacakan murni.

240
00:12:47,000 --> 00:12:55,610
Jadi Anda melempar koin sebanyak d
kali untuk menentukan h dari x.

241
00:12:55,610 --> 00:12:57,760
Jadi pada dasarnya begitu saja.

242
00:12:57,760 --> 00:12:59,420
Dan Anda terus-menerus melempar koinnya.

243
00:12:59,420 --> 00:13:00,950
Anda harus melempar sebanyak d kali.

244
00:13:00,950 --> 00:13:05,320
Jadi jika x adalah 0, Anda
melempar koinnya sebanyak d kali, d adalah 160.

245
00:13:05,320 --> 00:13:08,300
Anda melempar koin 160
kali dan mendapatkan sebuah string.

246
00:13:08,300 --> 00:13:13,430
Jika x adalah 1, lempar 160 kali,
Anda mendapatkan string yang berbeda

247
00:13:13,430 --> 00:13:15,530
dengan kemungkinan
yang sangat tinggi, jelas.

248
00:13:15,530 --> 00:13:16,890
Dan seterusnya.

249
00:13:16,890 --> 00:13:19,280
Tapi hal yang Anda lakukan adalah
Anda mempunyai buku ini.

250
00:13:19,280 --> 00:13:29,870
Jadi Anda akan mencatat
x h dari x di dalam buku tersebut, OK?

251
00:13:29,870 --> 00:13:31,770
Jadi pada tingkat tertentu
fungsi hash Anda

252
00:13:31,770 --> 00:13:35,220
merupakan tabel pencari raksasa
di langit, benar?

253
00:13:35,220 --> 00:13:37,480
Sebenarnya bukan raksasa, tapi
tabel pencari dengan kapasitas tak terhingga

254
00:13:37,480 --> 00:13:38,510
di langit.

255
00:13:38,510 --> 00:13:42,230
Karena Anda bisa menaruh
string-string acak ke dalamnya.

256
00:13:42,230 --> 00:13:47,910
Dan jika itu ada di buku tersebut-- 
jelas ini adalah bagian penting

257
00:13:47,910 --> 00:13:52,740
yang memberikan Anda determinisme--
maka Anda keluarkan y,

258
00:13:52,740 --> 00:13:58,700
di mana x dan y ada 
di dalam buku tersebut, OK?

259
00:14:01,350 --> 00:14:05,040
Jadi Anda mendapatkan sebuah
jawaban acak setiap kali,

260
00:14:05,040 --> 00:14:08,380
kecuali sesuai yang dibutuhkan
untuk konsistensi

261
00:14:08,380 --> 00:14:10,180
dengan jawaban-jawaban sebelumnya.

262
00:14:10,180 --> 00:14:11,930
Jadi, pertama kali
Anda melihat sebuah string,

263
00:14:11,930 --> 00:14:16,730
atau-- dan seluruh dunia
dapat membuat buku ini.

264
00:14:16,730 --> 00:14:17,740
Ini publik.

265
00:14:17,740 --> 00:14:22,430
Jadi, jika saya membuat buku tersebut saat
pertama kali dengan sebuah string tertentu,

266
00:14:22,430 --> 00:14:23,710
katakanlah Eric.

267
00:14:23,710 --> 00:14:25,120
Saya adalah string tersebut.

268
00:14:25,120 --> 00:14:29,960
Dan saya adalah orang yang menaruh
masukan tersebut-- x sama dengan Eric

269
00:14:29,960 --> 00:14:34,040
dan h dari x, h dari Eric sama dengan
suatu 160-bit string acak--

270
00:14:34,040 --> 00:14:36,640
ke dalam buku tersebut, saya mendapatkan
penghargaan untuk hal itu, benar?

271
00:14:36,640 --> 00:14:43,650
Tetapi jika Anda datang satu nanodetik
kemudian dan meminta h dari Eric,

272
00:14:43,650 --> 00:14:46,090
Anda seharusnya mendapatkan tepat
apa yang telah ditaruh ke dalam buku tersebut

273
00:14:46,090 --> 00:14:49,850
ketika saya meminta h dari Eric.

274
00:14:49,850 --> 00:14:51,290
Dan seterusnya.

275
00:14:51,290 --> 00:14:53,050
Jadi ini benar untuk semua orang.

276
00:14:53,050 --> 00:14:56,810
Jadi ini seperti-- maksud saya
pada dasarnya mustahil untuk didapatkan.

277
00:14:56,810 --> 00:15:01,770
Karena tidak hanya 
setiap orang dan semua orang bertanya,

278
00:15:01,770 --> 00:15:05,190
Anda harus membuat
urutan ini terasosiasikan

279
00:15:05,190 --> 00:15:09,450
dengan orang-orang yang bertanya ke buku tersebut.

280
00:15:09,450 --> 00:15:11,330
Dan Anda harus
mempunyai konsistensi.

281
00:15:11,330 --> 00:15:11,990
Baik.

282
00:15:11,990 --> 00:15:15,990
Jadi semua orang sudah yakin
bahwa kita tidak dapat membangun ini?

283
00:15:15,990 --> 00:15:16,710
Baik.

284
00:15:16,710 --> 00:15:18,660
Jika Anda mendapatkan apapun
dari perkuliahan ini,

285
00:15:18,660 --> 00:15:20,011
hal itu yang seharusnya Anda dapatkan.

286
00:15:20,011 --> 00:15:20,510
Tidak, tidak.

287
00:15:20,510 --> 00:15:22,290
Ada lebih banyak hal.

288
00:15:22,290 --> 00:15:26,750
Jadi kita ingin memperkirakan
pembangkit nilai acak tersebut.

289
00:15:26,750 --> 00:15:28,840
Dan kita akan membahas hal itu.

290
00:15:28,840 --> 00:15:34,767
Jelas bahwa kita harus melakukan ini
dalam ruang polinomial juga.

291
00:15:34,767 --> 00:15:35,850
Jadi apa yang salah dengan hal ini?

292
00:15:35,850 --> 00:15:38,810
Tentu saja gambaran ini 
Saya tidak benar-benar mengatakan ini,

293
00:15:38,810 --> 00:15:42,320
tetapi Anda ingin hal-hal menjadi
waktu polinomial dalam hal ruang.

294
00:15:42,320 --> 00:15:46,210
Anda tidak ingin menyimpan
angka tak terhingga-- hal ini 

295
00:15:46,210 --> 00:15:48,649
lebih buruk dari waktu polinomial,
lebih buruk dari waktu eksponensial,

296
00:15:48,649 --> 00:15:51,190
karena ini string-string acak
yang sedang kita bicarakan di sini,

297
00:15:51,190 --> 00:15:51,920
benar?

298
00:15:51,920 --> 00:15:53,940
Jadi Anda tidak mungkin melakukan itu.

299
00:15:53,940 --> 00:15:56,350
Jadi kita harus melakukan
sesuatu yang lebih baik.

300
00:15:56,350 --> 00:16:00,180
Tapi sebelum saya masuk ke bagaimana sebenarnya kita
akan membangun ini, dan memberikan 

301
00:16:00,180 --> 00:16:04,346
Anda gambaran tentang bagaimana SHA-1 
dan MD5 dibangun--

302
00:16:04,346 --> 00:16:06,220
dan itu akan kita
bahas nanti--

303
00:16:06,220 --> 00:16:11,910
Saya ingin menghabiskan banyak waktu
pada hal yang menarik,

304
00:16:11,910 --> 00:16:13,630
yaitu properti-properti
yang diinginkan.

305
00:16:13,630 --> 00:16:16,640
Yang dapat Anda lihat dengan
menggunakan pembangkit nilai acak.

306
00:16:16,640 --> 00:16:18,690
Jadi hal yang mengagumkan tentang
pembangkit nilai acak adalah

307
00:16:18,690 --> 00:16:21,140
itu merupakan algoritme yang sederhana.

308
00:16:21,140 --> 00:16:23,060
Anda dapat memahaminya.

309
00:16:23,060 --> 00:16:24,410
Anda tidak dapat mengimplementasikannya.

310
00:16:24,410 --> 00:16:27,130
Namun sekarang Anda dapat melihat
properti-properti mengagumkan apa yang 

311
00:16:27,130 --> 00:16:28,230
diberikan kepada Anda.

312
00:16:28,230 --> 00:16:30,350
Dan properti-properti ini 
akan menjadi penting

313
00:16:30,350 --> 00:16:32,490
untuk aplikasi kita, OK?

314
00:16:32,490 --> 00:16:36,146
Jadi mari kita mulai dengan
berbagai properti-properti yang berbeda.

315
00:16:36,146 --> 00:16:37,520
Dan ini semua merupakan
properti yang

316
00:16:37,520 --> 00:16:43,030
akan berguna untuk
verifikasi atau aplikasi

317
00:16:43,030 --> 00:16:44,850
keamanan komputer.

318
00:16:44,850 --> 00:16:51,100
Yang pertama, bukan ow,
ini adalah O, W. Ini adalah one-wayness (ke-satu-arah-an),

319
00:16:51,100 --> 00:16:51,780
baik?

320
00:16:51,780 --> 00:16:53,930
Jadi satu arah atau ke-satu-arah-an.

321
00:16:53,930 --> 00:17:03,230
Dan hal tersebut juga disebut-- Anda
tidak akan menyebutnya ini--

322
00:17:03,230 --> 00:17:09,390
tetapi mungkin ini merupakan 
istilah yang lebih teknis, istilah yang lebih

323
00:17:09,390 --> 00:17:11,150
tepat, pre-image resistance (ketahanan pre-image).

324
00:17:11,150 --> 00:17:13,060
Jadi apa arti dari ini?

325
00:17:13,060 --> 00:17:15,167
Jadi ini adalah kebutuhan 
yang sangat kuat.

326
00:17:15,167 --> 00:17:16,750
Maksud saya beberapa 
hal yang lain juga

327
00:17:16,750 --> 00:17:18,990
mungkin akan lebih kuat.

328
00:17:18,990 --> 00:17:21,270
Tetapi ini adalah 
kebutuhan yang cukup kuat

329
00:17:21,270 --> 00:17:28,710
yang mengatakan ini
tidak memungkinkan, diberikan y,

330
00:17:28,710 --> 00:17:45,170
yang ada di dalam-- pada dasarnya
sebuah vektor d-bit, untuk menemukan x apapun

331
00:17:45,170 --> 00:17:50,950
sehingga h dari x sama dengan y.

332
00:17:50,950 --> 00:18:00,120
Jadi x ini adalah
pre-image dari y.

333
00:18:00,120 --> 00:18:01,580
Jadi hal ini mengatakan apa?

334
00:18:01,580 --> 00:18:04,400
Hal ini mengatakan bahwa saya ingin
membuat sebuah fungsi hash sehingga

335
00:18:04,400 --> 00:18:08,030
jika saya memberikan Anda 
sebuah spesifik-- kita menyebutnya

336
00:18:08,030 --> 00:18:12,870
string 160-bit, karena
kita berbicara mengenai SHA-1 disini,

337
00:18:12,870 --> 00:18:16,792
dan itu adalah hashnya--
Saya akan memiliki,

338
00:18:16,792 --> 00:18:18,250
ini akan menjadi
tidak mungkin

339
00:18:18,250 --> 00:18:25,430
untuk saya menemukan sebuah x yang
memproduksi string 160-bit tersebut,

340
00:18:25,430 --> 00:18:26,390
OK?

341
00:18:26,390 --> 00:18:29,100
Sekarang jika Anda melihat
pada pembangkit nilai acak kita,

342
00:18:29,100 --> 00:18:32,750
Anda menyadari jika Anda
mempunyai sebuah string 160-bit,

343
00:18:32,750 --> 00:18:36,970
dan mungkin Anda
mempunyai seluruh buku

344
00:18:36,970 --> 00:18:39,290
dan Anda bisa membaca
seluruh buku tersebut.

345
00:18:39,290 --> 00:18:41,940
Itu adalah buku dengan kapasitas tidak terbatas.

346
00:18:41,940 --> 00:18:44,750
Buku itu mempunyai banyak hal di dalamnya.

347
00:18:44,750 --> 00:18:49,800
Dan ketahuilah bahwa setiap kali siapapun
bertanya ke buku untuk pertama kali

348
00:18:49,800 --> 00:18:53,580
untuk sebuah x tertentu, ada
angka 160-bit acak yang

349
00:18:53,580 --> 00:18:55,700
dibangkitkan dan
ditaruh ke dalam buku tersebut.

350
00:18:55,700 --> 00:18:58,100
Dan ada banyak sekali
angka tersebut, benar?

351
00:18:58,100 --> 00:18:59,954
Jadi hal yang akan
terjadi adalah, Anda

352
00:18:59,954 --> 00:19:01,870
harus memeriksa 
keseluruhan buku,

353
00:19:01,870 --> 00:19:04,710
keseluruhan buku yang berpotensi
berkapasitas tidak terbatas ini,

354
00:19:04,710 --> 00:19:13,500
untuk mengetahui apakah
y tertentu ada di dalam buku

355
00:19:13,500 --> 00:19:14,660
atau tidak.

356
00:19:14,660 --> 00:19:18,310
Dan itu mungkin akan membutuhkan waktu 
yang sangat lama, OK?

357
00:19:18,310 --> 00:19:23,290
Jadi pada kasus di mana Anda
memiliki sebuah pembangkit nilai acak Anda

358
00:19:23,290 --> 00:19:27,660
harus menelusuri dan menemukan--
memeriksa keluaran hash

359
00:19:27,660 --> 00:19:30,502
yang sesuai dengan tiap
entri dalam pembangkit nilai acak,

360
00:19:30,502 --> 00:19:32,960
Anda akan mulai mencocokkan,
cocokkan, cocokkan, cocokkan, cocokkan,

361
00:19:32,960 --> 00:19:35,290
hal itu akan membutuhkan
waktu eksponensial.

362
00:19:35,290 --> 00:19:37,760
Sebenarnya lebih buruk dari itu,
mempertimbangkan kapasitas tak terhingga

363
00:19:37,760 --> 00:19:38,930
dari buku tersebut.

364
00:19:38,930 --> 00:19:40,970
Jadi hal ini dengan jelas memberikan Anda hal itu.

365
00:19:40,970 --> 00:19:44,070
Sekarang Anda mungkin tidak sepenuhnya
puas dengan jawaban itu

366
00:19:44,070 --> 00:19:46,620
karena Anda mengatakan,
Anda tidak dapat mengimplementasikan hal itu.

367
00:19:46,620 --> 00:19:48,410
Tapi kita akan membahasnya
sedikit, seperti yang saya katakan,

368
00:19:48,410 --> 00:19:50,410
tentang bagaimana Anda dapat
memperoleh ini sesungguhnya.

369
00:19:50,410 --> 00:19:54,510
Tapi apa yang-- saya harus
jelas-- adalah fungsi hash

370
00:19:54,510 --> 00:19:59,180
sederhana yang telah kita lihat
sebelumnya hanya untuk membangun

371
00:19:59,180 --> 00:20:02,570
kamus tidak
memmuaskan hal ini, benar?

372
00:20:02,570 --> 00:20:11,860
Jadi misalkan saya mempunyai h dari x
sama dengan x kuadrat modulo p.

373
00:20:11,860 --> 00:20:18,050
Apakah ini satu arah,
diberikan sebuah p publik?

374
00:20:18,050 --> 00:20:19,210
Tidak tentu saja bukan, benar?

375
00:20:19,210 --> 00:20:22,310
Karena saya akan menjadi--
hal ini akan mudah

376
00:20:22,310 --> 00:20:24,730
bagi saya untuk melakukan sesuatu.

377
00:20:24,730 --> 00:20:29,320
Walaupun hal ini adalah aritmatika
diskret saya dapat melakukan sesuatu

378
00:20:29,320 --> 00:20:32,670
seperti, yah, saya tahu bahwa apa yang
saya punya di sini-- sebenarnya, mari

379
00:20:32,670 --> 00:20:34,170
kita lakukan dengan sesuatu 
yang lebih sederhana,

380
00:20:34,170 --> 00:20:36,580
lalu saya akan membahas
tentang x kuadrat.

381
00:20:36,580 --> 00:20:38,650
Jika saya memiliki sesuatu
se-sederhana x modulo p,

382
00:20:38,650 --> 00:20:42,100
maksud saya itu secara sepele rusak
dipandang dari ke-satu-arah-an.

383
00:20:42,100 --> 00:20:45,900
Karena saya tahu bahwa h dari x bisa
dilihat sebagai sisa.

384
00:20:45,900 --> 00:20:51,870
Jadi apapun-- jika ini
adalah h dari x, dan mari

385
00:20:51,870 --> 00:20:54,310
sebut saja hal itu y
sebentar, karena hal itu 

386
00:20:54,310 --> 00:20:56,280
apa yang kita punya di sana.

387
00:20:56,280 --> 00:21:00,340
Sesuatu yang merupakan kelipatan
dari y ditambah sisanya-- jadi saya

388
00:21:00,340 --> 00:21:02,777
bisa memiliki a-- apakah itu benar?

389
00:21:02,777 --> 00:21:03,610
Apakah itu yang saya inginkan?

390
00:21:03,610 --> 00:21:04,109
Iya.

391
00:21:04,109 --> 00:21:05,050
Tidak, tambah y.

392
00:21:05,050 --> 00:21:13,760
Jadi saya ingin a dari-- jadi karena
saya tidak bisa mengetahui hal itu,

393
00:21:13,760 --> 00:21:16,250
kenapa Anda tidak bisa?

394
00:21:16,250 --> 00:21:17,970
Apa yang harus saya
taruh di sana agar

395
00:21:17,970 --> 00:21:24,170
bisa menemukan sebuah x yang
akan menghasilkan sebuah y?

396
00:21:24,170 --> 00:21:25,290
Apakah saya bisa menulis sebuah persamaan?

397
00:21:25,290 --> 00:21:26,192
Iya?

398
00:21:26,192 --> 00:21:27,967
AUDIENS: Bisakah Anda
menulis y nya saja?

399
00:21:27,967 --> 00:21:29,300
SRINIVAS DEVADAS: Hanya y nya saja.

400
00:21:29,300 --> 00:21:29,960
Itu benar.

401
00:21:29,960 --> 00:21:30,900
Poin yang baik.

402
00:21:30,900 --> 00:21:32,635
Hanya y nya saja dalam kasus ini.

403
00:21:32,635 --> 00:21:33,820
Bagus.

404
00:21:33,820 --> 00:21:35,650
Saya tahu kalian lebih
pintar dari saya.

405
00:21:35,650 --> 00:21:38,060
Hal ini membuktikannya.

406
00:21:38,060 --> 00:21:41,500
Jadi, jika Anda hanya mengambil
y-- dan ingat y

407
00:21:41,500 --> 00:21:46,190
akan menjadi sesuatu
yang bernilai dari 0 sampai p dikurangi 1, benar?

408
00:21:46,190 --> 00:21:47,520
Dan begitu saja.

409
00:21:47,520 --> 00:21:49,170
Hal itu hanya akan berlalu saja, benar?

410
00:21:49,170 --> 00:21:51,150
Jadi itu adalah contoh yang
mudah dipahami, benar?

411
00:21:51,150 --> 00:21:55,780
Sekarang jika saya memasukkan x kuadrat
di sini, jelas ini bukan y,

412
00:21:55,780 --> 00:22:03,050
tetapi saya bisa mulai 
melihat pada-- hal yang saya miliki di sini

413
00:22:03,050 --> 00:22:05,280
saya akan mendapatkan y yang
terlihat seperti x kuadrat.

414
00:22:05,280 --> 00:22:07,220
Tapi saya bisa mengambil
y yang saya miliki,

415
00:22:07,220 --> 00:22:09,240
mengambil akar kuadrat
dari y tersebut, lalu mulai

416
00:22:09,240 --> 00:22:13,570
mencari nilai-nilai x yang memberikan
saya y yang saya miliki.

417
00:22:13,570 --> 00:22:18,020
Sebenarnya ini bukan proses 
yang rumit untuk dicoba dan dipelajari,

418
00:22:18,020 --> 00:22:20,230
melalui coba-coba
(trial and error),

419
00:22:20,230 --> 00:22:23,250
x apakah yang
menghasilkan sebuah y tertentu

420
00:22:23,250 --> 00:22:25,360
untuk jenis-jenis fungsi
hash yang telah kita

421
00:22:25,360 --> 00:22:26,900
lihat, OK?

422
00:22:26,900 --> 00:22:32,050
Sekarang semakin Anda membuat rumit
persamaan ini, persamaan ini semakin sulit.

423
00:22:32,050 --> 00:22:34,626
Karena Anda harus membalikkan
kumpulan persamaan ini.

424
00:22:34,626 --> 00:22:36,000
Dan seperti itulah
permainan ini akan berbentuk

425
00:22:36,000 --> 00:22:38,620
pada saat Anda membuat
fungsi hash satu arah.

426
00:22:38,620 --> 00:22:41,520
Jumlah komputasi
yang Anda lakukan untuk

427
00:22:41,520 --> 00:22:44,770
menghitung nilai y yang
akan meningkat sampai ke titik

428
00:22:44,770 --> 00:22:47,770
di mana, seperti yang saya katakan, Anda mempunyai
80, 100 ronde komputasi,

429
00:22:47,770 --> 00:22:49,400
hal-hal dicampur aduk.

430
00:22:49,400 --> 00:22:53,210
Dan harapannya adalah Anda menciptakan
sirkuit ini,

431
00:22:53,210 --> 00:22:54,970
yang memiliki semua
komputasi ini di dalamnya.

432
00:22:54,970 --> 00:22:57,170
Ke depannya akan semakin
mudah, karena Anda telah

433
00:22:57,170 --> 00:22:59,350
menspesifikasikan
perkalian-perkaliannya dan modulo-modulonya

434
00:22:59,350 --> 00:23:00,700
dan sebagainya.

435
00:23:00,700 --> 00:23:04,830
Tapi tidak semua operasi-operasi ini
memiliki invers-invers sederhana.

436
00:23:04,830 --> 00:23:07,790
Dan kembali ke belakang,
apa yang

437
00:23:07,790 --> 00:23:11,010
harus Anda lakukan untuk
mematahkan ke-satu-arah-an,

438
00:23:11,010 --> 00:23:14,890
atau menemukan x
dari suatu y, akan

439
00:23:14,890 --> 00:23:17,100
menjadi semakin sulit
seiring dengan komputasi-komputasi yang

440
00:23:17,100 --> 00:23:18,890
semakin kompleks, OK?

441
00:23:18,890 --> 00:23:20,905
Jadi semua orang memiliki gambaran
tentang apa itu ke-satu-arah-an?

442
00:23:24,810 --> 00:23:26,990
Jadi itulah ke-satu-arah-an.

443
00:23:26,990 --> 00:23:30,930
Ada empat properti lain,
dua dari mereka sangat berhubungan.

444
00:23:30,930 --> 00:23:33,700
CR dan TCR.

445
00:23:33,700 --> 00:23:35,550
Jadi CR adalah ketahanan terhadap tabrakan (collision resistance).

446
00:23:42,970 --> 00:23:54,290
Hal ini tidak memungkinkan untuk menemukan x dan
x aksen, agar x tidak sama

447
00:23:54,290 --> 00:24:02,269
dengan x aksen, dan h dari
x sama dengan h dari x aksen,

448
00:24:02,269 --> 00:24:03,560
yang tentu saja merupakan sebuah tabrakan.

449
00:24:08,300 --> 00:24:09,690
OK?

450
00:24:09,690 --> 00:24:14,790
Dan itu hanya menyatakan Anda memiliki
fungsi hash gila ini di mana

451
00:24:14,790 --> 00:24:16,650
Anda tidak dapat menemukan collisions.

452
00:24:16,650 --> 00:24:18,620
Yah ini akan menjadi
sangat luar biasa.

453
00:24:18,620 --> 00:24:21,740
Sebenarnya hal itulah yang kita inginkan
ketika kita membangun kamus-kamus.

454
00:24:21,740 --> 00:24:25,290
Tapi kenapa kita tidak menggunakan
SHA-3 dalam kamus-kamus?

455
00:24:28,410 --> 00:24:30,350
Kenapa kita tidak menggunakan
SHA-3 dalam kamus-kamus?

456
00:24:30,350 --> 00:24:30,851
Ya?

457
00:24:30,851 --> 00:24:33,058
AUDIENS: Karena hal tersebut lebih
rumit dari yang kita butuhkan.

458
00:24:33,058 --> 00:24:35,270
SRINIVAS DEVADAS: Ya,
hal tersebut sangat lambat, benar?

459
00:24:35,270 --> 00:24:39,365
Akan membutuhkan waktu lebih lama untuk
menghitung nilai hash daripada mengakses

460
00:24:39,365 --> 00:24:40,740
kamusnya,
ketika Anda sesungguhnya

461
00:24:40,740 --> 00:24:44,847
mempunyai sebuah kamus yang ukurannya masuk akal
yang mungkin memiliki beberapa collision.

462
00:24:44,847 --> 00:24:46,930
Maksud saya Anda dapat memulainya dan
Anda punya sebuah linked list,

463
00:24:46,930 --> 00:24:50,090
Anda mampu menoleransi sedikit collision,
tidak masalahnya, benar?

464
00:24:50,090 --> 00:24:51,860
Jadi tidak
masuk akal

465
00:24:51,860 --> 00:24:57,420
untuk menggunakan fungsi
hash sekompleks ini,

466
00:24:57,420 --> 00:25:00,830
bahkan jika dia memenuhi
collision resistance-- yang

467
00:25:00,830 --> 00:25:04,070
beberapa di antaranya diduga untuk
melakukan-- untuk aplikasi-aplikasi

468
00:25:04,070 --> 00:25:04,617
yang sudah kita lihat.

469
00:25:04,617 --> 00:25:06,950
Tapi akan ada aplikasi-aplikasi lain
di mana collision resistance

470
00:25:06,950 --> 00:25:08,520
akan menjadi penting.

471
00:25:08,520 --> 00:25:10,110
Jadi itu adalah collision resistance.

472
00:25:10,110 --> 00:25:15,470
Lalu ada-- TCR adalah
Target Collision Resistance.

473
00:25:15,470 --> 00:25:18,300
Ini adalah bentuk yang lebih lemah--
jadi terkadang orang-orang (menganggap)

474
00:25:18,300 --> 00:25:24,190
CR adalah collision resistance yang kuat,
dan TCR collision resistance

475
00:25:24,190 --> 00:25:24,810
yang lemah.

476
00:25:24,810 --> 00:25:28,090
Kita akan menggunakan CR dan TCR di sini.

477
00:25:28,090 --> 00:25:35,460
Dan hal ini mengatakan hal tersebut
tidak mungkin, diberikan

478
00:25:35,460 --> 00:25:39,200
x-- jadi ada sebuah
x tertentu yang Anda

479
00:25:39,200 --> 00:25:41,590
ingin temukan collision
nya, alih-alih

480
00:25:41,590 --> 00:25:45,360
hanya mencari sebuah pasangan yang
hanya sekali menuju ke x dan x aksen.

481
00:25:45,360 --> 00:25:49,700
Dan pasangan apapun akan cukup untuk
merusak properti

482
00:25:49,700 --> 00:25:50,560
collision resistance tersebut.

483
00:25:50,560 --> 00:25:54,630
Tapi TCR mengatakan bahwa saya akan
memberikan Anda sebuah x tertentu.

484
00:25:54,630 --> 00:25:57,750
dan saya ingin Anda untuk
mencari sebuah x aksen yang

485
00:25:57,750 --> 00:26:01,050
hash-nya sama dengan
hash dari x, OK?

486
00:26:01,050 --> 00:26:02,065
Itu adalah TCR.

487
00:26:16,350 --> 00:26:18,082
OK itu adalah TCR bagi Anda.

488
00:26:18,082 --> 00:26:20,040
Dan supaya jelas,
saya rasa mungkin Anda semua

489
00:26:20,040 --> 00:26:23,420
mengerti hal ini, dengan jelas
kita menginginkan ini di sini

490
00:26:23,420 --> 00:26:26,340
karena kita memiliki sebuah
fungsi hash yang deterministik.

491
00:26:26,340 --> 00:26:29,430
Dan cukup jelas
untuk mengatakan bahwa jika Anda memiliki x,

492
00:26:29,430 --> 00:26:32,380
dan Anda memiliki x lagi, Anda
mendapatkan hash yang sama dari situ.

493
00:26:32,380 --> 00:26:33,740
Itu adalah sebuah kebutuhan, sungguh.

494
00:26:33,740 --> 00:26:36,670
Jadi kita ingin 2 nilai x yang berbeda
dan sekumpulan x aksen yang tidak

495
00:26:36,670 --> 00:26:38,590
sama yang pada akhirnya akan bertabrakan.

496
00:26:38,590 --> 00:26:40,890
Itu adalah arti sesungguhnya 
dari sebuah collision.

497
00:26:40,890 --> 00:26:44,200
Jadi Anda melihat perbedaan
antara CR dan TCR?

498
00:26:44,200 --> 00:26:44,700
Yup?

499
00:26:44,700 --> 00:26:45,812
Ya?

500
00:26:45,812 --> 00:26:49,144
AUDIENS: Apakah kita
mengasumsikan bahwa diketahui sebuah x

501
00:26:49,144 --> 00:26:51,105
itu sangat mudah untuk
mendapatkan h dari x kembali?

502
00:26:51,105 --> 00:26:52,480
SRINIVAS DEVADAS:
Jadi pertanyaannya

503
00:26:52,480 --> 00:26:57,150
adalah, diketahui suatu x, itu adalah komputasi
dengan waktu polinomial untuk mendapatkan h dari x.

504
00:26:57,150 --> 00:26:58,230
Benar.

505
00:26:58,230 --> 00:27:02,480
Komputasi publik dengan waktu polinomial
diketahui suatu x untuk mendapatkan h dari x.

506
00:27:02,480 --> 00:27:08,840
Jadi berjalan ke arah sini mudah.

507
00:27:08,840 --> 00:27:15,170
Berjalan ke arah sini-- saya lari
keluar dari ruangan-- sulit.

508
00:27:15,170 --> 00:27:16,954
OK?

509
00:27:16,954 --> 00:27:20,160
AUDIENS: Jadi apakah itu berarti bahwa
TCR pada dasarnya sama dengan 1?

510
00:27:20,160 --> 00:27:22,230
SRINIVAS DEVADAS: Tidak,
tidak, tidak, sama sekali tidak.

511
00:27:22,230 --> 00:27:25,890
TCR bilang tidak apa-apa.

512
00:27:25,890 --> 00:27:27,620
Anda dapat menghitung hal ini.

513
00:27:27,620 --> 00:27:29,030
Anda bisa mendapatkan x.

514
00:27:29,030 --> 00:27:30,720
Dan Anda bisa mendapatkan h dari x.

515
00:27:30,720 --> 00:27:33,125
Jadi diberikan x, Anda tahu
bahwa Anda bisa mendapatkan h dari x.

516
00:27:33,125 --> 00:27:35,000
Saya sebenarnya tidak menaruh
hal itu di dalam definisi.

517
00:27:35,000 --> 00:27:36,800
Dan mungkin saya seharusnya melakukan hal itu.

518
00:27:36,800 --> 00:27:38,860
Jadi diberikan x Anda bisa
selalu dapatkan h dari x.

519
00:27:38,860 --> 00:27:40,080
Ingat hal itu.

520
00:27:40,080 --> 00:27:41,640
Sangat mudah untuk mendapatkan h dari x.

521
00:27:41,640 --> 00:27:44,350
Jadi kapan pun saya mengatakan diberikan
x, Anda selalu dapat menambahkannya,

522
00:27:44,350 --> 00:27:46,400
mengatakan diberikan x dan h dari x.

523
00:27:46,400 --> 00:27:48,690
Jadi saya diberikan x.

524
00:27:48,690 --> 00:27:49,960
Saya diberikan h dari x.

525
00:27:49,960 --> 00:27:53,600
Jelas bahwa saya harus 
memetakan-- saya harus menemukan

526
00:27:53,600 --> 00:27:58,080
sebuah x aksen sehingga h dari
x aksen sama dengan h dari x, OK?

527
00:27:58,080 --> 00:28:04,490
Sekarang Anda mempunyai situasi-situasi
di mana untuk-- itu

528
00:28:04,490 --> 00:28:07,920
mungkin kasus di mana 
untuk nilai-nilai x tertentu Anda

529
00:28:07,920 --> 00:28:08,900
sesungguhnya bisa melakukan hal ini.

530
00:28:08,900 --> 00:28:10,363
Dan itu cukup untuk merusak TCR.

531
00:28:13,270 --> 00:28:15,640
Jadi Anda harus mempunyai
properti yang kuat ini

532
00:28:15,640 --> 00:28:22,520
yang Anda sangat tidak inginkan untuk
menemukan collisions untuk beberapa--

533
00:28:22,520 --> 00:28:26,470
bahkan jika ada sebuah pecahan
konstan dari nilai-nilai x yang

534
00:28:26,470 --> 00:28:29,210
merusak properti TCR, Anda
tidak menyukai fungsi hash Anda,

535
00:28:29,210 --> 00:28:29,710
OK?

536
00:28:29,710 --> 00:28:31,850
Karena Anda mungkin pada akhirnya akan
memilihnya itu dan lanjut

537
00:28:31,850 --> 00:28:35,490
membangun aplikasi-aplikasi keamanan
menggunakan properti-properti tersebut.

538
00:28:35,490 --> 00:28:37,990
Saya ingin membahas sedikit
mengenai hubungan

539
00:28:37,990 --> 00:28:41,240
antara OW, CR, dan TCR.

540
00:28:41,240 --> 00:28:42,700
Jadi saya akan
kembali ke situ.

541
00:28:42,700 --> 00:28:45,290
Dan kita akan berbicara
mengenai fungsi-fungsi hash yang

542
00:28:45,290 --> 00:28:48,076
memenuhi satu properti tetapi
tidak memenuhi yang lainnya.

543
00:28:48,076 --> 00:28:49,700
Dan saya pikir
pertanyaan Anda mungkin

544
00:28:49,700 --> 00:28:52,150
akan terjawab lebih baik, OK?

545
00:28:52,150 --> 00:28:53,460
Terima kasih atas pertanyaannya.

546
00:28:53,460 --> 00:28:56,160
Jadi hal-hal itu adalah yang utama.

547
00:28:56,160 --> 00:28:59,260
Dan dengan cepat, jika Anda
ingin menghabiskan banyak waktu

548
00:28:59,260 --> 00:29:02,972
dalam hal ini-- tetapi saya
ingin mengatakan--

549
00:29:02,972 --> 00:29:05,320
Saya rasa saya akan meninggalkan
properti-properti ini di atas sini

550
00:29:05,320 --> 00:29:06,590
untuk sekarang.

551
00:29:06,590 --> 00:29:10,350
Karena penting bagi Anda
untuk melihat definisi-definisi ini

552
00:29:10,350 --> 00:29:13,580
selagi kita melihat
aplikasi-aplikasi di mana kita

553
00:29:13,580 --> 00:29:17,090
membutuhkan properti-properti ini, atau
sebagian dari properti-properti ini.

554
00:29:17,090 --> 00:29:19,580
Tapi kita memiliki
keacakan semu.

555
00:29:19,580 --> 00:29:22,910
Dan ini hanya sebuah
fungsi dari fakta

556
00:29:22,910 --> 00:29:31,100
bahwa-- jadi ini adalah PRF-- kita tahu
kita tidak bisa membangun sebuah pembangkit nilai acak.

557
00:29:31,100 --> 00:29:35,300
Jadi kita akan harus melakukan
sesuatu yang acak secara semu (pseudo-random).

558
00:29:35,300 --> 00:29:37,840
Dan pada dasarnya apa
yang kita bahas di sini

559
00:29:37,840 --> 00:29:45,870
adalah perilaku yang
tidak dapat dipisahkan dari keacakan.

560
00:29:50,990 --> 00:29:56,140
Jadi kita akan harus menggunakan
ke-non-linear-an, hal-hal yang

561
00:29:56,140 --> 00:29:58,730
disebut sebagai non-linear
feedback shift registers,

562
00:29:58,730 --> 00:30:00,370
untuk menciptakan fungsi-fungsi
acak yang semu (pseudo-random).

563
00:30:00,370 --> 00:30:03,710
Ada banyak cara agar kita dapat
menciptakan fungsi-fungsi semu acak.

564
00:30:03,710 --> 00:30:05,310
Kita tidak akan membahas hal itu terlalu dalam.

565
00:30:05,310 --> 00:30:07,680
Tapi jelas itu adalah
hal yang kita inginkan.

566
00:30:07,680 --> 00:30:14,420
Lalu yang terakhir
sedikit rumit.

567
00:30:14,420 --> 00:30:18,830
Dan kita akan mempunyai sebuah aplikasi yang
membutuhkan cara ini pada akhirnya.

568
00:30:18,830 --> 00:30:29,240
Tapi ini tidak memungkinkan
diketahui h dari x

569
00:30:29,240 --> 00:30:42,010
untuk menghasilkan h dari x aksen, di mana
x dan x aksen adalah-- ini menjadi

570
00:30:42,010 --> 00:30:50,150
sedikit kabur disini-- 
berhubungan dalam beberapa segi, benar?

571
00:30:50,150 --> 00:30:53,630
Jadi sebuah contoh
yang konkret dari hal ini adalah,

572
00:30:53,630 --> 00:30:59,770
mari katakan x
aksen adalah x tambah 1.

573
00:30:59,770 --> 00:31:02,630
Jadi ini adalah sebuah contoh
yang masuk akal dari hal ini.

574
00:31:02,630 --> 00:31:09,930
Jadi apa yang dimaksud dengan hal ini adalah
Anda hanya diberikan h dari x.

575
00:31:09,930 --> 00:31:12,680
Ini sesungghunya belum mengimplikasikan
apapun mengenai ke-satu-arah-an.

576
00:31:12,680 --> 00:31:14,670
Tapi Anda dapat
mengasumsikan, contohnya,

577
00:31:14,670 --> 00:31:18,510
bahwa jika ini adalah sebuah
fungsi hash yang satu arah,

578
00:31:18,510 --> 00:31:23,581
akan memungkinkan untuk
mendapatkan x dari h(x), benar?

579
00:31:26,300 --> 00:31:28,070
Dan mari kita simpan hal itu.

580
00:31:28,070 --> 00:31:29,470
Simpan pemikiran itu, baik?

581
00:31:29,470 --> 00:31:31,290
Kita akan kembali ke hal tersebut.

582
00:31:31,290 --> 00:31:36,710
Jadi jika saya hanya diberikan hash
melalui sebuah perhitungan.

583
00:31:36,710 --> 00:31:40,300
akan memungkinkan bagi saya
untuk menciptakan hash lain, h

584
00:31:40,300 --> 00:31:45,330
dari x aksen, sehingga
ada suatu hubungan

585
00:31:45,330 --> 00:31:51,010
yang dapat saya buktikan atau berikan argumen
antara string-string yang

586
00:31:51,010 --> 00:31:54,390
menciptakan hash-hash tersebut,
yaitu x dan x aksen, OK?

587
00:31:54,390 --> 00:31:57,330
Itulah apa
yang dimaksud malleability, benar?

588
00:31:57,330 --> 00:32:03,440
Sekarang Anda mungkin akan lompat pada kesimpulan dan
mengatakan ini adalah x, ini adalah y,

589
00:32:03,440 --> 00:32:07,700
ini adalah h(x),
dan ini adalah h(y).

590
00:32:07,700 --> 00:32:09,620
Hal-hal ini terlihat seperti sepenuhnya acak.

591
00:32:09,620 --> 00:32:12,890
Dan Anda mungkin akan lompat pada kesimpulan-- saya
sedang bercanda disini-- saya

592
00:32:12,890 --> 00:32:17,767
mengatakan bahwa y adalah saudara ipar dari
teman sekamar dari sepupu ketiga dari x.

593
00:32:17,767 --> 00:32:18,600
atau sesuatu, benar?

594
00:32:18,600 --> 00:32:20,600
Maksud saya karang
saja sesuatu, benar?

595
00:32:20,600 --> 00:32:26,470
Jadi jelas harus ada
sebuah hubungan kuat dan tepat

596
00:32:26,470 --> 00:32:27,780
antara x dan y.

597
00:32:27,780 --> 00:32:32,180
Jika faktanya Anda dapat
melakukan ini dan mendapatkan y

598
00:32:32,180 --> 00:32:36,160
sama dengan x tambah 1, itu
akan menjadi masalah, benar?

599
00:32:36,160 --> 00:32:38,840
Tapi jika Anda--
lalu Anda dapat

600
00:32:38,840 --> 00:32:42,280
melakukan hal ini secara agak konsisten
untuk nilai-nilai x dan y yang berbeda, itu

601
00:32:42,280 --> 00:32:44,980
pasti akan menjadi
sebuah masalah, benar?

602
00:32:44,980 --> 00:32:48,440
Tapi hal yang sesungguhnya Anda
minta-- dan khususnya

603
00:32:48,440 --> 00:32:50,710
ketika Anda menginginkan
non-malleability-- seperti

604
00:32:50,710 --> 00:32:55,000
di mana Anda mempunyai
pelelangan, contohnya, di mana

605
00:32:55,000 --> 00:32:58,350
Anda berhati-hati dalam
memastikan bahwa Anda tidak ingin

606
00:32:58,350 --> 00:33:01,320
menunjukkan tawaran Anda.

607
00:33:01,320 --> 00:33:04,700
Jadi apa yang mungkin Anda
lakukan adalah menunjukkan h(x).

608
00:33:04,700 --> 00:33:08,960
Anda tidak ingin seseorang
melihat h(x) Anda

609
00:33:08,960 --> 00:33:10,420
dan mengetahui bagaimana
mereka bisa mengalahkan

610
00:33:10,420 --> 00:33:13,540
tawaran Anda hanya dengan melebihkan sedikit saja.

611
00:33:13,540 --> 00:33:17,140
Atau pada kasus pelelangan Vickrey,
di mana penawar tertinggi kedua

612
00:33:17,140 --> 00:33:20,031
menang, sekarang hanya sedikit
di bawah Anda, benar?

613
00:33:20,031 --> 00:33:21,530
Jadi hal itu adalah jenis
hal yang Anda

614
00:33:21,530 --> 00:33:25,110
ingin pikirkan ketika
berhubungan dengan non-malleability,

615
00:33:25,110 --> 00:33:28,880
atau malleability, di mana Anda
menginginkan sebuah hubungan yang kuat

616
00:33:28,880 --> 00:33:32,300
antara dua string
yang berhubungan

617
00:33:32,300 --> 00:33:35,510
dengan suatu urutan tertentu,
seperti x sama dengan-- x aksen

618
00:33:35,510 --> 00:33:38,950
sama dengan x plus 1, atau hanya
x aksen sama dengan 2 kali x.

619
00:33:38,950 --> 00:33:43,040
Dan Anda tidak mau
agar bisa-- Anda

620
00:33:43,040 --> 00:33:45,350
tidak menginginkan musuh
untuk dapat menemukan

621
00:33:45,350 --> 00:33:47,670
string-string baru ini.

622
00:33:47,670 --> 00:33:51,440
Karena itu akan menjadi
sistemnya, OK?

623
00:33:51,440 --> 00:33:55,580
Jadi ada pertanyaan
tentang properti-properti?

624
00:33:55,580 --> 00:33:57,620
Apakah semua jelas tentang
properti-properti ini?

625
00:33:57,620 --> 00:33:59,840
Baiklah, karena saya
akan mulai bertanya kepada Anda

626
00:33:59,840 --> 00:34:03,010
bagaimana cara menggunakan mereka untuk
aplikasi-aplikasi tertentu,

627
00:34:03,010 --> 00:34:09,170
atau properti-properti apa yang dibutuhkan
untuk aplikasi-aplikasi tertentu, OK?

628
00:34:09,170 --> 00:34:11,150
Satu hal lagi
sebelum kita ke sana.

629
00:34:11,150 --> 00:34:16,960
Saya menjanjikan sebuah
analisis yang sedikit lebih rinci

630
00:34:16,960 --> 00:34:20,170
tentang hubungan
antara properti-properti ini.

631
00:34:20,170 --> 00:34:20,974
Jadi mari kita lakukan hal tersebut.

632
00:34:24,810 --> 00:34:27,830
Sekarang jika Anda
melihatnya, memperhatikannya,

633
00:34:27,830 --> 00:34:34,888
dan Anda perhatikan pada
collision resistance dan TCR,

634
00:34:34,888 --> 00:34:36,429
hal apa yang dapat saya katakan
tentang relasi

635
00:34:36,429 --> 00:34:40,820
antara CR dan TCR?

636
00:34:40,820 --> 00:34:45,953
Jika h adalah CR, dia akan
menjadi TCR, benar?

637
00:34:45,953 --> 00:34:46,744
Dia pasti menjadi TCR.

638
00:34:46,744 --> 00:34:48,735
Ini adalah kebutuhan
yang lebih ketat.

639
00:34:54,659 --> 00:34:55,415
Tapi tidak kebalikannya.

640
00:34:57,940 --> 00:35:04,230
Dan Anda sebenarnya dapat
memberikan sebuah contoh konkret

641
00:35:04,230 --> 00:35:07,077
tentang fungsi hash tertentu
yang merupakan TCR.

642
00:35:07,077 --> 00:35:08,160
Saya tidak akan membahas sampai ke sana.

643
00:35:08,160 --> 00:35:09,659
Itu sebenarnya
sedikit lebih terlibat

644
00:35:09,659 --> 00:35:12,780
daripada yang mungkin Anda pikirkan,
di mana sebuah fungsi hash TCR

645
00:35:12,780 --> 00:35:14,430
bukan merupakan collision resistant.

646
00:35:14,430 --> 00:35:17,180
Tapi Anda dapat melihat bahwa
contoh-contoh seperti ini

647
00:35:17,180 --> 00:35:20,340
seharusnya ada, hanya karena saya
memiliki properti yang lebih ketat

648
00:35:20,340 --> 00:35:22,280
yang berkaitan dengan
collision resistance

649
00:35:22,280 --> 00:35:24,680
daripada TCR, benar?

650
00:35:24,680 --> 00:35:27,170
Jadi jika Anda tertarik dengan
contoh tertentu itu,

651
00:35:27,170 --> 00:35:29,780
walaupun tidak wajib,
hubungi saya

652
00:35:29,780 --> 00:35:32,545
dan saya akan mengarahkan Anda ke,
penjelasan yang berisi contoh

653
00:35:32,545 --> 00:35:34,180
dan panjangnya tiga halaman.

654
00:35:34,180 --> 00:35:35,930
Jadi saya tidak terlalu
menjelaskan lebih dalam.

655
00:35:35,930 --> 00:35:40,170
Tapi yang saya ingin lakukan adalah bicara
mengenai ke-satu-arah-an dan collision

656
00:35:40,170 --> 00:35:40,820
resistance.

657
00:35:40,820 --> 00:35:43,069
Karena menurut saya itu
jauh lebih menarik,

658
00:35:43,069 --> 00:35:43,720
OK?

659
00:35:43,720 --> 00:35:59,060
Jadi jika h itu satu arah--
apakah ada yang ingin menebak

660
00:35:59,060 --> 00:36:03,370
apa tanda tanya
yang ada di tengah itu?

661
00:36:03,370 --> 00:36:07,950
Bisakah saya membuat pernyataan kuat
mengenai collision resistance

662
00:36:07,950 --> 00:36:10,430
dari sebuah fungsi hash,
jika saya digaransikan

663
00:36:10,430 --> 00:36:14,010
bahwa fungsi hash yang saya punya
adalah fungsi hash satu arah,

664
00:36:14,010 --> 00:36:14,730
atau sebaliknya?

665
00:36:20,960 --> 00:36:23,080
Cara lain untuk
mengatakannya adalah, bisakah Anda

666
00:36:23,080 --> 00:36:28,970
memberikan contoh kepada saya,
untuk memulai saja,

667
00:36:28,970 --> 00:36:35,096
sebuah fungsi hash yang satu
arah tapi tidak TCR, tidak

668
00:36:35,096 --> 00:36:36,220
target collision resistant?

669
00:36:40,520 --> 00:36:43,540
Jadi saya akan mencoba
mengekstrak hal ini dari Anda.

670
00:36:43,540 --> 00:36:46,870
Hal ini cukup rumit.

671
00:36:46,870 --> 00:36:48,990
Tapi bagaimana Anda 
memikirkan hal ini

672
00:36:48,990 --> 00:36:59,260
adalah, katakanlah h(x)
adalah OW dan TCR, OK?

673
00:36:59,260 --> 00:37:02,660
Jadi saya punya banyak masukan.

674
00:37:02,660 --> 00:37:03,660
Dan ini adalah keluarannya.

675
00:37:03,660 --> 00:37:06,160
Dan saya mendapatkan keluaran d-bit.

676
00:37:06,160 --> 00:37:12,010
Dan saya mempunyai x1, x2, hingga xn, OK?

677
00:37:12,010 --> 00:37:16,620
Sekarang saya telah diberikan h ini--
Saya telah diberikan h ini yang

678
00:37:16,620 --> 00:37:18,240
merupakan satu arah dan TCR.

679
00:37:18,240 --> 00:37:20,960
Hal tersebut memenuhi properti-properti itu
yang Anda miliki di atas sana.

680
00:37:20,960 --> 00:37:24,590
Dalam kasus satu arah, saya memberikan
Anda sebuah string d-bit acak.

681
00:37:24,590 --> 00:37:28,770
Anda tidak bisa mundur dan
menemukan sekumpulan xi yang

682
00:37:28,770 --> 00:37:34,150
menghasilkan string d-bit 
persis seperti itu, OK?

683
00:37:34,150 --> 00:37:36,530
Jadi akan sulit
untuk sampai kesini.

684
00:37:36,530 --> 00:37:40,380
Tapi sekarang Anda diperbolehkan
untuk memberi saya sebuah contoh.

685
00:37:40,380 --> 00:37:45,390
Jadi ini adalah beberapa fungsi
hash yang bisa Anda buat,

686
00:37:45,390 --> 00:37:48,300
yang mungkin menggunakan h juga.

687
00:37:48,300 --> 00:37:51,780
Dan h cukup bagus karena
ia memiliki properti satu arah ini.

688
00:37:51,780 --> 00:37:55,030
Jadi katakanlah bahwa kita ingin
menemukan sesuatu di mana

689
00:37:55,030 --> 00:37:59,080
satu arah tidak berarti TCR.

690
00:37:59,080 --> 00:38:03,490
Jadi saya ingin membuat sebuah
fungsi hash h aksen sehingga

691
00:38:03,490 --> 00:38:09,550
h aksen tersebut satu arah,
tapi bukan TCR, OK?

692
00:38:09,550 --> 00:38:13,610
Cara yang Anda ingin pikirkan
tentang hal ini adalah Anda tambahkan ke h.

693
00:38:13,610 --> 00:38:16,790
Dan Anda ingin menambahkan sesuatu
terhadap h agar tetap sulit--

694
00:38:16,790 --> 00:38:20,347
jika Anda menambahkan h tetap sulit
untuk pergi dari sini ke sana.

695
00:38:20,347 --> 00:38:21,680
Karena Anda harus pergi lebih dalam.

696
00:38:21,680 --> 00:38:23,760
Jika Anda menambahkan ke, sebagai
contoh, masukan-masukan dari h.

697
00:38:23,760 --> 00:38:26,170
Atau Anda bisa menambahkan ke
keluaran-keluaran dari h juga,

698
00:38:26,170 --> 00:38:27,730
atau keluaran-keluaran dari h saat ini.

699
00:38:27,730 --> 00:38:34,670
Tapi pada dasarnya Anda bisa pergi lebih dalam,
atau harus pergi lebih dalam untuk

700
00:38:34,670 --> 00:38:39,580
menemukan pemutusan
ke-satu-arah-an, untuk

701
00:38:39,580 --> 00:38:43,820
menemukan sebuah x, apapun yang Anda miliki,
yang menghasilkan string d-bit

702
00:38:43,820 --> 00:38:44,910
yang Anda miliki, benar?

703
00:38:44,910 --> 00:38:49,690
Jadi apa cara sederhana untuk
membuat sebuah h aksen agar

704
00:38:49,690 --> 00:38:53,700
menjadi cukup mudah untuk
menemukan collision yang terarah,

705
00:38:53,700 --> 00:38:56,150
tidak harus berupa collision,
cukup mudah untuk menemukan

706
00:38:56,150 --> 00:38:58,740
collision terarah,
tanpa merusak

707
00:38:58,740 --> 00:39:00,180
properti ke-satu-arah-an dari h?

708
00:39:03,785 --> 00:39:05,264
Ya?

709
00:39:05,264 --> 00:39:11,673
AUDIENS: Jadi jika Anda mempunyai
x sub i, jika i ganjil maka

710
00:39:11,673 --> 00:39:14,631
kembalikan h(x) dari i.

711
00:39:14,631 --> 00:39:16,603
Agar ia berkurang 1.

712
00:39:16,603 --> 00:39:18,552
Jadi keluarkan kelompok yang genap.

713
00:39:18,552 --> 00:39:19,510
SRINIVAS DEVADAS: Tentu saja.

714
00:39:19,510 --> 00:39:21,004
Ya.

715
00:39:21,004 --> 00:39:24,241
AUDIENS: Diberikan
x apa saja x dari i, Anda

716
00:39:24,241 --> 00:39:27,478
biasanya dapat menemukan x lain dari
i yang memiliki keluaran yang sama?

717
00:39:27,478 --> 00:39:28,980
Anda bisa mundur.

718
00:39:28,980 --> 00:39:29,700
SRINIVAS DEVADAS: Anda
tidak bisa mundur.

719
00:39:29,700 --> 00:39:30,500
Ya, itu bagus.

720
00:39:30,500 --> 00:39:31,450
Itu bagus.

721
00:39:31,450 --> 00:39:34,114
Saya akan melakukan sesuatu yang
hampir sama dengan yang Anda katakan.

722
00:39:34,114 --> 00:39:35,655
Tetapi saya akan
menggambarkannya.

723
00:39:38,270 --> 00:39:42,705
Dan yang dapat Anda lakukan, Anda dapat
melakukan sebuah pembatas, seperti ganjil dan genap

724
00:39:42,705 --> 00:39:43,705
yang baru saja dijelaskan.

725
00:39:47,520 --> 00:39:51,440
Dan yang akan saya lakukan adalah menambah
gerbang [? XNOR ?]

726
00:39:51,440 --> 00:39:55,240
kecil, yang merupakan gerbang
parity, terhadap salah satu masukannya.

727
00:39:55,240 --> 00:39:56,830
Jadi Anda mempunyai a dan b di sini.

728
00:39:56,830 --> 00:40:01,010
Jadi saya telah mengambil x1, dan
saya mempunyai a dan b di sini.

729
00:40:01,010 --> 00:40:04,560
Jadi saya telah menambahkan-- saya dapat
menambahkan masukan sebanyak

730
00:40:04,560 --> 00:40:06,190
yang saya inginkan untuk fungsi ini.

731
00:40:06,190 --> 00:40:08,830
Oh omong-omong saya
sebaiknya mengatakan, h(x)

732
00:40:08,830 --> 00:40:11,290
berfungsi pada string-string acak.

733
00:40:11,290 --> 00:40:13,630
Dan tentunya saya
memasukkan suatu angka

734
00:40:13,630 --> 00:40:16,774
di sini yang berhubungan dengan
n, yang merupakan angka yang tidak berubah.

735
00:40:16,774 --> 00:40:19,190
Jadi Anda mungkin bertanya, apa
yang terjadi di sini yang berkaitan

736
00:40:19,190 --> 00:40:20,610
terhadap string-string acak?

737
00:40:20,610 --> 00:40:22,570
Dan ada dua jawaban.

738
00:40:22,570 --> 00:40:25,000
Jawaban pertama adalah,
yah, abaikan keacakan.

739
00:40:25,000 --> 00:40:27,350
Dan asumsikan bahwa Anda
hanya mempunyai string-string n-bit.

740
00:40:27,350 --> 00:40:29,370
Dan n ini merupakan angka
yang sangat besar, benar?

741
00:40:29,370 --> 00:40:31,500
Dan hal itu mungkin tidak
terlalu memuaskan.

742
00:40:31,500 --> 00:40:34,220
Jawaban lainnya adalah,
yang lebih praktis,

743
00:40:34,220 --> 00:40:35,850
yang merupakan hal yang
digunakan dalam praktik,

744
00:40:35,850 --> 00:40:38,140
adalah biasanya
apa yang terjadi adalah,

745
00:40:38,140 --> 00:40:41,000
Anda memiliki
implementasi tertentu

746
00:40:41,000 --> 00:40:43,180
dari fungsi-fungsi hash yang
jelas perlu memiliki

747
00:40:43,180 --> 00:40:46,440
masukan-masukan tetap, n, sebagai contoh.

748
00:40:46,440 --> 00:40:48,110
Dan n biasanya 512.

749
00:40:48,110 --> 00:40:49,680
Itu biasanya adalah ukuran bloknya.

750
00:40:49,680 --> 00:40:52,940
Dan Anda potong inputnya sampai
menjadi 5 blok 12-bit.

751
00:40:52,940 --> 00:40:54,770
Dan biasanya apa
yang Anda lakukan adalah, Anda

752
00:40:54,770 --> 00:40:57,800
pilih 5 blok 12 bit pertama,
hitung fungsi hash-nya.

753
00:40:57,800 --> 00:41:02,280
Dan kemudian Anda dapat melakukannya
untuk blok-blok sisanya.

754
00:41:02,280 --> 00:41:04,530
Dan kemudian Anda dapat hash
mereka semua bersamaan, benar?

755
00:41:04,530 --> 00:41:06,872
Jadi biasanya ada
pemanggilan-pemanggilan lebih.

756
00:41:06,872 --> 00:41:08,330
Saya tidak terlalu ingin
membahasnya lebih dalam.

757
00:41:08,330 --> 00:41:11,370
Tapi biasanya ada
pemanggilan-pemanggilan lebih dari h

758
00:41:11,370 --> 00:41:15,600
ketika inputnya akan menjadi 2 kali
n, atau 3 kali n, baik?

759
00:41:15,600 --> 00:41:17,410
Jadi kita tidak perlu
melihat ke sana

760
00:41:17,410 --> 00:41:18,960
untuk tujuan dari
perkuliahan ini.

761
00:41:18,960 --> 00:41:20,270
Tapi ingatlah hal itu.

762
00:41:20,270 --> 00:41:23,750
Jadi kita masih tetap dengan
kebutuhan string acak.

763
00:41:23,750 --> 00:41:26,410
Jadi setelah mengatakan itu,
lihatlah gambar ini.

764
00:41:26,410 --> 00:41:30,190
Dan lihat apa yang
diimplikasikan oleh gambar ini.

765
00:41:30,190 --> 00:41:33,340
Saya punya sebuah h aksen yang
sudah saya bangun, benar?

766
00:41:33,340 --> 00:41:36,720
Sekarang jika saya lihat h
aksen, dan saya berikan Anda

767
00:41:36,720 --> 00:41:40,270
sebuah keluaran untuk h aksen--
jadi h aksen sekarang memiliki,

768
00:41:40,270 --> 00:41:45,640
itu sebuah fungsi dari a dan b, dan
x2 hingga xn, benar?

769
00:41:45,640 --> 00:41:47,850
Jadi dia memiliki masukan tambahan.

770
00:41:47,850 --> 00:41:50,630
Jika saya melihat h aksen, dan saya melihat
pada keluaran dari h aksen yang

771
00:41:50,630 --> 00:41:56,280
diberikan kepada saya, dan saya
harus menemukan sesuatu yang

772
00:41:56,280 --> 00:42:00,280
menghasilkan hal itu, ini cukup
jelas bahwa saya perlu mencari tahu

773
00:42:00,280 --> 00:42:03,400
apa nilai-nilai ini,
OK?

774
00:42:03,400 --> 00:42:06,930
Dan saya harus tahu apa
parity dari a dan b.

775
00:42:06,930 --> 00:42:09,293
Dan mungkin saya tidak perlu
tahu persis apa itu a dan b,

776
00:42:09,293 --> 00:42:11,626
tapi saya benar-benar perlu tahu
apa parity dari a dan b,

777
00:42:11,626 --> 00:42:13,230
karena itu adalah x1.

778
00:42:13,230 --> 00:42:15,490
Dan satu arah yang saya
rusak akan membutuhkan

779
00:42:15,490 --> 00:42:17,670
saya untuk memberitahu Anda
apa nilai dari x1,

780
00:42:17,670 --> 00:42:20,070
dan nilai dari x2,
dan selanjutnya.

781
00:42:20,070 --> 00:42:23,640
Jadi cukup jelas bahwa
h aksen itu satu arah, benar?

782
00:42:23,640 --> 00:42:25,520
Semuanya mengerti?

783
00:42:25,520 --> 00:42:28,870
h aksen adalah satu arah.

784
00:42:28,870 --> 00:42:30,160
Tapi tahukah Anda?

785
00:42:30,160 --> 00:42:33,860
Saya punya collision
terarah yang berlimpah, benar?

786
00:42:33,860 --> 00:42:37,360
Yang harus saya lakukan adalah membalik-- Saya
memiliki a sama dengan 1 dan b sama dengan 1.

787
00:42:37,360 --> 00:42:39,770
Dan saya memiliki yang a sama dengan
0 dan b sama dengan 0.

788
00:42:39,770 --> 00:42:42,350
Mereka akan memberi
saya hash yang sama, benar?

789
00:42:42,350 --> 00:42:45,690
Jadi contoh sepele,
tapi itu sampai

790
00:42:45,690 --> 00:42:50,070
pada inti dari perbedaan
antara collision resistance

791
00:42:50,070 --> 00:42:52,290
dan ke-satu-arah-an,
target collision resistance

792
00:42:52,290 --> 00:42:54,210
and ke-satu-arah-an, OK?

793
00:42:54,210 --> 00:43:03,710
Jadi ini satu-arah tapi bukan TCR,
hanya karena a sama dengan 0, b

794
00:43:03,710 --> 00:43:06,500
sama dengan 0 untuk
nilai-nilai x acak menghasilkan

795
00:43:06,500 --> 00:43:11,200
hal yang sama ketika a sama dengan
1 dan b sama dengan 1, benar?

796
00:43:11,200 --> 00:43:13,940
Jadi itulah collision.

797
00:43:13,940 --> 00:43:15,690
Jadi memang dibuat-buat.

798
00:43:15,690 --> 00:43:19,350
Tapi itu contohnya.

799
00:43:19,350 --> 00:43:21,150
Contoh
dapat dibuat-buat.

800
00:43:21,150 --> 00:43:23,510
Tidak apa-apa.

801
00:43:23,510 --> 00:43:24,710
Baiklah.

802
00:43:24,710 --> 00:43:28,470
Jadi tadi adalah apa
yang terjadi dengan hal itu.

803
00:43:28,470 --> 00:43:32,400
Mari lihat satu
hal lagi yang menarik

804
00:43:32,400 --> 00:43:36,150
yang berhubungan dengan
cara lain, OK?

805
00:43:36,150 --> 00:43:46,030
Jadi hal yang ingin saya tunujukkan adalah
sebuah TCR tidak berarti ke-satu-arah-an.

806
00:43:59,040 --> 00:44:03,122
OK, jadi sekarang saya ingin memberikan
contoh dimana terlihat jelas

807
00:44:03,122 --> 00:44:05,580
bahwa saya mempunyai ketahanan terhadap
collision terarah, karena saya hanya bisa

808
00:44:05,580 --> 00:44:06,370
mengasumsikan hal tersebut.

809
00:44:06,370 --> 00:44:08,310
Dan kita akan 
menggunakan strategi yang sama.

810
00:44:08,310 --> 00:44:10,550
Saya hanya akan mengasumsikan
bahwa saya memiliki sebuah h yang

811
00:44:10,550 --> 00:44:12,240
target collision resistant.

812
00:44:12,240 --> 00:44:16,250
Dan saya akan mencoba dan membuat
sebuah h aksen yang tidak satu arah.

813
00:44:16,250 --> 00:44:21,080
Jadi saya akan berasumsi bahwa
faktanya h adalah TCR dan OW.

814
00:44:21,080 --> 00:44:24,420
Dan saya akan mengambil
salah satu propertinya.

815
00:44:24,420 --> 00:44:26,060
Dan jika saya ambil salah
satu propertinya

816
00:44:26,060 --> 00:44:28,350
Saya mendapatkan sebuah contoh, benar?

817
00:44:28,350 --> 00:44:34,320
Jadi pikirkan bagaimana
Anda dapat melakukan hal ini.

818
00:44:34,320 --> 00:44:38,355
Anda memiliki h seperti sebelumnya.

819
00:44:41,920 --> 00:44:46,330
Dan saya ingin menambahkan
beberapa hal di sekitarnya

820
00:44:46,330 --> 00:44:52,820
agar dia dapat ditemukan
dengan mudah-- untuk sebagian besar,

821
00:44:52,820 --> 00:44:55,610
untuk sebagian hash
yang tetap

822
00:44:55,610 --> 00:44:58,430
yang telah saya berikan ke diri saya sendiri,
bukan hanya hash biasa saja.

823
00:44:58,430 --> 00:45:01,000
Karena Anda selalu bisa
menyatakan bahwa ke-satu-arah-an

824
00:45:01,000 --> 00:45:06,360
rusak dengan mengatakan saya memiliki
x, saya menghitung h(x), sekarang

825
00:45:06,360 --> 00:45:09,780
saya mengetahui apa-- diberikannya h(x)
saya tahu apa nilai x.

826
00:45:09,780 --> 00:45:11,970
Maksud saya Anda tidak dapat melakukan hal itu, benar?

827
00:45:11,970 --> 00:45:14,360
Jadi itu tidak merusak
sifat ke-satu-arah-an.

828
00:45:14,360 --> 00:45:16,420
Ketika Anda memiliki
sebuah h(x) dan ini

829
00:45:16,420 --> 00:45:18,250
adalah pertama kali
Anda melihatnya,

830
00:45:18,250 --> 00:45:20,660
Anda mencoba untuk mencari
apa itu x, benar?

831
00:45:20,660 --> 00:45:23,370
Jadi bagaimana Anda-- bagaimana
Anda akan menyiapkannya

832
00:45:23,370 --> 00:45:28,230
agar Anda merusak
ke-satu-arah-an dari h

833
00:45:28,230 --> 00:45:31,310
tanpa harus merusak
target collision

834
00:45:31,310 --> 00:45:37,430
resistance dari keseluruhan fungsi
hash yang Anda buat?

835
00:45:37,430 --> 00:45:41,339
Dan Anda harus melakukan sesuatu
dengan keluarannya, OK?

836
00:45:41,339 --> 00:45:42,380
Anda harus melakukan sesuatu.

837
00:45:42,380 --> 00:45:43,671
Hal ini sedikit lebih sulit.

838
00:45:43,671 --> 00:45:45,734
Itu tidak semudah
contoh ini.

839
00:45:45,734 --> 00:45:46,900
Itu sedikit lebih terlibat.

840
00:45:46,900 --> 00:45:47,920
Tapi ada ide?

841
00:45:51,240 --> 00:45:52,761
Ya, silakan.

842
00:45:52,761 --> 00:45:55,707
AUDIENS: Jadi x kurang
dari b kembalikan x.

843
00:45:55,707 --> 00:45:57,964
Jika x lebih besar dari
b, kembalikan [TIDAK TERDENGAR]

844
00:45:57,964 --> 00:45:59,130
SRINIVAS DEVADAS: Indah sekali.

845
00:45:59,130 --> 00:45:59,460
Benar.

846
00:45:59,460 --> 00:46:00,970
Warna apa yang Anda
dapatkan sebelumnya?

847
00:46:00,970 --> 00:46:02,150
AUDIENS: Biru.

848
00:46:02,150 --> 00:46:03,050
SRINIVAS DEVADAS: Anda
dapat biru sebelumnya?

849
00:46:03,050 --> 00:46:03,800
Baiklah

850
00:46:03,800 --> 00:46:04,890
Ya Anda dapat ungu.

851
00:46:04,890 --> 00:46:06,190
Anda memiliki sebuah set.

852
00:46:06,190 --> 00:46:09,220
Sebenarnya kita mempunyai yang merah ini
yang berharga, yang--

853
00:46:09,220 --> 00:46:12,780
tidak, kita tidak punya.

854
00:46:12,780 --> 00:46:14,479
Kita memutuskan untuk tidak membuat merah.

855
00:46:14,479 --> 00:46:15,020
Saya tidak tahu.

856
00:46:15,020 --> 00:46:17,370
Ada suatu pesan
bawah sadar

857
00:46:17,370 --> 00:46:20,750
saya rasa dengan melempar
Frisbee merah yang tidak kita sukai.

858
00:46:20,750 --> 00:46:21,380
Tapi OK.

859
00:46:21,380 --> 00:46:22,550
Jadi terima kasih.

860
00:46:22,550 --> 00:46:33,260
Dan secara sederhana h(x)
adalah sesuatu di mana

861
00:46:33,260 --> 00:46:37,360
Saya akan menyambungkan
sebuah nol ke nilai x.

862
00:46:37,360 --> 00:46:38,660
dan menaruhnya begitu saja.

863
00:46:38,660 --> 00:46:40,810
Dan jelas ini
merusak ke-satu-arah-an

864
00:46:40,810 --> 00:46:43,610
karena saya hanya mengambil
masukannya, saya menambahkan sebuah nol terhadapnya,

865
00:46:43,610 --> 00:46:44,730
dan mengeluarkannya.

866
00:46:44,730 --> 00:46:46,900
Jadi ini akan menjadi mudah
untuk mundur, benar?

867
00:46:46,900 --> 00:46:53,500
Dan ini hanya terjadi
jika x kurang dari n,

868
00:46:53,500 --> 00:46:55,460
seperti yang dikatakan pria itu.

869
00:46:55,460 --> 00:47:00,220
Kurang dari atau sama dengan n dalam
arti panjang masukannya, OK?

870
00:47:00,220 --> 00:47:03,131
Jika tidak saya
akan melakukan h(x).

871
00:47:08,270 --> 00:47:10,160
Jadi ini berita bagus.

872
00:47:10,160 --> 00:47:15,400
Karena sebenarnya saya menggunakan
fungsi hash dalam kasus

873
00:47:15,400 --> 00:47:17,890
di mana saya punya sebuah
masukan string yang lebih panjang.

874
00:47:17,890 --> 00:47:20,660
Ini berita buruk untuk
ke-satu-arah-an karena saya hanya

875
00:47:20,660 --> 00:47:23,010
meneruskan masukannya.

876
00:47:23,010 --> 00:47:30,927
Dan jadi jika saya mendapatkan sebuah x, dan saya
melihat apakah x tersebut ada di luar sini,

877
00:47:30,927 --> 00:47:32,510
dan mari katakan
demi argumen

878
00:47:32,510 --> 00:47:38,480
tersebut-- Anda bisa
katakan bahwa n

879
00:47:38,480 --> 00:47:43,330
akan menjadi sesuatu 
yang kurang dari d,

880
00:47:43,330 --> 00:47:46,210
yang merupakan keluaran
terakhir, yang memiliki d-bit.

881
00:47:46,210 --> 00:47:49,090
Jadi jika Anda melihat sesuatu
yang dihasilkan h aksen

882
00:47:49,090 --> 00:47:51,450
yang kurang dari
d-bit Anda langsung

883
00:47:51,450 --> 00:47:54,030
tahu bahwa Anda dapat
mundur dan menemukan

884
00:47:54,030 --> 00:47:57,186
masukan apa yang menghasilkan
hal tersebut untuk h aksen, benar?

885
00:47:57,186 --> 00:47:59,060
Karena Anda hanya pergi
dan Anda mundur.

886
00:47:59,060 --> 00:48:00,350
Inilah yang diberitahu kepada Anda.

887
00:48:00,350 --> 00:48:01,850
Sekarang di sisi lain
jika dia lebih besar

888
00:48:01,850 --> 00:48:03,160
jelas Anda tidak bisa melakukan hal itu.

889
00:48:03,160 --> 00:48:06,770
Tapi ada
banyak kombinasi

890
00:48:06,770 --> 00:48:08,100
yang dapat Anda lakukan untuk hal itu.

891
00:48:08,100 --> 00:48:11,300
Jadi ini merusak ke-satu-arah-an, OK?

892
00:48:11,300 --> 00:48:13,074
Sekarang Anda pikirkan tentang TCR.

893
00:48:13,074 --> 00:48:14,490
Dan hal yang Anda inginkan
tunjukkan tentu saja

894
00:48:14,490 --> 00:48:17,570
adalah hal ini mempertahankan TCR.

895
00:48:17,570 --> 00:48:20,622
Jadi itu adalah hal terakhir
yang harus kita tunjukkan.

896
00:48:20,622 --> 00:48:22,080
Kita tahu bahwa hal ini
merusak ke-satu-arah-an.

897
00:48:22,080 --> 00:48:25,182
Tetapi jika hal ini merusak TCR, kita belum
memiliki contoh kita.

898
00:48:25,182 --> 00:48:26,640
Jadi kita ingin menunjukkan
bahwa hal ini sebenarnya

899
00:48:26,640 --> 00:48:31,220
mempertahankan TCR, yang merupakan
sejenis properti lemah

900
00:48:31,220 --> 00:48:33,440
yang perlu kita pertahankan.

901
00:48:33,440 --> 00:48:35,890
Dan alasan hal
ini mempertahankan TCR

902
00:48:35,890 --> 00:48:39,290
adalah jelas bahwa hanya ada
dua kasus di sini,

903
00:48:39,290 --> 00:48:41,720
sesuai dengan
pernyataan if tersebut.

904
00:48:41,720 --> 00:48:49,280
Dan cukup jelas bahwa jika
x kurang dari atau sama dengan n,

905
00:48:49,280 --> 00:49:03,520
jelas nilai-nilai x yang berbeda akan menghasilkan
nilai-nilai h'(x) yang berbeda, benar?

906
00:49:03,520 --> 00:49:06,620
Karena saya hanya meneruskan
nilai x hingga menjadi keluaran.

907
00:49:06,620 --> 00:49:09,730
Jadi jika x kurang dari n saya
akan mendapatkan hash-hash yang berbeda

908
00:49:09,730 --> 00:49:10,570
pada keluarannya.

909
00:49:10,570 --> 00:49:12,350
Saya hanya menyalurkannya.

910
00:49:12,350 --> 00:49:13,940
Jadi itu mudah.

911
00:49:13,940 --> 00:49:17,490
Dan untuk kasus lainnya,
saya berasumsi bahwa h(x)

912
00:49:17,490 --> 00:49:20,129
adalah CCR, benar?

913
00:49:20,129 --> 00:49:22,420
Karena itu adalah asumsi 
awalnya, bahwa saya mempunyai h,

914
00:49:22,420 --> 00:49:23,540
yang CCR.

915
00:49:23,540 --> 00:49:30,690
Jadi dalam kedua kasus TCR
dipertahankan karena lainnya h(x)

916
00:49:30,690 --> 00:49:38,350
mempertahankan TCR, OK?

917
00:49:38,350 --> 00:49:41,284
Jadi sekali lagi, sedikit
contoh yang dibuat-buat

918
00:49:41,284 --> 00:49:42,700
untuk menunjukkan kepada Anda
perbedaan antara

919
00:49:42,700 --> 00:49:45,510
properti-properti yang berbeda ini sehingga
Anda tahu untuk tidak mencampur mereka.

920
00:49:45,510 --> 00:49:47,630
Anda tahu apa yang
ingin Anda minta,

921
00:49:47,630 --> 00:49:51,150
hal yang dibutuhkan
ketika Anda benar-benar

922
00:49:51,150 --> 00:49:53,870
mengimplementasikan sebuah
aplikasi yang bergantung

923
00:49:53,870 --> 00:49:56,000
pada properti-properti tertentu.

924
00:49:56,000 --> 00:49:57,230
OK?

925
00:49:57,230 --> 00:49:59,010
Ada pertanyaan sejauh ini
mengenai properti-properti

926
00:49:59,010 --> 00:50:01,040
atau salah satu contoh ini?

927
00:50:01,040 --> 00:50:03,227
Kita akan membahas
penggunaan mereka.

928
00:50:06,970 --> 00:50:08,510
OK.

929
00:50:08,510 --> 00:50:12,170
Jadi mulai memikirkan
keamanan komputer.

930
00:50:12,170 --> 00:50:18,090
Mulai pikirkan para peretas,
melindungi diri Anda

931
00:50:18,090 --> 00:50:20,655
dari orang-orang jahat
di luar sana yang

932
00:50:20,655 --> 00:50:22,640
mencoba untuk mengetahui
kata sandi Anda,

933
00:50:22,640 --> 00:50:24,924
mencoba untuk merusak
berkas-berkas Anda, secara umum

934
00:50:24,924 --> 00:50:25,965
membuat hidup Anda sengsara.

935
00:50:32,880 --> 00:50:38,880
Dan kita akan mulai dengan
contoh-contoh yang sederhana, di mana

936
00:50:38,880 --> 00:50:41,730
properti-propertinya
cukup jelas,

937
00:50:41,730 --> 00:50:46,205
dan meningkat hingga contoh
penawaran lelang ini yang

938
00:50:46,205 --> 00:50:48,080
seharusnya seperti
puncak dari setidaknya

939
00:50:48,080 --> 00:50:50,120
perkuliahan bagian ini.

940
00:50:50,120 --> 00:50:52,470
Dan bergantung pada berapa
banyak waktu yang saya miliki

941
00:50:52,470 --> 00:50:54,800
saya akan memberitahu Anda
sedikit mengenai bagaimana

942
00:50:54,800 --> 00:50:56,730
cara mengimplementasikan fungsi-fungsi hash.

943
00:50:56,730 --> 00:50:59,640
Tapi saya pikir
hal-hal ini lebih

944
00:50:59,640 --> 00:51:03,580
penting dari sudut pandang
yang memberikan Anda

945
00:51:03,580 --> 00:51:08,610
sebuah gambaran dari hash kriptografik.

946
00:51:08,610 --> 00:51:10,380
Baiklah.

947
00:51:10,380 --> 00:51:11,970
Penyimpanan kata sandi.

948
00:51:11,970 --> 00:51:16,730
Berapa banyak dari Anda menulis
kata sandi Anda di sebuah berkas

949
00:51:16,730 --> 00:51:22,230
tidak terenkripsi dan menyimpannya di
sebuah tempat yang dapat dibaca?

950
00:51:22,230 --> 00:51:24,380
Itu dia.

951
00:51:24,380 --> 00:51:27,390
Terima kasih sudah jujur.

952
00:51:27,390 --> 00:51:29,550
Dan saya melakukan yang lebih parah.

953
00:51:29,550 --> 00:51:32,610
Saya bukan hanya melakukan itu, saya
menggunakan nama anak perempuan pertama saya

954
00:51:32,610 --> 00:51:35,334
untuk empat kata sandi saya.

955
00:51:35,334 --> 00:51:36,750
Saya tidak akan memberitahu
Anda namanya.

956
00:51:41,350 --> 00:51:43,470
Jadi itu sesuatu yang ingin
kita perbaiki, benar?

957
00:51:43,470 --> 00:51:45,500
Jadi apa yang dilakukan sistem-sistem nyata?

958
00:51:45,500 --> 00:51:49,530
Sistem-sistem nyata tidak dapat melarang
saya untuk menggunakan nama

959
00:51:49,530 --> 00:51:51,400
anak perempuan pertama saya sebagai
kata sandi saya, benar?

960
00:51:51,400 --> 00:51:53,580
Jadi tidak ada cara Anda dapat
berlindung dari hal itu.

961
00:51:53,580 --> 00:51:56,830
Tapi jika saya memiliki sebuah
kata sandi masuk akal, yang

962
00:51:56,830 --> 00:51:59,030
memiliki entropi yang
masuk akal di dalamnya-- jadi

963
00:51:59,030 --> 00:52:01,344
mari asumsikan di sini bahwa kita
memiliki entropi yang masuk akal

964
00:52:01,344 --> 00:52:02,010
dalam kata sandi tersebut.

965
00:52:02,010 --> 00:52:04,000
Dan Anda dapat katakan saja 128-bit.

966
00:52:04,000 --> 00:52:05,240
Dan hal itu tidak banyak, benar?

967
00:52:05,240 --> 00:52:09,135
128-bit adalah 16 karakter, OK?

968
00:52:09,135 --> 00:52:11,260
Dan Anda tidak harus menjawab
ini-- berapa banyak dari kalian

969
00:52:11,260 --> 00:52:15,390
memiliki 16 karakter
dalam kata sandi kalian?

970
00:52:15,390 --> 00:52:16,710
Oh saya kagum.

971
00:52:16,710 --> 00:52:17,350
OK.

972
00:52:17,350 --> 00:52:18,980
Jadi Anda memiliki
entropi 128-bit.

973
00:52:18,980 --> 00:52:21,710
Tapi untuk kalian yang lain, lupakan.

974
00:52:21,710 --> 00:52:25,040
Hal ini tidak akan
membantu Anda, OK?

975
00:52:25,040 --> 00:52:28,140
Tapi hal yang saya inginkan,
mengasumsikan Anda memiliki

976
00:52:28,140 --> 00:52:31,830
entropi signifikan pada kata sandi
Anda-- karena jika tidak,

977
00:52:31,830 --> 00:52:33,940
jika tidak ada entropi
yang cukup Anda

978
00:52:33,940 --> 00:52:38,272
dapat menghitung semua kemungkinan
kata sandi yang terdiri dari delapan huruf.

979
00:52:38,272 --> 00:52:39,230
Dan hal itu tidak terlalu banyak.

980
00:52:39,230 --> 00:52:41,391
Hal tersebut merupakan 2 pangkat
50, mirip seperti itu.

981
00:52:41,391 --> 00:52:42,390
Dan Anda dapat lanjutkan terus.

982
00:52:42,390 --> 00:52:44,150
Dan tak satupun dari
properti-properti ini berarti.

983
00:52:44,150 --> 00:52:45,810
Anda hanya-- Anda hanya memiliki h(x) Anda.

984
00:52:45,810 --> 00:52:48,206
Hal ini publik.

985
00:52:48,206 --> 00:52:50,080
Kita akan membahas tentang cara kita
menggunakan hal tersebut sebentar lagi.

986
00:52:50,080 --> 00:52:53,350
Tapi jelas jika
domainnya kecil

987
00:52:53,350 --> 00:52:55,120
Anda bisa sekedar
enumerate the domain.

988
00:52:55,120 --> 00:52:57,062
Jadi itu perlu diingat.

989
00:52:57,062 --> 00:52:58,770
I talked about h of
x, and it's obviously

990
00:52:58,770 --> 00:53:00,300
going to be relevant here.

991
00:53:00,300 --> 00:53:02,520
But suppose I wanted
to build a system,

992
00:53:02,520 --> 00:53:04,300
and this is how
systems are built,

993
00:53:04,300 --> 00:53:06,700
ETC slash password
file, assuming

994
00:53:06,700 --> 00:53:11,040
you have long passwords
it does it this way,

995
00:53:11,040 --> 00:53:13,320
otherwise it needs something
that's called a salt.

996
00:53:13,320 --> 00:53:16,540
But that's 6, 8, 57
and we won't go there.

997
00:53:16,540 --> 00:53:19,590
So we just assume
a large entropy.

998
00:53:19,590 --> 00:53:21,980
What is it that a system can do?

999
00:53:21,980 --> 00:53:26,210
What can it store in order
to let you in, and only

1000
00:53:26,210 --> 00:53:28,830
let you in when you
type your password,

1001
00:53:28,830 --> 00:53:32,190
and not let some bogus
password into the system?

1002
00:53:32,190 --> 00:53:34,610
Or somebody with a bogus
password into the system.

1003
00:53:34,610 --> 00:53:35,249
Yeah, go ahead.

1004
00:53:35,249 --> 00:53:37,540
AUDIENCE: If you capture the
password when you enter it

1005
00:53:37,540 --> 00:53:39,380
and compare it to
what's stored--

1006
00:53:39,380 --> 00:53:40,347
SRINIVAS DEVADAS: Yes.

1007
00:53:40,347 --> 00:53:42,430
AUDIENCE: If it's a one-way
hash you know you have

1008
00:53:42,430 --> 00:53:42,730
what the correct password is.

1009
00:53:42,730 --> 00:53:43,820
SRINIVAS DEVADAS:
That's exactly right.

1010
00:53:43,820 --> 00:53:44,790
That's exactly right.

1011
00:53:44,790 --> 00:53:49,950
So it's a really simple
idea, a very powerful idea.

1012
00:53:49,950 --> 00:53:54,610
It, as I said, assumed that the
entropy-- and I'm belaboring

1013
00:53:54,610 --> 00:53:56,890
the obvious now--
but it is important

1014
00:53:56,890 --> 00:53:59,890
when you talk about security
to state your assumptions.

1015
00:53:59,890 --> 00:54:04,380
But you do not store
password on your computer.

1016
00:54:04,380 --> 00:54:06,940
And you store the
hash of the password.

1017
00:54:06,940 --> 00:54:09,530
Now why do I store my
password on the computer?

1018
00:54:09,530 --> 00:54:12,200
Because this is so
inconvenient, right?

1019
00:54:12,200 --> 00:54:15,180
So this is what the
system does for me.

1020
00:54:15,180 --> 00:54:18,110
But the fact of the matter
is, if I lose my password,

1021
00:54:18,110 --> 00:54:19,470
this doesn't help me.

1022
00:54:19,470 --> 00:54:24,050
Because what the system wants
you to do is choose a password

1023
00:54:24,050 --> 00:54:26,720
that is long enough,
and the h is one-way.

1024
00:54:26,720 --> 00:54:30,960
So anybody who discovers h of
PW that is publicly readable

1025
00:54:30,960 --> 00:54:33,840
cannot discover PW, all right?

1026
00:54:33,840 --> 00:54:36,420
That's what's cool about this.

1027
00:54:36,420 --> 00:54:38,740
How do you let
the person log in?

1028
00:54:38,740 --> 00:54:47,860
Use h of PW to compare
against h of PW prime,

1029
00:54:47,860 --> 00:54:54,420
which is what is entered, where
PW prime is the typed password.

1030
00:55:00,540 --> 00:55:08,530
And clearly what we need is
the disclosure of h of PW

1031
00:55:08,530 --> 00:55:14,960
should not reveal PW.

1032
00:55:14,960 --> 00:55:19,570
So we definitely
need one-wayness.

1033
00:55:19,570 --> 00:55:24,370
What about-- what about
collision resistance?

1034
00:55:24,370 --> 00:55:28,340
Our target collision resistance?

1035
00:55:28,340 --> 00:55:31,350
Think practitioner now, right?

1036
00:55:31,350 --> 00:55:33,590
Are we interested in
this hash function

1037
00:55:33,590 --> 00:55:34,880
being collision resistant?

1038
00:55:34,880 --> 00:55:37,150
What does that
mean in this case?

1039
00:55:37,150 --> 00:55:40,315
Give me the context in this
particular application?

1040
00:55:40,315 --> 00:55:40,940
Yeah, go ahead.

1041
00:55:40,940 --> 00:55:44,860
AUDIENCE: It means that someone
entering a different password

1042
00:55:44,860 --> 00:55:47,107
will have the same
hash [INAUDIBLE].

1043
00:55:47,107 --> 00:55:48,190
SRINIVAS DEVADAS: Exactly.

1044
00:55:48,190 --> 00:55:56,600
So it means that what you have
is a situation where you do not

1045
00:55:56,600 --> 00:56:00,900
reveal-- and so what might
happen is that h of PW prime

1046
00:56:00,900 --> 00:56:02,460
equals h of PW.

1047
00:56:02,460 --> 00:56:07,190
But h of PW equals
h of PW prime.

1048
00:56:07,190 --> 00:56:11,490
But PW is not equal to PW prime.

1049
00:56:11,490 --> 00:56:13,950
What you have is
a false positive.

1050
00:56:13,950 --> 00:56:15,570
Someone who didn't
know your password

1051
00:56:15,570 --> 00:56:19,060
but guessed right-- and
this is a 128-bit value,

1052
00:56:19,060 --> 00:56:22,840
and they guessed right--
is going to get it.

1053
00:56:22,840 --> 00:56:24,940
You don't particularly
care of the probability

1054
00:56:24,940 --> 00:56:26,190
of this occurrence.

1055
00:56:26,190 --> 00:56:27,900
It's really small.

1056
00:56:27,900 --> 00:56:30,570
Typically you're going to
have systems that lock you out

1057
00:56:30,570 --> 00:56:34,770
if you try 10 tries that occurs
one, two, wrong passwords,

1058
00:56:34,770 --> 00:56:35,270
right?

1059
00:56:35,270 --> 00:56:37,965
So really in systems
you do not require--

1060
00:56:37,965 --> 00:56:39,340
you do want to
build systems that

1061
00:56:39,340 --> 00:56:42,090
have minimal
properties with respect

1062
00:56:42,090 --> 00:56:43,570
to the perimeters that are used.

1063
00:56:43,570 --> 00:56:47,090
So from a system building
standpoint just require OW.

1064
00:56:47,090 --> 00:56:48,350
Don't go overboard.

1065
00:56:48,350 --> 00:56:53,100
Don't require collision
resistance or TCR, OK?

1066
00:56:53,100 --> 00:56:55,420
Let's do a slightly
different example.

1067
00:56:55,420 --> 00:56:59,010
Also a bit of a
warm-up for what's

1068
00:56:59,010 --> 00:57:01,895
coming next, which is a
file modification detector.

1069
00:57:22,080 --> 00:57:32,800
So for each file F, I'm going to
store h of F. And as securely.

1070
00:57:32,800 --> 00:57:36,980
So you assume that this means
that h of F cannot be modified

1071
00:57:36,980 --> 00:57:40,380
by anybody, h of F itself.

1072
00:57:47,860 --> 00:57:56,030
And now we want to
check if F is modified

1073
00:57:56,030 --> 00:58:04,470
by re-computing h of
F. Which could be,

1074
00:58:04,470 --> 00:58:05,640
this could be modified.

1075
00:58:05,640 --> 00:58:07,130
So this could
actually be F prime.

1076
00:58:07,130 --> 00:58:09,250
You don't know that.

1077
00:58:09,250 --> 00:58:10,500
You have a file.

1078
00:58:10,500 --> 00:58:11,780
It's a gigabyte.

1079
00:58:11,780 --> 00:58:14,270
And somebody might
have tampered with one

1080
00:58:14,270 --> 00:58:16,030
of the bits in the file.

1081
00:58:16,030 --> 00:58:19,340
All you have is a
d-bit digest that

1082
00:58:19,340 --> 00:58:23,670
corresponds to h of F that you
stored in a secure location.

1083
00:58:23,670 --> 00:58:27,190
And you want to check
to see, by re-computing

1084
00:58:27,190 --> 00:58:31,940
h of F, the file
that is given to you,

1085
00:58:31,940 --> 00:58:34,135
and comparing it with what
you've stored, the h of F

1086
00:58:34,135 --> 00:58:35,730
that you've stored.

1087
00:58:35,730 --> 00:58:42,200
And so what property do we
need in order to pull this off?

1088
00:58:42,200 --> 00:58:44,590
Of hash functions.

1089
00:58:44,590 --> 00:58:48,070
What precisely do we
need to pull this off?

1090
00:58:50,620 --> 00:58:53,040
What is the adversary
trying to do?

1091
00:58:53,040 --> 00:58:55,530
And what is a successful break?

1092
00:58:55,530 --> 00:59:02,000
A successful break is if an
adversary can modify the file

1093
00:59:02,000 --> 00:59:08,720
and keep h of F the same, right?

1094
00:59:08,720 --> 00:59:10,780
That would be a
successful break, right?

1095
00:59:10,780 --> 00:59:13,600
Yup.

1096
00:59:13,600 --> 00:59:14,125
Go ahead.

1097
00:59:14,125 --> 00:59:14,910
AUDIENCE: TCR.

1098
00:59:14,910 --> 00:59:15,550
SRINIVAS DEVADAS: TCR?

1099
00:59:15,550 --> 00:59:16,300
Yeah, absolutely.

1100
00:59:16,300 --> 00:59:16,841
You need TCR.

1101
00:59:19,350 --> 00:59:21,750
So you want to modify the file.

1102
00:59:34,830 --> 00:59:38,230
So you're given that
the file-- the adversary

1103
00:59:38,230 --> 00:59:41,980
is given the file, which
is the input to the hash,

1104
00:59:41,980 --> 00:59:47,550
and is going to try and
modify-- modify the file, right?

1105
00:59:47,550 --> 00:59:51,130
So let's do a couple more.

1106
00:59:51,130 --> 00:59:57,470
And we're going to advance our
requirements here a little bit.

1107
00:59:57,470 --> 01:00:00,891
So those two are
basic properties.

1108
01:00:00,891 --> 01:00:02,140
I want to leave this up there.

1109
01:00:04,937 --> 01:00:06,770
We're going to do
something that corresponds

1110
01:00:06,770 --> 01:00:08,690
to digital signatures.

1111
01:00:08,690 --> 01:00:13,030
So digital signatures are
this wonderful invention

1112
01:00:13,030 --> 01:00:18,290
that came out of MIT in a
computer science laboratory--

1113
01:00:18,290 --> 01:00:23,160
again, Ron Rivest and
collaborators-- which

1114
01:00:23,160 --> 01:00:28,120
are a way of digitally
signing a document using

1115
01:00:28,120 --> 01:00:31,170
a secret key, a private key.

1116
01:00:31,170 --> 01:00:35,660
But anybody who has
access to a public key,

1117
01:00:35,660 --> 01:00:37,210
so it could be
pretty much anybody,

1118
01:00:37,210 --> 01:00:41,647
could verify the authenticity
of that signature, right?

1119
01:00:41,647 --> 01:00:43,230
So that's what a
digital signature is.

1120
01:00:52,490 --> 01:00:55,960
So we're going to talk
about public cryptography

1121
01:00:55,960 --> 01:01:00,730
on Thursday, in terms
of how you could build

1122
01:01:00,730 --> 01:01:06,640
systems or encryption algorithms
that are public key algorithms.

1123
01:01:06,640 --> 01:01:12,470
But here I'll just tell you
what we want out of them.

1124
01:01:12,470 --> 01:01:15,100
Essentially what we have here
in the case of signatures,

1125
01:01:15,100 --> 01:01:18,100
we actually want to talk
about encryption here,

1126
01:01:18,100 --> 01:01:20,180
are-- there's two
keys associated

1127
01:01:20,180 --> 01:01:24,030
with a public key system.

1128
01:01:24,030 --> 01:01:26,880
Anybody and everybody
in the system

1129
01:01:26,880 --> 01:01:31,090
would have a public key that
you can put on your website.

1130
01:01:31,090 --> 01:01:34,500
And you also have a secret key--
that's like your password--

1131
01:01:34,500 --> 01:01:35,930
that you don't
want to write down,

1132
01:01:35,930 --> 01:01:38,221
you don't want to give away,
because that's effectively

1133
01:01:38,221 --> 01:01:39,930
your identity.

1134
01:01:39,930 --> 01:01:44,700
And what digital
signatures respond to

1135
01:01:44,700 --> 01:01:46,880
are that you have
two operations.

1136
01:01:46,880 --> 01:01:51,030
You have signing
and verification.

1137
01:01:51,030 --> 01:01:56,760
So signing means that you
create a signature sigma that

1138
01:01:56,760 --> 01:02:06,420
is the sign using your
private key, your secret key,

1139
01:02:06,420 --> 01:02:10,070
off a message M. So you're
saying this is this message,

1140
01:02:10,070 --> 01:02:12,060
it came from me, right?

1141
01:02:12,060 --> 01:02:13,655
That's what signing means.

1142
01:02:13,655 --> 01:02:16,030
You have this long message
and you sign it at the bottom.

1143
01:02:16,030 --> 01:02:20,620
You're taking responsibility for
the contents of that message.

1144
01:02:20,620 --> 01:02:27,710
And then verification is you
have M sigma and a public key.

1145
01:02:27,710 --> 01:02:31,770
And this is simply going
to output true or false.

1146
01:02:35,780 --> 01:02:42,260
And so the public key should
not reveal any information

1147
01:02:42,260 --> 01:02:43,260
about the secret key.

1148
01:02:48,570 --> 01:02:51,700
And that's the challenge
of building PKI systems,

1149
01:02:51,700 --> 01:02:56,800
that we'll talk about in
some detail next time.

1150
01:02:56,800 --> 01:03:01,440
But we don't need to
think about that other

1151
01:03:01,440 --> 01:03:06,100
than acknowledging it today.

1152
01:03:06,100 --> 01:03:09,680
So the public and private
key are two distinct things,

1153
01:03:09,680 --> 01:03:12,150
neither one of which reveals
anything about the other.

1154
01:03:12,150 --> 01:03:14,430
Think of them as completely
distinct passwords.

1155
01:03:14,430 --> 01:03:16,730
But they happen to be
mathematically related.

1156
01:03:16,730 --> 01:03:18,500
That's why this
whole thing works.

1157
01:03:18,500 --> 01:03:20,260
And that mathematical
relationship

1158
01:03:20,260 --> 01:03:24,750
we'll look at in some
detail on Thursday.

1159
01:03:24,750 --> 01:03:26,920
But having said
that, take a look

1160
01:03:26,920 --> 01:03:29,490
at what this app is
doing for us, right?

1161
01:03:29,490 --> 01:03:31,370
This is a security application.

1162
01:03:31,370 --> 01:03:33,930
And I haven't quite gotten
to hash functions yet.

1163
01:03:33,930 --> 01:03:36,600
But I'll get to it
in just a minute.

1164
01:03:36,600 --> 01:03:39,330
But what I want to do is
emphasize that there's

1165
01:03:39,330 --> 01:03:41,150
two operations going on.

1166
01:03:41,150 --> 01:03:42,760
One of which is a
signature, which

1167
01:03:42,760 --> 01:03:46,050
is a private signature, in the
sense that it's private to me,

1168
01:03:46,050 --> 01:03:47,160
if I'm Alice.

1169
01:03:47,160 --> 01:03:48,500
Or private to Alice.

1170
01:03:48,500 --> 01:03:50,590
And you're using
secret information

1171
01:03:50,590 --> 01:03:52,810
on this public message,
M, because that's

1172
01:03:52,810 --> 01:03:54,690
going to be publicized.

1173
01:03:54,690 --> 01:03:57,580
And you're going to
sign the public message.

1174
01:03:57,580 --> 01:04:01,160
And then anybody in the
world who has access

1175
01:04:01,160 --> 01:04:04,190
to Alice's public key is
going to be able to say,

1176
01:04:04,190 --> 01:04:06,840
oh I'm looking at the signature,
which is a bunch of bits.

1177
01:04:06,840 --> 01:04:09,900
I'm looking at the message,
which is a whole lot of bits.

1178
01:04:09,900 --> 01:04:12,590
And I have this public key,
which is a bunch of bits.

1179
01:04:12,590 --> 01:04:16,150
And I'm going to be
able to tell for sure

1180
01:04:16,150 --> 01:04:19,340
that either Alice
signed this message,

1181
01:04:19,340 --> 01:04:22,560
or Alice did not
sign this message.

1182
01:04:22,560 --> 01:04:26,710
And the assumption
here is that Alice

1183
01:04:26,710 --> 01:04:28,950
kept her private key secret.

1184
01:04:28,950 --> 01:04:30,970
And of course, what
I just wrote there,

1185
01:04:30,970 --> 01:04:33,450
that the public key
does not reveal anything

1186
01:04:33,450 --> 01:04:35,530
about the secret key, OK?

1187
01:04:35,530 --> 01:04:38,350
So that's digital signatures
for you, in a nutshell.

1188
01:04:38,350 --> 01:04:40,990
And when you do MIT
certificates you're

1189
01:04:40,990 --> 01:04:45,130
using digital signatures a la
Rivest-Shamir-Adleman, the RSA

1190
01:04:45,130 --> 01:04:45,900
algorithm.

1191
01:04:45,900 --> 01:04:48,580
So you're using
this all the time,

1192
01:04:48,580 --> 01:04:52,290
when you click on 6.046
links, for example.

1193
01:04:52,290 --> 01:04:56,440
And what happens is M is
typically really large.

1194
01:04:56,440 --> 01:04:58,060
I mean it could
be a file, right?

1195
01:04:58,060 --> 01:04:59,510
It could be a large file.

1196
01:04:59,510 --> 01:05:02,730
And you don't necessarily want
to compute these operations

1197
01:05:02,730 --> 01:05:04,150
on large files.

1198
01:05:04,150 --> 01:05:09,580
So for convenience, what happens
is you end up hashing the file.

1199
01:05:09,580 --> 01:05:22,550
And for large M it's
easier to sign h of M.

1200
01:05:22,550 --> 01:05:29,810
And so replace the M's that
you see here with h of M,

1201
01:05:29,810 --> 01:05:30,720
all right?

1202
01:05:30,720 --> 01:05:38,640
So now that we're given that
we're going to be doing h of M

1203
01:05:38,640 --> 01:05:42,550
in here, think
about what we wanted

1204
01:05:42,550 --> 01:05:45,390
to accomplish with M, right?

1205
01:05:45,390 --> 01:05:48,150
I told you what we wanted
to accomplish with M.

1206
01:05:48,150 --> 01:05:49,360
There's a particular message.

1207
01:05:49,360 --> 01:05:50,190
I'm Alice.

1208
01:05:50,190 --> 01:05:53,850
I'm going to keep my
secret key secret.

1209
01:05:53,850 --> 01:05:57,910
But I want to commit to signing
this message M, all right?

1210
01:05:57,910 --> 01:06:00,330
And I want to make
sure that nobody

1211
01:06:00,330 --> 01:06:05,320
can pretend to be me who
doesn't know my secret key.

1212
01:06:05,320 --> 01:06:07,290
And nobody does.

1213
01:06:07,290 --> 01:06:10,760
So if I'm going to be signing
the hash of the message,

1214
01:06:10,760 --> 01:06:13,930
now it comes down
to today's lecture.

1215
01:06:13,930 --> 01:06:16,680
I'm signing the hash
of the message h of M.

1216
01:06:16,680 --> 01:06:22,120
What property do I require of
h in order for this whole thing

1217
01:06:22,120 --> 01:06:23,640
to work out?

1218
01:06:23,640 --> 01:06:24,636
Yeah, go ahead.

1219
01:06:24,636 --> 01:06:26,540
AUDIENCE: Is it
non-malleability?

1220
01:06:26,540 --> 01:06:28,665
SRINIVAS DEVADAS: Non
malleability, but even before

1221
01:06:28,665 --> 01:06:31,770
that-- suppose-- absolutely,
but non-malleability

1222
01:06:31,770 --> 01:06:36,590
is kind of beyond one of these
properties over on the right.

1223
01:06:36,590 --> 01:06:39,570
You're on the
right track, right?

1224
01:06:39,570 --> 01:06:45,219
So do you want to give
me a different answer?

1225
01:06:45,219 --> 01:06:46,677
You can give me a
different answer.

1226
01:06:46,677 --> 01:06:50,090
AUDIENCE: Oh, I'm not sure.

1227
01:06:50,090 --> 01:06:52,190
SRINIVAS DEVADAS: OK.

1228
01:06:52,190 --> 01:06:52,690
What?

1229
01:06:52,690 --> 01:06:53,898
Yeah, back there.

1230
01:06:53,898 --> 01:06:56,766
AUDIENCE: I think you wanted to
one-way because otherwise you

1231
01:06:56,766 --> 01:07:00,112
could take that signature and
find another message that you

1232
01:07:00,112 --> 01:07:01,080
could credit.

1233
01:07:01,080 --> 01:07:02,740
SRINIVAS DEVADAS: I
can make M public.

1234
01:07:02,740 --> 01:07:05,480
I can make M-- M can be public.

1235
01:07:05,480 --> 01:07:07,060
And h of M is public.

1236
01:07:07,060 --> 01:07:13,570
So one-wayness is not
interesting for this example

1237
01:07:13,570 --> 01:07:14,690
if M is public.

1238
01:07:14,690 --> 01:07:16,690
And we can assume that M
eventually gets public.

1239
01:07:16,690 --> 01:07:18,840
Because that's the message
I'm signing, right?

1240
01:07:18,840 --> 01:07:21,082
I can also put M out.

1241
01:07:21,082 --> 01:07:22,540
So I want the
relationship-- I want

1242
01:07:22,540 --> 01:07:25,760
you to focus on the relationship
between h of M and M

1243
01:07:25,760 --> 01:07:28,720
and tell me what would
break this system.

1244
01:07:28,720 --> 01:07:31,120
And you're on the right track.

1245
01:07:31,120 --> 01:07:31,970
Yeah, go ahead.

1246
01:07:31,970 --> 01:07:32,932
Or way back there.

1247
01:07:32,932 --> 01:07:33,890
Yeah, sorry about that.

1248
01:07:33,890 --> 01:07:35,074
AUDIENCE: TCR.

1249
01:07:35,074 --> 01:07:35,990
SRINIVAS DEVADAS: TCR.

1250
01:07:35,990 --> 01:07:36,780
Why TCR?

1251
01:07:36,780 --> 01:07:37,696
AUDIENCE: [INAUDIBLE].

1252
01:07:46,130 --> 01:07:49,070
SRINIVAS DEVADAS: So I have
M. So what happens here--

1253
01:07:49,070 --> 01:07:51,920
I should write this out.

1254
01:07:51,920 --> 01:08:12,640
I'm given-- as an adversary I
have M and h of M. It is bad

1255
01:08:12,640 --> 01:08:33,010
if Alice signs h of M, but Bob
claims Alice signed M prime.

1256
01:08:33,010 --> 01:08:39,830
Because h of M equals
h of M prime, right?

1257
01:08:39,830 --> 01:08:41,600
That is bad.

1258
01:08:41,600 --> 01:08:44,729
So the M is public--
could you stand up?

1259
01:08:49,229 --> 01:08:50,600
M is given.

1260
01:08:50,600 --> 01:08:53,329
There's a specific
M, and a specific h

1261
01:08:53,329 --> 01:08:56,470
of M in particular,
that has been exposed.

1262
01:08:56,470 --> 01:08:59,620
And h of M is what was
used for the signature.

1263
01:08:59,620 --> 01:09:01,140
So you want to keep
h of M the same.

1264
01:09:01,140 --> 01:09:02,170
It's a specific one.

1265
01:09:02,170 --> 01:09:03,544
So it's not
collision resistance,

1266
01:09:03,544 --> 01:09:05,850
it's target
collision resistance,

1267
01:09:05,850 --> 01:09:07,460
because that's given to you.

1268
01:09:07,460 --> 01:09:09,430
And you want to
keep that the same.

1269
01:09:09,430 --> 01:09:13,600
But you want to claim that oh,
you promised me $10,000, not

1270
01:09:13,600 --> 01:09:15,319
$20, right?

1271
01:09:15,319 --> 01:09:17,899
If you can do that,
you signed saying

1272
01:09:17,899 --> 01:09:22,149
you want to pay $10,000, not
$20, then you've got a problem.

1273
01:09:22,149 --> 01:09:24,160
So your thing is very close.

1274
01:09:24,160 --> 01:09:27,130
It's just that it doesn't need
to be a strong relationship

1275
01:09:27,130 --> 01:09:28,710
between the 10,000 or the 20.

1276
01:09:28,710 --> 01:09:31,000
I mean I give you a
concrete example of that.

1277
01:09:31,000 --> 01:09:33,720
But it could be more,
it could be less.

1278
01:09:33,720 --> 01:09:36,479
Anything that is different
from what you signed,

1279
01:09:36,479 --> 01:09:38,870
be it with the numerical
relationship or not,

1280
01:09:38,870 --> 01:09:43,080
would cause a problem and
break this scheme, all right?

1281
01:09:43,080 --> 01:09:45,260
Are we good?

1282
01:09:45,260 --> 01:09:50,490
All right, one last example,
the most interesting one.

1283
01:09:50,490 --> 01:09:57,250
And as I guessed I'm
probably not going

1284
01:09:57,250 --> 01:10:01,670
to get to saying very much
about how cache functions are

1285
01:10:01,670 --> 01:10:02,250
implemented.

1286
01:10:02,250 --> 01:10:04,041
But maybe I'll spend
a minute or two on it.

1287
01:10:08,770 --> 01:10:12,700
So let's do this example that
has to do with commitments.

1288
01:10:19,260 --> 01:10:20,890
Commitment is important, right?

1289
01:10:20,890 --> 01:10:22,640
You want to commit
to doing things.

1290
01:10:22,640 --> 01:10:24,420
You want to keep your promises.

1291
01:10:24,420 --> 01:10:28,310
And in this case we
have a legal requirement

1292
01:10:28,310 --> 01:10:34,550
that you want to be able to make
people honor their commitments,

1293
01:10:34,550 --> 01:10:37,040
and not weasel their way
out of commitments, right?

1294
01:10:37,040 --> 01:10:39,670
And we want to deal with
this computationally.

1295
01:10:39,670 --> 01:10:42,720
And let's think about auctions.

1296
01:10:42,720 --> 01:10:51,325
So Alice has value x,
e.g. an auction bid.

1297
01:10:54,940 --> 01:11:02,170
Alice computes what
we're going to call

1298
01:11:02,170 --> 01:11:11,500
C of x, which is a commitment
of x, and cements it, right?

1299
01:11:11,500 --> 01:11:26,670
C of x, C of x is-- let's
assume that the auctioneer,

1300
01:11:26,670 --> 01:11:32,470
and perhaps other auctionees
as well, see C of x.

1301
01:11:32,470 --> 01:11:34,770
You have to submit it
to somebody, right?

1302
01:11:34,770 --> 01:11:37,100
So you can assume
that that's exposed.

1303
01:11:37,100 --> 01:11:49,460
And what is going to happen
is, when bidding is over Alice

1304
01:11:49,460 --> 01:11:53,145
is going to open--
so this is-- C

1305
01:11:53,145 --> 01:12:00,069
of x can be thought
of as sealing the bid.

1306
01:12:00,069 --> 01:12:01,110
So that's the commitment.

1307
01:12:01,110 --> 01:12:03,030
You're sealing the--
you're making a bid

1308
01:12:03,030 --> 01:12:04,600
and you're sealing
it in an envelope.

1309
01:12:04,600 --> 01:12:05,650
You've committed to that.

1310
01:12:05,650 --> 01:12:08,110
That's obviously, what
happens in real life

1311
01:12:08,110 --> 01:12:09,740
without cryptography,
but we want

1312
01:12:09,740 --> 01:12:12,300
to do this with cryptography,
with hash functions.

1313
01:12:12,300 --> 01:12:19,250
And so now Alice opens
C of x to reveal x.

1314
01:12:19,250 --> 01:12:25,670
So she has to prove that
in fact x was her bid.

1315
01:12:25,670 --> 01:12:28,580
And that it matches
what she sealed.

1316
01:12:28,580 --> 01:12:31,930
When you open it up, think
about it conceptually

1317
01:12:31,930 --> 01:12:34,660
from a standpoint of
what happens with paper,

1318
01:12:34,660 --> 01:12:38,620
and then we have to think
about this computationally

1319
01:12:38,620 --> 01:12:41,120
and what this implies, right?

1320
01:12:41,120 --> 01:12:43,245
So again I'll do a
little bit of set up.

1321
01:12:43,245 --> 01:12:45,370
And then we have start
talking about the properties

1322
01:12:45,370 --> 01:12:48,997
that we want for this
particular application.

1323
01:12:48,997 --> 01:12:50,580
So there are a bunch
of people who are

1324
01:12:50,580 --> 01:12:54,680
doing bidding for this auction.

1325
01:12:54,680 --> 01:12:56,999
I don't-- I want
to be the first--

1326
01:12:56,999 --> 01:12:58,540
I don't want to
spend a lot of money.

1327
01:12:58,540 --> 01:12:59,560
But I want to win.

1328
01:12:59,560 --> 01:13:01,640
All of us are like that, right?

1329
01:13:01,640 --> 01:13:04,350
If I know information
about your bid,

1330
01:13:04,350 --> 01:13:06,490
that is obviously a
tremendous advantage.

1331
01:13:06,490 --> 01:13:09,110
So clearly that
can't happen, right?

1332
01:13:09,110 --> 01:13:13,000
If I know one other person's
bid I just do plus 1 on that.

1333
01:13:13,000 --> 01:13:16,090
If I know everybody else's I
just do plus 1 on the maximum.

1334
01:13:16,090 --> 01:13:19,420
So clearly there's some secrecy
that's required here, correct?

1335
01:13:19,420 --> 01:13:23,000
So C of x is going to
have to do two things.

1336
01:13:23,000 --> 01:13:26,160
It can't reveal x.

1337
01:13:26,160 --> 01:13:28,760
Because then even maybe
the auctioneer is bad.

1338
01:13:28,760 --> 01:13:31,570
Or other people are
looking at this.

1339
01:13:31,570 --> 01:13:34,760
And you can just assume that C
of x is-- the C of x's are all

1340
01:13:34,760 --> 01:13:36,000
public.

1341
01:13:36,000 --> 01:13:39,840
But I also need a
constraint that's

1342
01:13:39,840 --> 01:13:43,530
associated with C of x
that corresponds to making

1343
01:13:43,530 --> 01:13:46,540
sure Alice is honest, correct?

1344
01:13:46,540 --> 01:13:50,940
So I need to make Alice
commit to something, right?

1345
01:13:50,940 --> 01:13:56,000
So what are the different
properties of the hash function

1346
01:13:56,000 --> 01:14:03,350
that if I use h of
x here, that I'd

1347
01:14:03,350 --> 01:14:08,090
want h to satisfy in order
for this whole process

1348
01:14:08,090 --> 01:14:14,700
to work like it's supposed to
work with paper and envelopes?

1349
01:14:14,700 --> 01:14:15,695
Yeah, go ahead.

1350
01:14:15,695 --> 01:14:18,406
AUDIENCE: It has to be
one-way [INAUDIBLE].

1351
01:14:18,406 --> 01:14:20,030
SRINIVAS DEVADAS: It
has to be one-way.

1352
01:14:20,030 --> 01:14:24,210
And explain to me-- so I
want a description of it

1353
01:14:24,210 --> 01:14:26,260
has to be one-way, because why?

1354
01:14:26,260 --> 01:14:27,957
AUDIENCE: Because
you want all the c

1355
01:14:27,957 --> 01:14:29,790
x's to be hidden from
all the other options.

1356
01:14:29,790 --> 01:14:31,200
SRINIVAS DEVADAS: Right.

1357
01:14:31,200 --> 01:14:40,930
C of x should not
reveal x, all right?

1358
01:14:40,930 --> 01:14:41,430
All right.

1359
01:14:41,430 --> 01:14:41,950
That's good.

1360
01:14:41,950 --> 01:14:44,320
Do you have more?

1361
01:14:44,320 --> 01:14:46,765
It has to be
collision resistant.

1362
01:14:53,180 --> 01:14:55,560
OK.

1363
01:14:55,560 --> 01:14:57,852
I guess.

1364
01:14:57,852 --> 01:15:00,580
A little bit more.

1365
01:15:00,580 --> 01:15:02,560
You're getting there.

1366
01:15:02,560 --> 01:15:05,672
What-- why is it
collision resistant?

1367
01:15:05,672 --> 01:15:08,132
AUDIENCE: Because you want
to make sure that Alice,

1368
01:15:08,132 --> 01:15:12,560
when she makes a bid that
she commits that bid.

1369
01:15:12,560 --> 01:15:15,512
If she's not going to resist
it then she could bid $100

1370
01:15:15,512 --> 01:15:16,805
and then find something else.

1371
01:15:16,805 --> 01:15:18,430
SRINIVAS DEVADAS:
That's exactly right.

1372
01:15:18,430 --> 01:15:26,540
So CR, because
Alice should not be

1373
01:15:26,540 --> 01:15:37,760
able to open this in
multiple ways, right?

1374
01:15:37,760 --> 01:15:41,940
And in this case it's
not TCR in the sense

1375
01:15:41,940 --> 01:15:45,350
that Alice controls
what her bids are.

1376
01:15:45,350 --> 01:15:51,440
And so she might find a pair
of bids that collide, correct?

1377
01:15:51,440 --> 01:15:55,840
She might realize that in
this particular hash function,

1378
01:15:55,840 --> 01:16:01,000
you know $10,000 and a billion
dollars collide, right?

1379
01:16:01,000 --> 01:16:04,450
And so she figures
depending on what happens,

1380
01:16:04,450 --> 01:16:07,820
she's a billionaire,
let's assume.

1381
01:16:07,820 --> 01:16:09,320
She's going to open
the right thing.

1382
01:16:09,320 --> 01:16:11,320
She's a billionaire, but
she doesn't necessarily

1383
01:16:11,320 --> 01:16:13,390
want to spend the billion, OK?

1384
01:16:13,390 --> 01:16:15,040
So that's that, right?

1385
01:16:15,040 --> 01:16:18,360
But I want more.

1386
01:16:18,360 --> 01:16:19,115
Go ahead.

1387
01:16:19,115 --> 01:16:21,590
AUDIENCE: You don't
want it to be malleable.

1388
01:16:21,590 --> 01:16:23,482
Assuming that the
auctioneer is not honest

1389
01:16:23,482 --> 01:16:25,690
because you don't want to
accept a bribe from someone

1390
01:16:25,690 --> 01:16:27,200
and then change
everyone else's bid

1391
01:16:27,200 --> 01:16:29,485
to square root of
whatever they bid.

1392
01:16:29,485 --> 01:16:31,110
SRINIVAS DEVADAS:
That's exactly right.

1393
01:16:31,110 --> 01:16:34,480
Or plus 1, which is a
great example, right?

1394
01:16:34,480 --> 01:16:37,050
So there you go.

1395
01:16:37,050 --> 01:16:38,000
I ran out of Frisbees.

1396
01:16:38,000 --> 01:16:39,083
You can get one next time.

1397
01:16:42,610 --> 01:16:45,640
So yeah, I don't
need this anymore.

1398
01:16:45,640 --> 01:16:47,020
You're exactly right.

1399
01:16:47,020 --> 01:16:49,790
There's another-- it turns out
it's even more subtle than what

1400
01:16:49,790 --> 01:16:51,070
you just described.

1401
01:16:51,070 --> 01:16:54,470
And I think I might be able
to point that out to you.

1402
01:16:54,470 --> 01:16:59,730
But let me just first
describe this answer, which

1403
01:16:59,730 --> 01:17:02,960
gives us non-malleability.

1404
01:17:02,960 --> 01:17:06,130
So the claim is that you
also want non-malleability

1405
01:17:06,130 --> 01:17:08,000
in your hash function.

1406
01:17:08,000 --> 01:17:14,147
And the simple reason is,
given C of x-- and let's assume

1407
01:17:14,147 --> 01:17:14,980
that this is public.

1408
01:17:14,980 --> 01:17:16,646
It's certainly public
to the auctioneer,

1409
01:17:16,646 --> 01:17:19,530
and it could be public to
the other bidders as well.

1410
01:17:19,530 --> 01:17:23,370
Because the notion of
sealing is that you've

1411
01:17:23,370 --> 01:17:24,372
sealed it using C of x.

1412
01:17:24,372 --> 01:17:26,580
But people can see the
outside of the envelope, which

1413
01:17:26,580 --> 01:17:27,990
is C of x.

1414
01:17:27,990 --> 01:17:29,510
So everyone can see C of x.

1415
01:17:29,510 --> 01:17:32,250
You still want this to work,
even though all other bidders

1416
01:17:32,250 --> 01:17:33,650
can see C of x.

1417
01:17:33,650 --> 01:17:44,990
So given C of x, should
not be possible to produce

1418
01:17:44,990 --> 01:17:48,110
C of x plus 1.

1419
01:17:48,110 --> 01:17:49,250
You don't know x is.

1420
01:17:49,250 --> 01:17:54,050
But if you can produce C of
x plus 1, you win, all right?

1421
01:17:54,050 --> 01:17:57,590
And so that's the problem.

1422
01:17:57,590 --> 01:18:04,930
Now it turns out you
now say OK, am I done?

1423
01:18:04,930 --> 01:18:06,930
I want these three properties.

1424
01:18:06,930 --> 01:18:10,350
And I'm done, right?

1425
01:18:10,350 --> 01:18:13,060
There's a little
subtlety here which

1426
01:18:13,060 --> 01:18:15,750
these properties don't capture.

1427
01:18:15,750 --> 01:18:18,290
So that's why there's more here.

1428
01:18:18,290 --> 01:18:21,770
And I don't mean to
titillate, because I'll

1429
01:18:21,770 --> 01:18:24,000
tell you what is missing here.

1430
01:18:24,000 --> 01:18:29,370
But let's say that I have a hash
function that looks like this.

1431
01:18:33,600 --> 01:18:39,970
And this here is non-malleable.

1432
01:18:39,970 --> 01:18:41,690
It is collision resistant.

1433
01:18:41,690 --> 01:18:43,290
And it's one-way, all right?

1434
01:18:43,290 --> 01:18:46,730
So h of x has all these
wonderful properties,

1435
01:18:46,730 --> 01:18:48,710
all right?

1436
01:18:48,710 --> 01:18:52,160
I'm creating an h
prime x that looks

1437
01:18:52,160 --> 01:18:54,660
like this, which is
a concatenation of h

1438
01:18:54,660 --> 01:19:00,210
of x, and giving away the most
significant bit of x, which

1439
01:19:00,210 --> 01:19:01,670
is my bid, right?

1440
01:19:01,670 --> 01:19:03,780
I'm just giving
that away, right?

1441
01:19:03,780 --> 01:19:08,190
The problem here is
that we haven't really

1442
01:19:08,190 --> 01:19:11,660
made our properties
broad enough to solve

1443
01:19:11,660 --> 01:19:14,230
this particular
application to the extent

1444
01:19:14,230 --> 01:19:19,140
that there's contrived cases
where these properties aren't

1445
01:19:19,140 --> 01:19:20,420
enough, OK?

1446
01:19:20,420 --> 01:19:22,180
And the reason is simple.

1447
01:19:22,180 --> 01:19:30,000
h prime x is arguably
NM, CR, and OW.

1448
01:19:30,000 --> 01:19:32,660
And I won't go into to
each of those arguments.

1449
01:19:32,660 --> 01:19:36,630
But you can think
about it, right?

1450
01:19:36,630 --> 01:19:40,030
If I'm just giving you one
bit, there's 159 others,

1451
01:19:40,030 --> 01:19:42,140
there's a couple of
hundred others, whatever it

1452
01:19:42,140 --> 01:19:43,860
is that I have in the domain.

1453
01:19:43,860 --> 01:19:46,230
It's not going to be invertible.

1454
01:19:46,230 --> 01:19:49,420
h prime x is not going to
be invertible if h of x

1455
01:19:49,420 --> 01:19:51,080
is not invertible.

1456
01:19:51,080 --> 01:19:57,880
h prime x is not going to be
breakable in terms of collision

1457
01:19:57,880 --> 01:20:00,950
resistance if h of
x is not breakable,

1458
01:20:00,950 --> 01:20:02,450
and so on and so forth.

1459
01:20:02,450 --> 01:20:04,740
But if I had a hash
function like that,

1460
01:20:04,740 --> 01:20:09,340
is it a good hash function
for my commitment application?

1461
01:20:09,340 --> 01:20:10,090
No, obviously not.

1462
01:20:10,090 --> 01:20:12,298
Because if I publicize this
hash function-- remember,

1463
01:20:12,298 --> 01:20:13,890
everything is public
here with respect

1464
01:20:13,890 --> 01:20:18,030
to h and h prime-- you
are giving away the most

1465
01:20:18,030 --> 01:20:21,360
significant that
corresponds to your bid

1466
01:20:21,360 --> 01:20:23,350
in this particular
hash function, right?

1467
01:20:23,350 --> 01:20:33,170
So you really need a little bit
more than these for secrecy,

1468
01:20:33,170 --> 01:20:34,200
for true secrecy.

1469
01:20:37,510 --> 01:20:39,890
But in the context
of this example,

1470
01:20:39,890 --> 01:20:41,770
I mean it's common
sense that you would not

1471
01:20:41,770 --> 01:20:43,550
use the hash function
like that, right?

1472
01:20:43,550 --> 01:20:46,950
So it's not that there's
anything profound here.

1473
01:20:46,950 --> 01:20:48,540
It's just that I
want to make sure

1474
01:20:48,540 --> 01:20:51,480
that you understand the
nuances of the properties

1475
01:20:51,480 --> 01:20:52,580
that we're requiring.

1476
01:20:52,580 --> 01:20:55,560
We had all the
requirements corresponding

1477
01:20:55,560 --> 01:20:58,900
to the definitions
of NM and CR and OW.

1478
01:20:58,900 --> 01:21:01,150
And you need a little bit
more for this example, where

1479
01:21:01,150 --> 01:21:04,300
you have to say something,
perhaps informally,

1480
01:21:04,300 --> 01:21:10,870
like the bits of your auction
are scrambled in the final hash

1481
01:21:10,870 --> 01:21:14,010
output, which most hash
functions should do anyway,

1482
01:21:14,010 --> 01:21:15,730
and h of x will definitely do.

1483
01:21:15,730 --> 01:21:19,290
But you kind of unscrambled
it by adding this little thing

1484
01:21:19,290 --> 01:21:22,210
in here, corresponding to
the most significant thing,

1485
01:21:22,210 --> 01:21:23,050
all right?

1486
01:21:23,050 --> 01:21:25,480
So I'll stop with that.

1487
01:21:25,480 --> 01:21:29,760
Let me just say that the
operation-- or sorry,

1488
01:21:29,760 --> 01:21:33,590
the work involved in
creating hash functions that

1489
01:21:33,590 --> 01:21:37,430
are poly-time computable
is research work.

1490
01:21:37,430 --> 01:21:40,290
People put up hash functions
and they get broken,

1491
01:21:40,290 --> 01:21:43,770
like MD4 was put up in '92 and
then got broken, SHA-1 and so

1492
01:21:43,770 --> 01:21:44,700
on and so forth.

1493
01:21:44,700 --> 01:21:49,580
And so I just encourage you
to look up SHA-3 and just take

1494
01:21:49,580 --> 01:21:52,480
a quick scan and what
the complexity of SHA-3

1495
01:21:52,480 --> 01:21:56,820
is with respect to computing the
hash given an arbitrary string,

1496
01:21:56,820 --> 01:21:57,590
all right?

1497
01:21:57,590 --> 01:21:59,575
I'll stick around for questions.
